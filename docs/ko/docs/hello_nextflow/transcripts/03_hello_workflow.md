# Part 3: Hello Workflow - 대본

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보기 및 개선 제안](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/zJP7cUYPEbA?si=Irl9nAQniDyICp2b&amp;list=PLPZ8WHdZGxmXiHf8B26oB_fTfoKQdhlik" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 사항"

    이 페이지는 대본만 보여줍니다. 전체 단계별 지침은 [교육 자료](../03_hello_workflow.md)로 돌아가십시오.

    대본에 표시된 섹션 번호는 참고용으로만 제공되며 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영합니다

안녕하세요, "Hello Nextflow" 교육 과정의 세 번째 파트에 오신 것을 환영합니다.

이 챕터의 제목은 "Hello Workflow"입니다.

챕터 2에서는 하나의 프로세스로 구성된 간단한 워크플로를 만들었지만, 실제로 파이프라인은 여러 분석 단계를 함께 연결할 수 있기 때문에 유용합니다.

이 챕터에서는 초기 예제를 가져와서 좀 더 현실적으로 확장할 것입니다.

몇 가지 추가 단계를 추가하고 채널을 사용하여 이러한 단계를 연결하는 방법을 살펴볼 것입니다.

단일 프로세스로 축소할 수 있는 여러 작업을 살펴보고 여러 입력과 여러 출력을 가질 수 있는 프로세스를 살펴볼 것입니다.

좋습니다, 시작하겠습니다.

자, 시작해봅시다. 이전과 동일합니다. training.nextflow.io로 이동합니다. Hello Nextflow, 챕터 3. Hello Workflow. 그리고 작업 공간을 열겠습니다. 이전 챕터의 모든 작업 파일을 정리했고 Hello Workflow를 열겠습니다.

이것은 지금까지 작업해온 것과 동일한 파일이므로 익숙할 것입니다. say hello 프로세스가 있습니다. greetings CSV 파일이 있는 params.greeting이 있고, CSV 파일을 로드하고 채널을 생성하여 프로세스에 전달하는 하단의 워크플로가 있습니다.

## 0. 준비 운동: hello-workflow.nf 실행하기

원하시면 이것을 시도해보고 예상대로 작동하는지 확인할 수 있습니다. 터미널을 로드하여 nextflow run hello workflow nf를 실행하고 엔터를 누릅니다.

좋습니다. 세 개의 프로세스가 실행됩니다. 세 개의 출력이 있는 results 디렉토리가 있습니다. Bonjour. Hello. Holà. 그럼 이 파일들을 닫고, 터미널을 닫고, 스크립트로 돌아갑시다.

## 1. 워크플로에 두 번째 단계 추가하기

좋습니다. 예제에서는 기본적이고 도메인에 구애받지 않도록 노력하겠습니다. 따라서 두 번째 프로세스는 이러한 문자열과 단어를 간단한 방식으로 조작할 것입니다. translate Unix 명령을 사용하여 이러한 파일을 가져와서 모두 대문자로 만들 것입니다. "tr" 명령으로 수행합니다.

## 1.1. 대문자 변환 명령을 정의하고 터미널에서 테스트하기

bash 터미널에서 이것을 시도하고 작동하는지 확인할 수 있습니다. echo, Hello World를 입력하고 파이프 문자로 tr에 전달합니다. 그리고 인식 패턴, a부터 z, 그리고 변환할 대상을 제공합니다. 대문자 A부터 Z까지.

이것은 문자 그대로 A부터 Z까지의 문자를 다루기 때문에 매우 간단합니다. 따라서 악센트가 있는 문자나 그런 것들에는 작동하지 않습니다. 하지만 예제의 목적으로는 이해하실 수 있을 것입니다.

엔터를 누르면 터미널에 대문자 HELLO WORLD가 출력됩니다. 그리고 이전과 마찬가지로 원하면 파일로 리디렉션할 수 있습니다. Outfile.

좋습니다. 이것을 정리하겠습니다.

## 1.1. 대문자 변환 단계를 Nextflow 프로세스로 작성하기

스크립트로 돌아가서 이 bash 명령을 처리할 새 프로세스를 작성하겠습니다. 이전 프로세스를 복사하여 아래에 붙여넣고 convert to upper라고 부르겠습니다. 대문자용입니다. 동일한 publishDir results를 사용하겠지만 여기서 몇 가지 변경을 하겠습니다. val 대신 path input file을 사용하고, 출력 파일이 덮어쓰기되지 않도록 여기에 upper라는 접두사를 사용하겠습니다. 그리고 입력의 변수 이름을 사용하겠습니다. 그런 다음 여기 스크립트를 변경하고, 대신 입력 파일에 cat을 사용하고 Bash에서 했던 것처럼 TR, a-z, upper input file .txt를 사용하겠습니다. 좋습니다, 저장을 클릭하겠습니다.

## 1.2. workflow 블록에 새 프로세스 호출 추가하기

이제 아래로 스크롤하면 실제로 이 프로세스를 호출해야 합니다. 스크립트에 프로세스를 추가하는 것만으로는 충분하지 않습니다. Nextflow에게 이 프로세스를 실행해야 하고 어디서 실행해야 하는지 알려야 합니다.

그래서 여기서 convert to upper를 실행하겠습니다.

좋습니다, 여기서 인수가 필요하다는 오류가 발생하고 있습니다. 확실히 이 프로세스가 실제로 무언가를 할 수 있도록 무언가를 전달해야 합니다.

## 1.3. 첫 번째 프로세스의 출력을 두 번째 프로세스로 전달하기

우리가 할 일은 이 프로세스에서 출력을 가져오는 것입니다. 그래서 이름 say hello를 가져와서 dot out을 수행합니다.

단일 출력만 있는 프로세스를 새 프로세스에 전달하는 이와 같은 간단한 예제의 경우, 단일 입력이 있으므로 필요한 전부여야 합니다. 저장을 클릭하고 터미널을 불러와서 다시 실행해보겠습니다.

## 1.4. 워크플로를 다시 실행하기

이제 이전에 이 워크플로를 실행했을 때의 work 디렉토리를 정리하지 않았습니다. 다시 실행하고 부분 캐싱이 어떻게 작동하는지 보여주는 기회로 사용하겠습니다. 그래서 단일 대시 resume을 수행합니다. 마지막으로 실행했을 때와 정확히 동일했던 첫 번째 프로세스의 출력을 재사용하기를 바랍니다. 하지만 이제 이전에 실행된 적이 없는 새 프로세스가 있으므로 처음부터 실행됩니다. 그리고 확실히 첫 번째 프로세스가 캐시 출력을 사용했고 두 번째 출력이 3개 중 3개를 실행했음을 알 수 있습니다. 또한 이제 첫 번째 프로세스인 say hello가 세 번 실행되고 두 번째 프로세스인 convert to upper가 세 번 실행되는 두 프로세스가 모두 여기에 있음을 알 수 있습니다.

다시 실행하면, 상기시켜드리자면, -ansi-log false로 실행하면 각각 세 개씩 총 6개의 다른 프로세스 작업이 실행되는 것을 볼 수 있습니다. 이것은 우리가 기대했던 것과 정확히 일치합니다. 첫 번째 프로세스가 세 번 실행되고 해당 출력을 두 번째 프로세스로 전달하여 세 번 실행됩니다.

work 디렉토리 내부를 살펴보고 Nextflow가 이러한 파일 입력을 어떻게 처리하는지 확인해봅시다. 두 번째 프로세스에서 여기 해시 디렉토리를 가져오면 이러한 파일을 보기 위해 -a로 tree 명령을 다시 사용할 수 있습니다. 여기에 Bonjour-output.txt 파일인 입력 파일이 있고 실제로 심볼릭 링크입니다. 이 화살표가 보여주는 것이고, 이전 work 디렉토리의 파일을 가리키고 있습니다.

이것은 말이 됩니다. Nextflow는 자체 캡슐화된 디렉토리에서 각 작업의 실행을 처리하므로 완전히 독립적입니다. 그러나 이전 단계의 파일을 입력으로 제공해야 합니다. work 디렉토리 외부에 도달하여 해당 파일을 가져오는 대신, Nextflow는 work 디렉토리로 스테이징합니다.

여기처럼 공유 파일 시스템이 있는 경우 추가 파일 공간을 사용하지 않도록 심볼릭 링크를 사용하여 수행합니다. 다른 위치의 버킷이 있는 클라우드 스토리지를 사용하는 경우 해당 파일을 가져와서 실제로 work 디렉토리에 복사합니다.

command sh 파일을 살펴봅시다. code work, command sh를 수행하면 확실히 로컬 디렉토리에서 해당 파일에 액세스하고 있음을 알 수 있습니다. 따라서 모든 것이 매우 독립적이고 깨끗합니다.

또한 results 디렉토리를 확인하고 이러한 파일이 제대로 출력되었는지 확인할 수 있습니다. 그리고 확실히 results에서 첫 번째 프로세스의 모든 출력 파일과 두 번째 프로세스의 모든 출력 파일을 볼 수 있습니다. 그리고 우리가 바랐던 대로 모두 대문자입니다.

여기서 Nextflow의 힘이 빛나기 시작합니다. 매우 최소한의 코드로 Nextflow는 별도의 work 디렉토리 내에서 깨끗한 캡슐화와 입력 및 출력 파일 스테이징 및 파일 게시를 자동으로 처리하여 이러한 작업을 병렬로 실행합니다. 따라서 분석 워크플로의 복잡성을 확장함에 따라 이 기능이 정말 정말 가치가 있음을 알 수 있습니다.

## 2. 모든 인사말을 수집하는 세 번째 단계 추가하기

좋습니다. 이러한 단계는 일대일이었습니다. 첫 번째 프로세스에서 하나의 출력이 두 번째 프로세스의 하나의 입력으로 전달되었습니다. 다음으로, 이러한 다른 출력을 단일 프로세스 작업으로 수집하는 방법에 대해 이야기하겠습니다. 이것은 다시 매우 일반적인 작업입니다. 그럼 빠르게 터미널을 불러와서 이것의 드라이 런을 수행해봅시다.

## 2.1. 수집 명령을 정의하고 터미널에서 테스트하기

속임수를 쓰고 교육 자료에서 예제 bash 코드를 복사하여 엔터를 누르겠습니다.

여기서 볼 수 있는 것은 이 echo 명령을 세 개의 다른 출력 파일에 세 번 실행했고, 여기서 볼 수 있습니다. 그런 다음 cat 명령을 사용하여 이 세 개의 다른 파일 각각의 출력을 출력하고 단일 수집 파일로 리디렉션했습니다.

그리고 "cat COLLECTED-output"을 수행하면 이제 단일 파일에 이 세 개의 다른 파일의 내용이 있는 것을 볼 수 있습니다.

## 2.2. 수집 단계를 수행하는 새 프로세스 만들기

이제 Nextflow 파이프라인 내에서 동일한 것을 복제할 수 있는지 확인해봅시다.

위로 스크롤하여 세 번째 프로세스를 만들겠습니다. 이전 프로세스를 복사하고 이번에는 Collect Greetings라고 부르겠습니다.

bash 터미널에서 collected output txt라고 불렀습니다. 그래서 여기에 동일한 path output을 사용하겠습니다. 그리고 여기서 리디렉션을 수행하므로 동일한 방식으로 저장됩니다.

좋습니다. 해당 명령의 시작 부분에서 발생하는 것을 변경해야 하며 여기서 입력 파일이 무엇인지 생각해야 합니다. 사실 이 프로세스는 여러 입력 파일을 받을 것입니다. path를 유지하고 이것을 input files(복수형)라는 새 변수로 변경하겠습니다.

그런 다음 bash 스크립트에서 했던 것처럼 다시 cat을 사용하겠습니다. 그리고 여기서 변수를 사용하겠습니다.

이제 이것이 작동하지 않을 것이라고 생각할 수 있습니다. 이전에 문자열 배열 또는 경로 배열이 프로세스에 전달되어 오류가 발생한 실패를 봤습니다. 하지만 실제로 여기서 Nextflow는 올바른 방식으로 자동으로 이것을 처리할 것입니다. 여러 다른 입력 파일을 가져와서 여기에 다른 파일 경로를 출력할 것입니다.

물론 cat 명령이 이와 같은 일련의 파일 이름을 받을 수 있다는 것이 도움이 됩니다. 각 파일 경로 전에 인수가 필요한 다른 명령이나 그런 것을 사용하는 경우 이러한 파일 경로의 반복을 처리할 수 있도록 여기에 좀 더 많은 코드와 로직이 있어야 합니다. 하지만 이 경우에는 그냥 작동해야 합니다.

## 2.3. 워크플로에 수집 단계 추가하기

좋습니다, 워크플로로 내려가서 새 프로세스를 추가하겠습니다. Collect greetings. 그리고 다시 convert to upper out의 출력을 가져옵니다. 저장하겠습니다.

시도해봅시다. nextflow run hello workflow.

좋습니다, 워크플로가 실행되었지만 뭔가 이상합니다. 예상대로 첫 번째 단계가 세 번 실행되었습니다. 두 번째는 세 번의 작업이 있지만 마지막에도 모든 출력을 병합하는 단일 작업만 예상했는데 세 개의 작업이 있습니다.

results 디렉토리로 가면. 또한 collected output에 세 개 대신 단일 값만 있는 것을 볼 수 있습니다. 이는 해당 출력 파일이 세 개의 다른 값으로 세 번 덮어쓰기되었기 때문입니다.

이것은 이전 단계에서 했던 것과 같은 방식으로 여기서 하나의 출력을 하나의 입력으로 전달했기 때문에 말이 됩니다.

## 2.4. 연산자를 사용하여 인사말을 단일 입력으로 수집하기

따라서 여기서 세 개의 요소가 있는 이 채널을 가져와서 단일 요소로 축소하여 최종 프로세스가 한 번만 실행되도록 하는 연산자가 필요합니다.

이를 위해 collect 연산자를 사용할 것입니다. 워크플로 내에서 직접 수행할 수 있습니다. .out을 수행하고 마지막에 .collect 연산자를 연결할 수 있습니다.

저장을 누릅니다. 그리고 이 교육의 목적을 위해 이전에 했던 것처럼 몇 가지 view 연산자도 수행하겠습니다. 그래서 collect 연산자를 사용하기 전과 후의 이 채널을 살펴볼 수 있으므로 무슨 일이 일어나고 있는지 이해할 수 있습니다.

이 채널을 가져와서 collect를 제거하고 dot view greetings를 수행하겠습니다. 그런 다음 이 줄을 복제하고 collect 연산자를 추가하겠습니다. 그리고 그것을 after로 변경하겠습니다.

이것은 이것을 호출하는 곳과 별개이지만 동일한 출력 채널에서 동일한 연산자 호출을 사용하고 있으므로 괜찮습니다.

좋습니다, 저장을 누르고 터미널에서 시도해봅시다. nextflow run을 수행하겠습니다. Hello, workflow. 스크립트를 다시 실행합니다.

좋습니다. 더 나아 보입니다. 이전과 마찬가지로 처음 두 프로세스가 세 번 실행되었고 이제 최종 프로세스는 한 번만 실행되었습니다.

view 연산자로 출력된 것을 보면 아래에 before collect라고 했고, 이것이 여기 출력이고, 세 번 출력되었습니다. 그리고 각각에 대해 단일 경로가 있음을 알 수 있습니다. 그리고 after collect 이후에는 세 개의 경로 배열이 있는 것을 볼 수 있습니다. 따라서 예상대로입니다.

좋습니다, results 파일을 확인하고 이번에는 예상대로인지 확인해봅시다. 확실히 이제 파일에 세 줄이 있습니다 - 이 세 개의 출력을 단일 출력 파일로 성공적으로 연결했습니다. 환상적입니다.

좋습니다, 정리하고 다음 단계로 넘어가겠습니다. 그리고 깔끔하게 유지하기 위해 이러한 view 문을 삭제하겠습니다.

## 3. 최종 출력 파일 이름을 고유하게 지정하기 위해 프로세스에 하나 이상의 입력 전달하기

좋습니다. 지금까지 모든 프로세스는 단일 입력만 받았습니다. 이제 프로세스에 하나 이상의 입력을 추가하여 어떻게 작동하는지 확인하는 연습을 하겠습니다. 이를 위해 이 collect greetings 예제를 사용하겠습니다.

워크플로를 실행할 때마다 results 디렉토리에서 해당 파일을 덮어썼는데, 우리가 원하는 것이 아닐 수 있습니다.

## 3.1. 출력 파일에 대한 사용자 정의 이름을 허용하도록 수집기 프로세스 수정하기

이 예제에서는 출력 파일 이름을 사용자 정의할 수 있도록 추가 매개변수를 전달할 것입니다.

프로세스에 두 번째 입력을 추가하는 것은 매우 간단합니다. input 블록에 두 번째 줄을 추가하기만 하면 됩니다. 이번에는 문자열을 전달하려고 하므로 path가 아니라 value이고 batch underscore name이라고 부르겠습니다.

이제 script 블록에서 이 변수를 사용할 수 있으며, collected dash dollar batch name이라고 하겠습니다.

여기서 변수 이름 주위에 중괄호를 사용하고 있습니다. 이것은 단지 문자열의 나머지 부분과 분리하기 위한 것이며 이 경우에는 필요하지 않을 수도 있지만 읽기가 더 쉽다고 생각합니다.

좋습니다. 마지막으로 이제 파일 이름이 변경되었으므로 출력 경로를 업데이트해야 합니다. 따라서 예상대로 batch name을 출력 경로에 넣겠습니다.

## 3.2. batch 명령줄 매개변수 추가하기

이제 어딘가에서 batch name을 전달해야 하며, 워크플로를 실행할 때 명령줄에서 수행할 수 있도록 두 번째 매개변수를 만들 것입니다.

그래서 params batch name을 수행하고 기본적으로 이것을 test batch라고 부르겠습니다. 이제 프로세스를 호출하는 곳에서 이 특수 매개변수 변수를 사용할 수 있습니다.

그리고 확실히 VS Code는 이제 이 프로세스에 인수가 충분하지 않으며 두 번째 입력이 필요하다고 알려주고 있습니다.

간단히 쉼표를 수행하고 새 변수를 전달하면 오류가 사라집니다.

여기서 입력의 순서가 정말 중요합니다. 첫 번째 프로세스 입력은 path였고 두 번째 입력은 name입니다. 여기서 순서를 변경하면 프로세스를 호출할 때도 순서를 변경해야 합니다. 그렇지 않으면. Next는 잘못된 채널을 잘못된 입력에 전달할 것입니다.

## 3.3. 워크플로 실행하기

좋습니다, 시도해보고 작동하는지 확인해봅시다. "nextflow run hello- workflow를 수행해봅시다. 좋습니다, 이전처럼 실행되었습니다. results 디렉토리를 살펴봅시다.

확실히 여기 파일 이름은 이제 "collected test batch output txt"라고 합니다. 환상적입니다.

이제 다시 실행하여 덮어쓸 수 있는지 확인해봅시다. 이번에는 여기 특수 매개변수 변수 이름과 일치하도록 --batch_name을 수행하겠습니다. 그리고 demo output이라고 부르겠습니다.

워크플로를 다시 실행하고 무슨 일이 일어나는지 확인하겠습니다.

좋습니다, 이제 collected demo output .txt가 있습니다. 그리고 이 파일 이름이 저것과 다르기 때문에 덮어쓰지 않았습니다. 둘 다 이제 results 디렉토리에 있습니다.

## 4. 수집기 단계에 출력 추가하기

좋습니다, 거기서 프로세스에 여러 입력을 제공하는 것을 보여줬지만 여러 출력은 어떻습니까? 이 예제에서는 처리된 인사말의 수를 계산하고 이 collect greeting 단계의 보조 출력으로 출력할 것입니다.

## 4.1. 인사말을 카운트하고 출력하도록 프로세스 수정하기

여기서 약간의 트릭을 사용할 것입니다. Nextflow 프로세스에는 다중 줄 문자열이 있는 script 블록이 있으며, 이것은 bash 출력으로 dot 명령 dot sh에 전달됩니다. 하지만 실제로 그 위에 사용자 정의 코드를 작성할 수 있으며, 이것은 작업의 일부로 실행되지만 bash 스크립트 내에 포함되지 않습니다.

Nextflow 구문의 내장 함수 중 하나는 size라고 합니다. 그래서 path input을 가져와서 count underscore greetings라고 하겠습니다. 변수 이름을 정의하기 위해서입니다. input files를 가져와서 그것에 "size"를 호출할 것입니다.

이 함수는 이 입력 채널의 크기를 계산하여 변수에 할당합니다.

이제 output 블록의 일부로 해당 변수를 반환할 수 있습니다. 따라서 파일이 아니라 값이므로 val이라고 합니다. 그리고 count greetings.

이제 이것만으로도 충분하며 이제 이 프로세스에서 이러한 다른 출력에 액세스할 수 있습니다. 그러나 위치 방식으로 액세스해야 합니다. 따라서 0과 1과 같은 인덱스 키를 사용합니다.

출력을 더 쉽게 얻을 수 있도록 이름을 지정할 수 있으며 emit 문을 사용하여 수행합니다.

그래서 쉼표 emit out file 또는 이것을 호출하고 싶은 것을 수행합니다. 그리고 여기서 emit count를 수행합니다. 이것은 기본적으로 워크플로 블록 나중에 특정 출력을 쉽게 참조할 수 있도록 약간 더 깨끗한 코드를 작성하는 데 도움이 되는 데코레이터일 뿐입니다.

## 4.2. 워크플로 끝에서 출력 보고하기

좋습니다. 워크플로 블록으로 스크롤하면 이제 collect greetings의 출력을 가져올 수 있고, collect greetings, dot out을 수행할 수 있으며, VS Code 확장에서 제안하는 두 개의 명명된 출력을 볼 수 있습니다. 매우 편리합니다.

그래서 방금 생성한 count 값을 얻기 위해 dot count를 수행하고 view를 수행하여 명령줄에 출력되도록 하겠습니다. 따라서 워크플로를 실행할 때 볼 수 있습니다.

조금 더 좋게 만들기 위해 클로저에 뭔가를 작성하겠습니다. num greetings, there were greetings greetings.

그리고 실제로 다른 출력은 신경 쓰지 않습니다. 왜냐하면 다른 프로세스의 입력으로 사용하지 않기 때문입니다. 하지만 원하면 다운스트림에서 다른 프로세스에 입력으로 쉽게 전달할 수 있는 방법을 볼 수 있습니다.

## 4.3. 워크플로 실행하기

저장을 클릭하겠습니다. 터미널을 살펴보고 시도해봅시다.

좋습니다, 환상적입니다. 여기 있습니다. 세 개의 인사말이 있습니다. 정확히 맞습니다.

좋습니다, 대단합니다. 이 챕터의 끝입니다. 여기까지 오신 것을 축하합니다. 이제 입력과 출력 및 워크플로 내의 로직을 처리할 수 있는 매우 현실적인 워크플로를 구축하기 시작했습니다.

이러한 워크플로 파일이 길어지면 약간 다루기 어려워지기 시작합니다. 따라서 다음 챕터에서는 워크플로 내에서 코드를 찾고 유지 관리하기 쉽도록 Nextflow 코드를 별도의 파일로 모듈화하는 방법을 살펴보겠습니다.

다음 비디오 챕터 4에서 만나요. Hello Modules.

[다음 비디오 대본 :octicons-arrow-right-24:](04_hello_modules.md)
