# 파트 3: Hello Workflow - 비디오 스크립트

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보고 개선 사항 제안하기](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/_aO56V3iXGI?si=Irl9nAQniDyICp2b&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 참고 사항"

    이 페이지는 스크립트만 보여줍니다. 전체 단계별 지침은 [과정 자료](../03_hello_workflow.md)로 돌아가세요.

    스크립트에 표시된 섹션 번호는 참고용으로만 제공되며, 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영 인사 및 요약

안녕하세요. Hello Nextflow의 파트 3에 다시 오신 것을 환영합니다. 이번 파트는 Hello Workflow라고 하며, 파이프라인 또는 워크플로우라는 이름을 정당화하는 과정의 시작입니다.

지금까지의 단순한 파이프라인 스크립트에 하나의 프로세스가 있었는데, 이제 추가 프로세스들을 더하고 Nextflow가 이 조정과 파이프라인을 통한 데이터 흐름을 어떻게 처리하는지 살펴보겠습니다.

코드스페이스로 돌아가보겠습니다. 저는 모든 .nextflow\* 디렉토리와 work 디렉토리 등을 삭제하여 깨끗하게 유지하려고 했습니다. 과정의 이전 파트에서 남은 파일들이 있어도 걱정하지 마세요.

hello-workflow.nf라는 파일에서 작업하겠습니다. 이전과 마찬가지로, 이 파일은 지금까지 구축한 스크립트를 기본적으로 나타내며 깨끗한 시작점을 제공합니다. 그리고 다시 출력에서 경로가 이제 hello_workflow임을 확인할 수 있습니다. 따라서 게시된 파일들은 results 폴더의 다른 하위 디렉토리로 이동해야 합니다.

지금까지의 상황을 요약하면, 하나의 입력 greeting과 하나의 출력 greeting 파일을 가진 단일 프로세스가 있습니다. 그리고 파일에 echo 명령을 수행하는 간단한 Bash 스크립트가 있습니다.

params 블록에 단일 워크플로우 입력이 있으며, 경로를 예상하고 기본값은 data/greetings.csv입니다. 이것은 여기 위에 있는 이 파일입니다.

그런 다음 워크플로우 자체에 main 블록이 있습니다. 채널을 생성하고 있습니다. CSV를 행으로 분석한 다음 각 배열의 첫 번째 요소를 가져와서, 그 채널을 프로세스로 전달합니다. 프로세스는 세 개의 작업을 생성하고, 워크플로우에서 해당 프로세스의 출력을 게시합니다.

그리고 마지막으로 output 블록에서 Nextflow에게 이 채널의 파일들을 hello_workflow라는 디렉토리에 게시하도록 지시합니다. 그리고 소프트 링크 대신 파일들을 복사하도록 합니다.

## 1. 워크플로우에 두 번째 단계 추가하기

좋습니다. 이번 파트에서는 워크플로우에 두 번째 프로세스를 추가하겠습니다. sayHello 프로세스의 출력을 가져와서 두 번째 단계에서 처리하여, 해당 파일 내의 모든 문자를 대문자로 변환하는 convertToUppercase를 수행합니다.

이것은 단지 간단한 예제입니다. 단순한 문자열 처리일 뿐이지만, 워크플로우 내에서 로직을 어떻게 가져올 수 있는지 보여줍니다.

이를 위해 "tr"이라는 bash 명령을 사용하겠습니다. 이는 translate의 약자입니다. 오래전부터 존재해온 Unix 명령입니다. 익숙하지 않으시더라도 괜찮습니다. 저도 교육 전에는 사용해본 적이 없다고 생각합니다만, 터미널에서 매우 빠르게 테스트할 수 있습니다. "echo 'hello world'"를 입력한 다음 'tr'로 파이프하고 따옴표 안에 문자 범위를 지정합니다. 소문자 A부터 Z까지, 그리고 대문자 A부터 Z까지 원하는 것을 입력합니다. 이것은 단순히 이 문자들을 저 문자들로 변환하라고 말하는 것입니다.

엔터를 누르면 모든 것이 대문자로 변환된 것을 볼 수 있습니다. 사람들에게 소리치는 것을 좋아한다면 매우 좋습니다.

이것이 두 번째 프로세스에서 사용할 매우 간단한 스타일의 bash 명령입니다.

## 1.2. 대문자 변환 단계를 Nextflow 프로세스로 작성하기

스크립트로 돌아가서, 조금 편법을 쓰겠습니다. 교육 문서에서 코드를 복사하겠습니다. 하지만 무슨 일이 일어나고 있는지 정확히 볼 수 있습니다.

여기 새로운 프로세스가 있습니다. 이것을 convertToUpper라고 불렀지만, 원하는 대로 부를 수 있습니다.

이전과 마찬가지로 단일 입력 경로가 있습니다. 값 채널이 아니라 경로 채널입니다. 그리고 단일 출력이 있습니다.

스크립트 블록에서 입력 파일에 "cat"을 수행합니다. 원한다면 이것을 중괄호 안에 넣을 수 있습니다. 그리고 그 변수를 가져옵니다. 동일한 bash 명령을 파이프에서 실행하고 결과를 이 파일 이름으로 파일에 작성합니다. 그러면 출력 경로가 이것을 가져옵니다.

이제 이 새로운 프로세스로 무언가를 해야 합니다. 워크플로우의 다른 로직을 구축하는 곳으로 내려가서, 첫 번째 프로세스 이후에 두 번째 프로세스를 실행하겠습니다. 따라서 convertToUpper가 여기 프로세스의 이름입니다.

입력을 받으므로 그냥 호출할 수 없습니다. 첫 번째 프로세스의 출력을 처리하고 싶습니다. 따라서 이것처럼, 이러한 결과를 게시하는 sayHello out처럼, 여기서 입력으로 동일한 결과를 사용하고 싶으므로 복사하여 거기에 넣을 수 있습니다.

sayHello 프로세스 ".out"을 원하고, Nextflow는 이것이 여기 있는 간단한 단일 출력 레코드를 의미한다는 것을 알고 있습니다. 이것은 이 파일입니다. 따라서 이것은 두 번째 프로세스에 입력으로 전달됩니다.

## 1.5. 워크플로우 출력 게시 설정하기

좋습니다. 그리고 마지막으로, 이 두 번째 프로세스의 결과를 실제로 저장하기 위해, 워크플로우에서 게시해야 하며, 그런 다음 이전과 동일한 구문으로 output 블록에서 정의해야 합니다. 이것을 복사하여 second outputs라고 하거나 원하는 대로 부를 수 있습니다.

관심 있는 프로세스 이름인 convertToUpper out을 가져오고, 여기 output 블록에서 이것을 추가하고 여기서 동일한 속성을 사용할 수 있습니다. 따라서 이 파일들도 Hello Workflow 하위 디렉토리에 원하고, 복사하고 싶습니다.

좋습니다. 실행해 보겠습니다. 터미널을 불러와서 "nextflow run hello-workflow.nf"를 입력하고 어떻게 작동하는지 보겠습니다. 이전 파트와 다르게 보이는지 확인해 보겠습니다.

Nextflow가 시작됩니다. 문서에서는 "-resume"으로 수행하라고 되어 있지만, 제가 모든 work 디렉토리를 삭제했으므로 여기서는 차이가 없었을 것입니다. 하지만 그렇게 했다면 그것도 작동할 것입니다.

거의 똑같아 보입니다. 하지만 이제 여기에 두 번째 출력 라인이 있고, 방금 추가한 두 번째 프로세스의 이름을 볼 수 있습니다. 그리고 확실히, 세 번 성공적으로 실행된 것을 볼 수 있습니다.

훌륭합니다. 이전 work 디렉토리가 있고 "-resume"으로 수행했다면, 파이프라인의 첫 번째 단계만 캐시되었을 것입니다. 해당 출력이 정확히 동일했기 때문에 Nextflow는 이를 다시 재사용해야 한다는 것을 알았을 것입니다.

그리고 필요한 경우 -resume을 사용하여 워크플로우를 단계별로 반복적으로 구축할 수 있는 방법을 볼 수 있습니다.

좋습니다. 여기 results 디렉토리를 보고 작동했는지 확인해 보겠습니다. 여기 위에 더 많은 파일이 있습니다. 이전처럼 첫 번째 프로세스의 원본 파일이 있습니다. 그리고 확실히, upper 파일이 있고 문자가 모두 대문자이므로 작동했습니다. 정말 보기 좋습니다.

이러한 work 디렉토리 안을 확인하는 것도 흥미롭습니다. 이전과 마찬가지로 여기의 해시는 work 디렉토리에 해당합니다. 따라서 "ls work"를 보고 확장하면 여기에 다른 파일들을 볼 수 있습니다.

여기에 입력으로 가져온 첫 번째 프로세스의 출력 파일이 보입니다. 그리고 생성된 새로운 출력 파일을 볼 수 있습니다.

이제 "-la"로 수행하여 모든 파일을 나열하고 표시하면 몇 가지를 더 볼 수 있습니다. 먼저, 이 파일이 실제로 첫 번째 프로세스에 대한 소프트 링크임을 알 수 있습니다. 파일 공간을 절약하기 위해 가능하면 기본적으로 항상 소프트 링크입니다. 여기서 파일을 게시하지 않으며, 첫 번째 작업에서 두 번째 작업으로 해당 파일을 참조하여 모든 것이 하나의 작업 디렉토리 내에 캡슐화되고 다른 모든 것으로부터 안전하고 격리되도록 합니다.

.command.sh 파일을 보면 거기에 있어야 하기 때문입니다. "cat work/b8/56\*"를 수행하면 여기의 파일 경로가 상대적이므로 동일한 작업 디렉토리에 소프트 링크된 해당 입력 파일을 catting하는 것을 볼 수 있습니다.

이것이 모든 work 디렉토리가 보이는 방식입니다. Nextflow에서 볼 때, 해당 작업 디렉토리에 스테이징된 모든 입력 파일이 있을 것입니다. 그리고 생성된 모든 출력 파일도 있을 것입니다. 그래서 훌륭합니다. 예상대로 보입니다.

## 2.1. 수집 명령 정의 및 터미널에서 테스트하기

좋습니다. 워크플로우로 돌아가겠습니다. 다음 단계에서 무엇을 하고 싶습니까?

이제 두 개의 프로세스가 있고 이 하나의 CSV 파일을 가져와서 분석하고 분할합니다. 그런 다음 이러한 각 프로세스에 대해 세 개의 작업이 있고, Nextflow는 가능한 경우 나란히 실행되도록 모든 병렬화를 처리합니다.

작업을 병렬로 실행하기 위해 분할하는 방식은 매우 일반적입니다. 그리고 그 반대는 모든 것을 다시 모으는 것입니다. 따라서 워크플로우의 최종 프로세스에서 수행할 작업은 여기에 세 번째 프로세스를 만들어 세 가지 다른 출력을 가져와서 모두 단일 파일로 결합하는 것입니다.

터미널에서 이것을 매우 간단하게 수행하여 어떻게 보일지 느껴볼 수 있습니다.

results 폴더로 이동하겠습니다. "cd results/hello_workflow/"로 이동하면 여기에 모든 UPPER 파일이 있습니다. 해당 파일의 내용을 출력하는 데 사용하는 "cat"을 사용할 수 있으며, "cat"에 여러 파일을 제공할 수 있고 차례로 읽습니다.

"UPPER-\*"라고 말할 수 있으며, Bash 확장으로 동일한 세 개의 파일 이름 목록을 제공합니다. 그리고 combined.txt라고 말할 수 있습니다. 문서에는 정확한 파일 이름이 나열되어 있다고 생각하지만 같은 작업을 수행합니다.

이제 "cat combined.txt"를 사용하면 세 파일 모두의 파일 내용이 있음을 확인할 수 있습니다.

따라서 이것이 기본적으로 이 프로세스가 수행할 모든 작업입니다. 이전 프로세스의 모든 다른 출력 파일을 단일 프로세스 작업에서 제공하려고 시도한 다음, "cat"으로 함께 묶어 출력 파일을 저장할 것입니다.

## 2.2. 수집 단계를 수행할 새 프로세스 생성하기

좋습니다. 새 프로세스를 추가해 보겠습니다. 교육 자료에서 이것을 붙여넣겠습니다. 이 물음표로 독자를 위한 연습 문제를 남겨둔 것을 볼 수 있습니다. 하지만 프로세스의 일반적인 개요는 기본적으로 터미널에서 방금 수행한 것과 같습니다. 여기서 입력 파일 묶음을 "cat"하고 collected라는 출력 파일에 작성한 다음 출력은 다시 단일 경로를 예상합니다.

따라서 여기에 어떤 종류의 입력이 필요하고 경로 집합이 될 것입니다. 다시 입력 경로 채널을 정의하고 input_files라고 부르겠습니다. 이전에는 여기에 단일 경로를 제공했지만, 경로는 단일 선언이지만 여기에 여러 파일을 가질 수도 있습니다.

이 파일들을 "cat"하고 싶기 때문에 여기 아래로 복사하겠습니다. 여기서 배열을 출력하는 것과 같은 문제가 있을 수 있다고 생각할 수 있지만, Nextflow는 일반적으로 이와 관련하여 꽤 합리적입니다. 그리고 이와 같이 여러 파일이 있는 채널이 제공되면 공백 구분 기호로 모두 함께 배치합니다. 따라서 올바른 구문을 제공합니다.

훌륭합니다. 이제 새 프로세스를 연결해 보겠습니다. 워크플로우로 내려가겠습니다. 출력을 결합하겠습니다. 새 프로세스 이름이고 이전과 똑같습니다. 이 이전 프로세스인 convertToUpper를 가져와서 ".out"을 수행하겠습니다.

좋습니다. 터미널에서 시도해 보고 작동하는지 확인해 보겠습니다. 몇 개의 디렉토리를 올라가서 Nextflow 명령을 다시 실행하고 어떻게 되는지 보겠습니다.

워크플로우가 시작되었고 이제 세 가지 다른 프로세스 이름이 있음을 알 수 있습니다. 처음 두 개는 이전과 동일하게 보이고 세 번째 새로운 프로세스가 실행되어 좋습니다.

그러나 여기에 약간 이상한 것이 있습니다. 이러한 출력 파일을 단일 파일로 결합하고 싶었지만, 이 프로세스는 한 번이 아니라 세 번 실행된 것을 볼 수 있습니다.

확실히 이러한 work 디렉토리 중 하나로 들어가서 "cat work/" "collected"를 수행하면 볼 수 있습니다. 여기에는 세 개가 아니라 단일 단어만 있습니다.

그래서 일어난 일은 Nextflow가 이전 단계에서와 마찬가지로 병렬화를 계속했다는 것입니다. 그리고 이 프로세스는 세 개의 요소가 있는 채널을 제공했고, 이 세 개의 채널 요소가 다운스트림 프로세스로 전달되어 세 개의 프로세스 작업을 생성했습니다.

기본적으로 세 번 별도로 수집하려고 시도했고 매번 단일 파일만 있었으므로 단일 파일을 출력으로 cat하는 것만 수행했으며, 실제로 .command.sh 파일에서도 볼 수 있습니다.

.command.sh를 수행하면 여기에 단일 파일 이름만 있고 단일 파일만 해당 작업 디렉토리에 스테이징되었음을 볼 수 있습니다.

## 2.3. 워크플로우에 수집 단계 추가하기

따라서 어떻게든 Nextflow에게 이전 프로세스의 모든 출력을 한데 모아 세 개가 아닌 단일 채널 요소로 이 다운스트림 프로세스에 제공하도록 지시해야 합니다.

_collect_라는 채널 연산자로 이를 수행합니다.

이것은 Nextflow 파이프라인에서 항상 볼 수 있는 매우 유용한 연산자입니다. 이것은 여기의 채널이며, 이 출력 채널은 위에서 만든 것과 똑같습니다. 따라서 이전에 했던 것처럼 채널 연산자를 추가할 수 있습니다. dot을 수행한 다음 이 경우 collect, 괄호를 수행하면 됩니다.

그것이 필요한 전부입니다. 그러면 이 프로세스로 전달되기 전에 이 채널을 조작합니다.

무슨 일이 일어나고 있는지 보고 싶다면 여기에서도 볼 수 있습니다. 따라서 이것은 이 프로세스 실행과 전혀 관련이 없으므로 해당 프로세스를 실행한 후 어느 시점에나 넣을 수 있습니다. 하지만 동일한 출력 채널을 가져와서 .view로 보고 있고, 그런 다음 .collect.view로 다시 보고 있습니다.

이것을 실행하면 collect 전후의 해당 채널의 두 가지 다른 구조를 보여줄 것입니다. 이제 시도해 보겠습니다. 좋습니다. 일부 출력이 매우 길기 때문에 조금 축소했습니다만, 파이프라인을 실행하면 작동하는지 확인할 수 있습니다.

세 번째 프로세스가 한 번만 실행되기를 바랍니다. 왜냐하면 출력을 수집하고 있기 때문이고, 확실히 collectGreetings가 one of one임을 알 수 있습니다. 따라서 단일 작업만 실행되었습니다.

그런 다음 view 문을 보면 각각에 하나의 파일 경로가 있는 세 요소에 대해 세 개의 view 문이 있습니다.

그리고 해당 collect 문 이후, 해당 채널에 단일 요소가 있기 때문에 한 번만 트리거되었습니다. 이제 세 개의 다른 파일 경로 목록이 있습니다.

이것이 정확히 우리가 바랐던 것입니다. 그리고 이것이 기본적으로 CSV 배열에서 별도의 채널 요소로 이동하기 위해 수행한 "map" 연산자의 반대임을 알 수 있기를 바랍니다. 이제 별도의 채널 요소를 가져와서 단일 배열에 다시 넣습니다.

훌륭합니다. 이러한 view 문을 정리할 수 있습니다. 더 이상 필요하지 않습니다. 다음 단계로 넘어갈 수 있습니다.

더 나아가기 전에, 그리고 잊기 전에, 여기에 새로운 publish 문을 추가하겠습니다. Third output. 워크플로우에서 더 의미 있고 설명적으로 부를 수 있습니다. 그런 다음 output 블록에 다시 추가하고 path 'hello_workflow' mode 'copy'라고 말하겠습니다. 이 프로세스에서 생성된 출력 파일이 여기 위의 results 폴더에 저장되도록 하기 위해서입니다.

작동하는지 빠르게 재확인하겠습니다. 이러한 view 문이 없으므로 이제 조금 더 깔끔해야 합니다. 그리고 여기 위에 새 출력 파일을 얻을 수 있는지 확인하겠습니다. 하나의 작업이 실행되었고, collected라는 새 파일이 생겼으며, 이제 세 단어가 모두 있습니다. 환상적입니다. 다음은 무엇입니까?

## 3. 프로세스에 추가 매개변수 전달하기

좋습니다. 다음으로 단일 프로세스에 여러 입력을 처리하는 방법을 살펴보겠습니다. 지금까지 모든 프로세스가 입력으로 한 가지만 받고 있음을 알 수 있습니다. 모두 입력 아래에 단일 라인이 있습니다.

Nextflow가 다른 배치 식별자를 지정할 수 있도록 하여 이 워크플로우를 여러 번 실행할 때마다 다른 배치 ID를 제공할 수 있도록 하는 것을 보여드리겠습니다.

collectGreetings의 입력에 두 번째 라인을 추가하겠습니다. "val"이라고 하겠습니다. 왜냐하면 이것은 문자열이기 때문입니다. 이제 경로가 아니라 값이고 "batch_name"이라고 부르겠습니다.

그런 다음 이 변수를 사용하도록 여기 아래의 스크립트를 편집하고 교육 자료와 같은 위치에 넣으려고 하겠습니다. 따라서 이 파일 경로 COLLECTED-$\{batch_name\}-output 중간에 넣겠습니다.

아직 완료되지 않았습니다. Nextflow에게 출력 파일 이름이 무엇인지 알려야 한다는 것을 기억하세요. 따라서 여기 위에서도 같은 것을 해야 합니다: COLLECTED-$\{batch_name\}-output.txt".

환상적입니다. Nextflow는 이제 두 번째 변수 입력을 받고 있으며 이를 스크립트와 출력에 보간하고 있습니다.

마지막으로 한 가지, 이제 이것이 호출되는 위치를 찾아야 하며, 프로세스에 두 번째 입력을 전달해야 합니다. 이것은 다른 언어의 함수에 대한 다른 입력과 같습니다.

교육 초반에 했던 것처럼, 여기서 특별한 "params"를 사용하겠습니다. "params.batch"라고 부를 것이므로 -- batch CLI 옵션을 가질 수 있습니다. 이제 우리 프로세스가 여기에 전달되는 두 개의 별도 입력을 쉼표로 구분하여 가지고 있음을 알 수 있습니다.

순서를 올바르게 하는 것이 정말 중요합니다. 따라서 여기서 채널에 대한 인수의 순서, 그 다음 param은 일치해야 합니다. 채널과 거기의 batch name. 이것은 단지 위치 매칭입니다.

좋습니다. 이제 --batch로 파이프라인을 바로 실행할 수 있지만, 먼저 올바른 일을 하고 여기 Params의 입력에서 정의하겠습니다. 따라서 batch에 추가하고 문자열이라고 말하고 기본값을 지정하겠습니다. 그냥 batch라고 부르겠습니다. 좋습니다. 이제 워크플로우를 실행해 보겠습니다.

--batch Trio. 교육 자료에 그렇게 나와 있다고 생각하지만, 원하는 문자열을 사용할 수 있습니다. 그리고 여기 위에 결과 출력 파일이 나타나기를 바랍니다.

그리고 확실히 COLLECTED-trio-output - 제대로 작동했습니다. 파일 이름이 변경되었습니다. 이제 다른 배치 이름, 예를 들어 replicate_two로 다시 실행하면 여기 위에 다른 배치 이름을 제공할 것임을 상상할 수 있습니다.

그리고 이 경우 출력 파일을 덮어쓰지 않을 것입니다. 따라서 좋습니다.

## 4. 수집 단계에 출력 추가하기

좋습니다. 이제 프로세스에 여러 입력이 있습니다. 하지만 여러 출력을 만들고 싶다면 어떻게 될까요? 여기서 우리의 예는 이 프로세스에 대한 리포트를 생성하여 수집된 파일 수가 얼마인지 말하는 것입니다.

여기서 echo 명령으로 수행하겠습니다. 따라서 echo라고 말할 수 있습니다. 교육 자료에서 이것을 복사하겠습니다. 타이핑하는 것을 지켜보지 않아도 됩니다.

이 배치에는 $\{count_greetings\}개의 인사말이 있었습니다. 그리고 이제 $\{batch_name\}이라는 새 파일에 저장합니다. 따라서 동일한 변수로, 원하는 만큼 재사용할 수 있습니다. report.txt.

## 4.1.1. 수집된 인사말 수 계산하기

어떻게든 실제로 계산해야 합니다. 원한다면 Bash 로직을 사용하여 Bash 스크립트에서 해당 로직을 수행할 수 있습니다. 그러나 프로세스의 스크립트 블록 내에서 인용된 섹션 위에 있는 한 Nextflow 코드 내에서 직접 스크립팅을 수행할 수도 있습니다.

여기의 모든 것은 최종 렌더링된 스크립트에 포함되지 않으며, 작업을 렌더링할 때 Nextflow에 의해 실행됩니다.

따라서 여기서는 일부 로직을 수행하고 있습니다. count_greetings라는 새 변수를 만들고 있습니다. 여기서 입력 파일 채널을 가져와서 .size()를 호출합니다.

좋습니다. 해당 함수는 이 변수에 숫자를 제공할 것이며, 이제 이 변수가 정의되고 있기 때문에 경고가 사라졌습니다.

좋습니다. 작업 디렉토리에 두 번째 파일을 생성하고 있지만, 이 프로세스의 게시된 출력으로 예상하도록 Nextflow에게 알려야 합니다. 첫 번째 파일과 정확히 동일한 구문으로 수행합니다.

path라고 말합니다. 왜냐하면 다시, 원한다면 "val"로 여기서 변수를 게시할 수 있지만, "path"라고 말하겠습니다. 그런 다음 예상되는 파일 이름입니다. 여기서는 강조 표시되지 않았습니다. 작은따옴표를 사용했기 때문입니다. 큰따옴표를 사용해야 합니다.

## 4.1.2. 리포트 파일 내보내기 및 출력 이름 지정하기

좋습니다. 훌륭합니다. 그리고 이제 여기 아래에서 이러한 출력에 액세스를 시작할 수 있습니다. 여기서 했던 것처럼 말입니다. 하지만 이제 다른 객체의 배열이므로 collectGreetings.out[0]을 수행하여 첫 번째를 가져오거나, 새 리포트인 두 번째를 가져오기 위해 1을 수행할 수 있습니다.

하지만 인덱스 계산을 엉망으로 만들기가 매우 쉽기 때문에 그렇게 하는 것을 별로 좋아하지 않습니다. 그리고 줄을 많이 세는 데 앉아 있고 새 출력을 추가하면 갑자기 모든 것이 망가집니다. 따라서

대신 모든 것을 이름으로 참조하는 것이 훨씬 좋습니다. 그리고 여기서 "emit"이라는 특별한 키로 수행할 수 있습니다.

따라서 이것을 원하는 대로 부를 수 있습니다. emit outfile이라고 부르고, emit reports라고 부르겠습니다. 이것을 정의하면 하나 또는 여러 개에 대해 수행할 수 있으며, 여러분에게 달려 있습니다. 이제 여기로 내려가서 대신 dot out dot reports라고 할 수 있으며 이름으로 호출하면 코드를 읽을 때 이해하기가 훨씬 쉽고 코드 변경에 더 안전합니다.

여기에 .out.report를 추가했지만, 실제로는 두 개의 다른 출력이 게시되어야 합니다. 따라서 더 흥미로운 이름으로 collected와 report로 변경하겠습니다. 그것을 뭐라고 불렀나요? out file이라고 불렀습니다. 따라서 여기 emit 이름은 outfile과 report입니다. 두 개의 다른 출력 채널을 게시하고 있기 때문에 publish 블록에서 둘 다 참조해야 합니다.

그런 다음 output 블록에서도 정의해야 합니다. 따라서 collected로 이름을 변경했고, reports에 대해서도 마찬가지입니다. 여기서 약간 장황하지만, 새로운 워크플로우를 읽을 때 들어와서 여기에 나란히 나열된 모든 다른 출력, 모든 다른 채널을 보는 것이 정말 유용하며, 이를 덜 장황하게 만드는 방법이 있으며 나중에 다루겠습니다.

좋습니다. 시도해 보고 워크플로우를 실행하고 어떻게 되는지 보겠습니다.

이제 기본적으로 이전과 동일하게 실행되기를 바랍니다. 그리고 여기 위에 replicate_two라는 새 출력 파일이 생기기를 바랍니다. report. 그리고 있습니다. 열렸고 배치에 세 개의 인사말이 있다고 나와 있으며, 이것이 우리가 예상한 것이므로 완벽합니다.

여기 work 디렉토리로 들어가서 Nextflow 코드에서 실행되었음을 증명하기 위해, Bash 스크립트가 아니라, cat work/ command.sh로 이동할 수 있습니다. 여기서 이 문자열을 직접 echoing하고 있음을 알 수 있습니다. 이 배치에 세 개의 인사말이 있었습니다. 그래서 해당 변수가 Nextflow에 의해 보간되었습니다. .command.sh 파일을 작성하기 전에 스크립트 블록에서 계산되었습니다. 따라서 결과 변수 계산은 기본적으로 이 경우 컴퓨팅 환경에서 실행되기 전에 이것에 하드 코딩됩니다.

그리고 여기 스크립트 블록과 그 위의 모든 것 사이의 분리를 볼 수 있습니다. 이해가 되기를 바랍니다.

## 핵심 정리 및 퀴즈

좋습니다. Hello Nextflow의 이번 파트가 끝났습니다. 이전과 마찬가지로, 퀴즈를 확인하세요. 웹페이지나 CLI에서 수행하고, 몇 가지 질문을 살펴보고 다룬 자료 중 일부를 이해했는지 확인하세요. 이해하지 못한 것을 강조할 수 있는 것이 있는지 확인하세요. 너무 많은 질문은 아닙니다. 하기 쉽고 좋습니다. 또는 여기 아래 웹페이지에서도 수행할 수 있습니다.

그리고 잠시 휴식을 취하고, 조금 걷다가 돌아와서 Hello Nextflow의 파트 4에 합류하세요. 모듈에 대해 이야기하겠습니다. 감사합니다.
