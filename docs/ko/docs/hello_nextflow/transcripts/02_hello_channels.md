# 파트 2: Hello Channels - 비디오 스크립트

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보기 및 개선 제안](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/yDR66fzAMOg?si=xCItHLiOQWqoqBB9&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 사항"

    이 페이지는 스크립트만 표시합니다. 전체 단계별 지침은 [과정 자료](../02_hello_channels.md)로 돌아가세요.

    스크립트에 표시된 섹션 번호는 참고용으로만 제공되며 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영합니다

안녕하세요, Hello Nextflow 파트 2에 다시 오신 것을 환영합니다. 이번 챕터는 Hello Channels입니다.

채널은 Nextflow 파이프라인의 접착제와 같습니다. 모든 다른 프로세스들을 함께 연결하는 부분이며, Nextflow가 모든 정보를 전달하고 워크플로우를 조율하는 데 사용합니다.

채널에는 연산자라는 또 다른 부분이 있습니다. 이것들은 기본적으로 채널에 사용하여 내용을 수정할 수 있는 함수입니다. VS Code로 들어가서 현재 상황을 살펴보겠습니다.

VS Code를 많이 확대했기 때문에 깔끔하게 정리하기 위해 모든 _.nextflow\*_ 파일과 _work/_ 디렉토리, 그리고 results/와 챕터 1의 모든 것을 제거했습니다. 여기서 새롭게 시작하고 있습니다. 하지만 너무 걱정하지 마세요. 원하지 않으면 그 파일들을 그대로 둘 수 있습니다. 문제를 일으키지 않을 것입니다.

이번 챕터에서는 _hello-channels.nf_ 작업을 시작할 것이며, 이 파일을 열면 이전에 작업했던 파일과 매우 유사해 보일 것입니다. 스크립트의 다른 부분들이 다른 위치에 있을 수 있지만, 모든 것이 기본적으로 동일해야 합니다.

한 가지 다른 점은 여기 output 블록의 경로가 이제 이 파트를 위해 *hello_channels*로 되어 있다는 것입니다. 이는 결과 파일이 results의 다른 하위 디렉토리에 저장된다는 의미입니다. 따라서 출력에 대해 혼란스러워하지 않고 깔끔하게 시작할 수 있는 좋은 장소가 될 것입니다.

좋습니다. 이 워크플로우를 실행할 때 이 스크립트가 무엇을 하는지 빠르게 기억해 봅시다. *"nextflow run hello-channels.nf"*를 실행합니다. *"--input myinput"*을 할 수 있으며, 이것을 실행하면 이 매개변수 params.input을 사용할 것입니다. 이것은 여기 위의 sayHello 프로세스에 변수로 전달되어 greeting으로 들어가고 output.txt에 저장됩니다. 그리고 results 파일에서 그것을 볼 수 있습니다. 좋습니다.

## 1. 채널을 통해 명시적으로 변수 입력 제공하기

좋습니다. 하지만 이것은 꽤 단순합니다. 이 매개변수에 하나의 변수가 있고, 이것이 한 번 실행되는 프로세스로 들어가며, 실제로 확장되지 않습니다. 여기서 생성할 많은 다른 파일을 제공할 수 없습니다. 많은 다른 인사말을 제공할 수 없습니다. 하나만 있습니다.

실제로 Nextflow는 분석을 확장하는 것에 관한 것입니다. 따라서 아마도 한 가지 이상을 수행하기를 원할 것입니다. 그리고 우리는 *채널*로 그것을 합니다.

채널은 Nextflow를 처음 접하는 많은 사람들에게 다소 독특한 개념입니다. 이것은 함수형 프로그래밍의 개념에서 나온 것이며, 이해하는 데 약간의 시간이 걸릴 수 있지만, 일단 이해하면 Nextflow의 힘을 정말로 발휘하게 되며 워크플로우를 작성하는 방법의 핵심입니다.

## 1.1. 입력 채널 생성하기

이 스크립트를 가져와서 단순히 _param_ 대신 *채널*을 사용하도록 만들어 봅시다.

워크플로우로 내려가겠습니다. 이곳은 모든 것을 함께 연결하는 워크플로우 로직이 있는 곳입니다. 여기로 들어가서 새 채널을 만들겠습니다.

새 채널을 생성합니다.

그리고 "*greeting_ch"*라고 부르겠습니다. 이 변수가 채널임을 기억할 수 있도록 "*\_ch"*를 사용하는 것이 관례입니다. 하지만 원하는 대로 부를 수 있습니다.

그런 다음 등호를 하고 *"channel.of"*를 하겠습니다.

Channel은 채널과 관련된 모든 것의 네임스페이스와 같습니다. 이전에 Nextflow를 사용했다면 소문자 "c"입니다. 그리고 *".of"*는 채널 팩토리라고 불리는 것으로, 기본적으로 채널을 생성하는 방법입니다.

다양한 채널 팩토리가 있습니다. 여기서 "."만 하면 VS Code가 많은 것들을 제안하는 것을 볼 수 있지만, *".of"*가 가장 간단하며 여기에 입력을 받습니다.

따라서 괄호를 하고 *"Hello Channels!"*라고 하겠습니다.

좋습니다. 채널이 있습니다. 훌륭합니다. 저장을 누르고 다시 실행할 수 있지만, 흥미로운 일은 일어나지 않을 것입니다. VS Code가 여기 아래에 주황색 경고 줄을 표시하고 이것이 설정되었다고 알려줍니다: 이것을 생성했지만 실제로 아무것에도 사용하지 않았습니다. 이 채널이 소비되지 않고 있습니다.

좋습니다. 그럼 어떻게 사용할까요? 매우 간단합니다. 이것을 복사하고 *params.input*을 삭제한 다음 대신 여기에 *"greeting_ch"*를 넣겠습니다. 따라서 이 채널을 sayHello의 입력으로 전달할 것입니다.

지금은 이 문자열을 하드코딩했습니다. 이것은 지난 챕터 끝에서 사용했던 좋은 param 이후 약간의 후퇴이지만, 로직을 볼 수 있도록 처음에는 단순하게 유지합니다.

좋습니다. 터미널로 가서 워크플로우를 다시 실행하겠습니다. 이번에는 _"--input"_ 없이 실행할 것이며, 우리가 생성한 채널을 사용하여 실행될 것이고 희망적으로 *results/hello_channels/*에 파일이 있어야 하며 이제 "Hello Channels!"라고 표시됩니다. 훌륭합니다. 이것이 우리가 채널에서 기대하는 것입니다. 좋습니다.

## 1.4. view()를 사용하여 채널 내용 검사하기

여기에 추가할 한 가지 더, 채널에서 사용할 수 있는 "*.view"*라는 또 다른 함수에 대한 간단한 소개입니다.

이것은 Python이나 익숙할 수 있는 다른 언어의 _print_ 명령과 유사하며, 실행할 때 이 채널의 내용을 터미널에 덤프합니다.

따라서 "*.view"*를 하고, 워크플로우를 다시 실행하면 생성 시점에 해당 채널의 내용이 무엇인지 터미널에 출력해야 합니다.

확실히 여기 터미널에 출력되었습니다. _"Hello Channels!"_.

원하는 경우 이것들을 여러 줄로 나눌 수 있으며, 실제로 Nextflow 자동 포맷터가 그렇게 하려고 할 것입니다. 여기서 공백은 실제로 중요하지 않으므로 이것들을 하나씩 연결할 수 있습니다.

## 2. 여러 입력 값에서 실행되도록 워크플로우 수정하기

좋습니다. 우리 채널에는 하나가 있는데 좋지만, 기본적으로 이전과 동일합니다. 조금 더 복잡하게 만들어 봅시다. 채널에 몇 가지를 더 추가해 봅시다.

"_.of()"_ 채널 팩토리는 여러 항목을 받을 수 있으므로 몇 가지를 더 작성해 봅시다. *Hello, Bonjour, Hej*를 하겠습니다. 그런 다음 이 워크플로우를 다시 실행하고 무슨 일이 일어나는지 보겠습니다.

다시 실행되어야 합니다. 그리고 이제 출력했습니다. view 문으로 터미널에 _"Hello", "Bonjour"_ 및 *"Hej"*를 출력했습니다. 훌륭합니다.

## 2.1.2. 명령 실행 및 로그 출력 확인하기

이 시점에서 완료되었다고 생각할 수 있습니다. 하지만 실제로 여기에는 우리를 걸려 넘어뜨릴 약간의 함정이 있습니다. 여기 출력 파일을 보면 *"Hello"*가 있지만 다른 출력은 없습니다. 실제로 이것만 있습니다.

이 워크플로우를 여러 번 실행하면 때로는 *"Bonjour"*가 있고 때로는 *"Hej"*가 있는 것을 볼 수 있습니다. 약간 무작위입니다.

터미널을 보면 세 번 실행되었고 다른 view 출력을 볼 수 있습니다. 하지만 work 디렉토리로 가면 *"cat work"*를 할 수 있습니다. 이 해시를 넣고 확장한 다음 *output.txt*를 합니다. work 디렉토리의 이 파일이 results 디렉토리와 다르고 이것은 *"Hej"*입니다. 따라서 여기서 뭔가 제대로 작동하지 않습니다.

그리고 핵심은 세 개의 작업이 실행되었다는 것입니다. Nextflow 출력은 처리가 진행됨에 따라 전체 터미널을 완전히 차지하지 않도록 요약하려고 하며, 해당 ANSI 로깅은 ANSI 이스케이프 코드를 사용하여 기본적으로 다른 작업을 덮어썼습니다. 따라서 업데이트된 마지막 작업만 표시됩니다.

## 2.1.3. -ansi-log false 옵션으로 명령 다시 실행하기

이것을 실제로 더 잘 이해하기 위해 할 수 있는 몇 가지가 있습니다. work 디렉토리 자체를 살펴볼 수 있으며 거기에 모든 다른 work 디렉토리를 볼 수 있지만, 다른 Nextflow 실행 실행과 혼합되어 있기 때문에 약간 혼란스럽습니다.

또는 Nextflow에게 ANSI 이스케이프 코드를 사용하지 말라고 말할 수 있습니다.

따라서 명령을 다시 실행하되 이번에는 *"-ansi-log false"*라고 말하여 끄면, 환경 변수 _$NO_COLOR_ 또는 *"$NXF_ANSI_LOG=false"*를 사용할 수도 있습니다. 그러면 이러한 이스케이프 코드 없이 Nextflow 로깅의 더 구식 스타일을 사용합니다. 영리한 업데이트 없이 터미널에 직접 출력합니다.

이제 실행된 이 세 가지 프로세스를 모두 볼 수 있습니다. 그리고 각각 자체 작업 해시가 있습니다. 그리고 이러한 work 디렉토리로 들어가면 우리가 지정한 세 가지 다른 인사말을 볼 수 있습니다.

이제 조금 더 이해가 됩니다. Nextflow가 이것을 하고 있었다는 것을 이해하셨기를 바랍니다. 단지 해당 work 디렉토리로 터미널에 표시하는 것에 대해 약간 영리했을 뿐입니다.

그러나 이것은 work 디렉토리의 한 가지 문제를 해결했지만 출력 파일의 문제는 해결하지 못했습니다. 여전히 *"Hello"*라고 표시된 하나의 출력 파일만 있습니다.

## 2.2. 출력 파일 이름이 고유하도록 보장하기

이제 이것을 이해하려면 워크플로우 스크립트로 돌아가야 합니다. 여기서 채널을 생성하고 프로세스에 전달하고 있으며, 프로세스를 보면 greeting을 *"output.txt"*라는 파일에 쓰고 해당 출력 파일을 여기 아래 output 블록으로 다시 전달하여 게시하고 있습니다.

그러나 이 프로세스가 이 세 가지 다른 작업을 세 번 실행할 때마다 모두 *"output.txt"*라는 파일을 생성하고, 이러한 모든 출력 파일이 results 디렉토리에 게시되며 서로를 덮어씁니다. 따라서 거기서 얻는 결과 파일은 생성된 마지막 파일일 뿐이지만 다른 모든 파일을 덮어썼습니다. 그것은 우리가 원하는 것이 아닙니다.

## 2.2.1. 동적 출력 파일 이름 구성하기

이것을 처리하는 다양한 방법이 있지만, 지금은 가장 간단한 방법은 다른 고유한 파일 이름을 만드는 것입니다. 따라서 작업이 다른 greeting으로 실행될 때마다 다른 출력 파일을 생성하며, 게시될 때 더 이상 충돌하지 않습니다. 그러면 세 개의 고유한 출력 파일을 얻게 됩니다.

정확히 같은 방식으로 합니다. script 블록 내 어디에서나 이 변수를 사용할 수 있으며 여러 번 사용할 수 있습니다.

따라서 여기에 붙여넣을 수 있습니다. _"$\{greeting\}\_output.txt"_, 그런 다음 더 이상 *output.txt*라는 파일을 생성하지 않기 때문에 여기 위에도 붙여넣어야 합니다. 따라서 이것을 업데이트하지 않으면 Nextflow는 생성되지 않은 파일을 예상했다는 오류와 함께 충돌합니다.

따라서 거기에도 동일하게 해야 하며 이 변수가 이해되도록 작은따옴표가 아닌 큰따옴표를 사용해야 합니다.

좋습니다. 시도해 보고 작동했는지 봅시다. 워크플로우를 다시 실행할 것입니다. 세 가지 다른 work 디렉토리 내에서 세 가지 다른 작업을 표시할 것입니다. 확실히 여기 왼쪽 results 폴더에서 볼 수 있습니다. 이제 세 가지 다른 파일 이름을 가진 세 개의 다른 파일이 있으며 각각 우리가 예상하는 다른 내용이 있습니다. 따라서 파일이 더 이상 서로를 덮어쓰지 않으며 모든 것이 예상대로 있습니다.

여기서 진행한 것은 약간 사소한 설정이지만, 파일 게시가 어떻게 작동하는지에 대한 핵심 개념과 함정에 빠질 수 있는 몇 가지 사항을 강조합니다. 따라서 자신의 워크플로우에서 이를 피할 수 있기를 바랍니다.

또한 여기서 한 것은 실제 상황에서 약간 비실용적이라는 점을 주목할 가치가 있습니다. 일부 입력 데이터를 가져와서 해당 데이터를 사용하고 있지만 해당 데이터의 이름을 따서 파일 이름을 지정하고 있는데, 일반적으로 할 수 없습니다.

따라서 실제로 더 성숙한 Nextflow 파이프라인에서는 주어진 샘플과 관련된 모든 메타데이터가 있는 meta 객체를 전달하는 경우가 많습니다. 그런 다음 이를 기반으로 동적 파일 이름을 만들 수 있으며 훨씬 더 실용적입니다.

모범 사례로 이를 수행하는 방법에 관심이 있다면 *training.nextflow.io*에 메타데이터와 meta map에 대한 사이드 퀘스트가 있으므로 자세한 내용을 확인할 수 있습니다.

## 3. 배열을 통해 여러 입력 제공하기

좋습니다. 다음으로 채널이 어떻게 구조화되어 있고 코딩 언어의 다른 종류의 데이터 구조와 어떻게 다른지에 대해 조금 탐구할 것입니다. 그리고 다른 언어에서 왔다면 익숙한 개념일 수 있는 배열을 잠재적으로 어떻게 사용할 수 있는지 생각해 보겠습니다.

채널에서 배열을 사용할 수 있을까요? 시도해 봅시다. 배열을 만들겠습니다. 문서에서 복사했습니다. _"greetings_array"_ 및 _"Hello", "Bonjour"_ 및 _"Holà"_. 그런 다음 하드코딩된 문자열 대신 여기에 넣겠습니다. 따라서 "channel.of" *"greetings_array"*라고 말하고 이 배열을 채널에 전달합니다. 시도해 봅시다.

터미널을 불러와서 파이프라인을 실행합니다.

좋습니다. view 문이 예상대로 배열을 출력했지만 이 모든 빨간색 텍스트, 또는 여전히 *"-ansi-log"*를 끄면 빨간색이 아니지만 이 모든 빨간색 텍스트는 뭔가 잘못되었다고 알려줍니다.

더 이상 여기에 좋은 녹색 체크 표시가 없습니다. 빨간색 십자가가 있으며, 읽기 쉽도록 조금 더 넓게 만들면 Nextflow가 무엇이 잘못되었는지 알려줍니다.

섹션별로 분석해 봅시다. 오류의 원인은 출력 파일 누락이라고 합니다. 따라서 기본적으로 해당 output 블록은 이 파일이 생성되어야 한다고 말했지만 생성되지 않았습니다. 다음으로 실행된 명령이라고 합니다. 따라서 이것은 기본적으로 해당 _.command.sh_ 파일의 내용입니다. 모든 변수가 입력된 후의 모습입니다.

그리고 여기서 echo 명령이 실제로 한 번만 실행되었고 전체 배열을 사용했지만 문자열 표현으로 사용했음을 볼 수 있습니다. 이것은 우리가 원하는 것이 아닙니다.

그런 다음 명령이 그렇게 종료되었고 파일을 보고 더 이해할 수 있는 work 디렉토리였습니다.

좋습니다. 그럼 무슨 일이 일어났냐면 Nextflow가 이 전체 배열을 단일 채널 요소로 프로세스에 전달했고, 이는 프로세스가 한 번만 실행되었음을 의미합니다. 하나의 작업이 있었고 우리가 예상한 구조로 데이터를 사용하지 않았습니다.

## 3.2. 연산자를 사용하여 채널 내용 변환하기

따라서 사용하기 전에 이 채널에 먼저 무언가를 해야 합니다. 그리고 이것은 채널 내용을 조작하기 위해 채널에서 사용할 수 있는 특수 함수인 연산자를 사용하기 위한 단계를 설정합니다.

이 경우 *flatten*이라는 것을 사용할 것입니다. 여기 채널 끝에 전달합니다. 따라서 채널을 생성한 다음 *flatten*을 실행합니다. 그리고 다시 마우스를 올리면 VS Code에서 이 명령에 대한 문서를 바로 표시하며 매우 유용합니다. Nextflow 웹사이트, 문서에서도 이러한 모든 문서를 찾을 수 있습니다.

지금 이 코드를 실행하고 작동하는지 볼 수 있지만, Nextflow 코드 내에서 연산자 내에서 클로저라고 하는 동적 코드를 수행하는 방법을 소개하는 좋은 기회이기도 합니다.

따라서 *flatten*을 실행하기 전에 여기에 view 명령을 다시 추가하겠습니다. 그리고 여기에는 이 중괄호가 있는데, 이것은 동적 클로저입니다. 그리고 view 연산자의 컨텍스트 내에서 실행될 임의의 코드가 있습니다.

여기서 이것은 greeting을 가져온다고 말하는데, 이것은 view 연산자의 입력이며 여기에 있습니다. 원하는 대로 부를 수 있으며 *"foo"*라고 부를 수 있고 나중에 *"foo"*로 참조하기만 하면 됩니다. 그런 다음 이것으로 이것을 반환한다고 말합니다.

그런 다음 변수에 대해 flatten 전이라고 말하는 문자열을 반환하도록 설정합니다. 매우 간단합니다.

이제 정확히 동일한 것을 하나 더 추가하겠지만 _flatten_ 후라고 말하겠습니다.

따라서 이것이 하는 일은 이것이 순서대로 실행되기 때문에 *flatten*을 실행하기 전에 채널이 어떻게 보이는지, 그리고 *flatten*을 실행한 후 다시 어떻게 보이는지 볼 수 있습니다.

그런 다음 이 greeting 채널이 여전히 생성되므로 여전히 프로세스에 전달될 것입니다. 그리고 이제 워크플로우가 실행될 것입니다. 시도해 봅시다.

좋습니다. 우선 이번에는 파이프라인이 충돌하지 않았습니다. 제대로 실행된 세 개의 프로세스가 있었고 작은 체크 표시가 있습니다. 그런 다음 view 문이 작동했음을 볼 수 있습니다.

_flatten_ 전이 있는데, 이것은 실패에서 본 배열이고, 그런 다음 _flatten_ 후가 세 번 호출되었으며 _"Hello", "Bonjour"_ 및 배열의 다른 세 개의 개별 요소가 있으며, 이제 우리가 희망한 대로 채널의 세 개의 개별 요소입니다.

그리고 _view_ 연산자가 세 번 실행되었음을 볼 수 있습니다. 그리고 그것은 _flatten_ 후 이 채널에 이제 세 개의 요소가 있기 때문입니다. 따라서 연산자가 세 번 호출됩니다.

매우 빠르게, 이전에 채널 팩토리를 생성할 때 *"."*를 했고 채널을 생성하는 많은 다른 방법이 있었으며 그 중 하나는 "*fromList"*라고 불린다는 것을 언급하고 싶습니다. 그리고 그것은 실제로 이 동일한 작업을 수행하도록 특별히 설계되었습니다. 따라서 from list greetings away를 했을 수 있으며 작동할 것입니다. 약간 깔끔하고 좋은 구문입니다. 하지만 이 시연의 목적을 위해 채널이 어떻게 조작되고 있는지, 다른 연산자가 채널 내용을 어떻게 변경할 수 있는지 볼 수 있도록 단계별로 만들고 싶었습니다.

## 4. CSV 파일에서 입력 값 읽기

좋습니다. 이것을 어떻게 좀 더 현실적으로 만들 수 있을까요? 아마도 하드코딩된 배열로 Nextflow 파이프라인에 많은 코드를 생성하고 싶지 않을 것입니다. 아마도 시작할 때 외부에서 데이터를 가져오고 싶을 것이며, 해당 데이터는 거의 확실히 파일에 있을 것입니다.

따라서 다음으로 할 일은 이것을 복제하는 것이지만 단일 CLI 매개변수나 하드코딩된 문자열 또는 배열에서 데이터를 가져오는 대신 파일에서 가져올 것입니다.

따라서 greetings away를 제거하겠습니다. 이제 이 채널 팩토리를 다시 변경할 것입니다. 선택할 수 있는 많은 것이 있다고 방금 말했으며 *".fromPath"*라는 것이 있습니다. 그리고 이 경우 *params.input*을 가져오도록 지시하겠습니다. 이것은 이전에 사용했던 입력으로 돌아갑니다.

이제 해당 매개변수는 아직 사용할 준비가 되지 않았습니다. 여전히 문자열이라고 말하고 있으며 기본값으로 여기에 하드코딩되어 있지만 해당 문자열을 덮어쓸 수 있습니다. 이제 이것이 파일이 되기를 원합니다. 따라서 유형이 다릅니다. 더 이상 *String*이 아닙니다. *Path*입니다.

그런 다음 원하는 경우 기본값을 다시 Path로 설정할 수 있습니다. 왼쪽 탐색기를 보면 이 저장소, 이 작업 디렉토리에 data라는 디렉토리가 있습니다. 거기에 *"greetings.csv"*라는 파일이 있습니다.

따라서 여기에 기본값을 *"data/greetings.csv"*로 설정할 수 있습니다. 이제 명령줄 옵션 없이 이 파이프라인을 다시 실행하면 이 기본값을 사용할 것입니다. 경로임을 알고 있으므로 문자열이 아닌 경로로 처리해야 한다는 것을 알고 있습니다.

그런 다음 이 params.input에서 채널 팩토리로 전달하고 채널을 생성할 것이며, 이것은 *sayHello*라는 이 프로세스에서 사용될 것입니다. 시도해 봅시다.

좋습니다. 실패했습니다. 걱정하지 마세요. 이것은 예상된 것입니다. 그리고 교육 자료를 따르고 있다면 거기서도 예상되었음을 알 수 있습니다. 무슨 일이 일어나고 있는지 봅시다.

파이프라인을 실행하려고 했습니다. 프로세스를 실행하려고 했고 이전에 본 것과 매우 유사한 오류가 발생했습니다.

여기서 *echo*를 실행하려고 했지만 이 CSV 파일의 내용을 에코하는 대신 경로만 에코했다고 합니다. 그리고 여기에 이 CSV 파일의 전체 절대 경로임을 볼 수 있습니다.

그런 다음 확실히 이 정말 복잡한 경로에 쓰려고 했기 때문에 무엇을 해야 할지 정말 몰랐습니다. 그리고 프로세스 work 디렉토리의 범위를 벗어났습니다.

처음에 Nextflow가 특수 work 디렉토리 내에서 실행된 모든 작업을 캡슐화한다고 언급했습니다. 그리고 해당 work 디렉토리 외부에 있는 데이터에 쓰려고 하면 Nextflow가 안전 예방 조치로 중지합니다. 그리고 그것이 여기서 일어난 일입니다. 절대 경로에 쓰려고 했고 Nextflow가 실패하고 우리를 막았습니다.

## 4.2. splitCsv() 연산자를 사용하여 파일 분석하기

좋습니다. 이 채널을 살펴보고 어떻게 보이는지 봅시다. "*.view"*를 할 수 있으며 웹사이트에서 복사했습니다. 따라서 _.view_, 그리고 여기에 동적 클로저가 있으며 입력으로 변수 이름 "*csv"*라고 말합니다. 따라서 그것은 채널 내용이며 splitCsv 전이라고 말하고 이것이 어떻게 보이는지입니다.

다시 실행하면 여전히 실패하지만 이 채널 내부에 무엇이 있는지 보여줄 것입니다. 특별히 흥미롭지 않습니다. 그것은 _path_ 변수입니다. 따라서 터미널에 출력되기 때문에 여기서는 문자열일 뿐이지만 이 파일에 대한 정보와 메타데이터를 포함하는 _path_ 객체입니다.

파일의 메타데이터를 입력에 전달하고 싶지 않습니다. 해당 파일의 내용을 전달하고 싶습니다. _greetings.csv_ 파일을 보면 여기에 이러한 다른 변수가 있음을 볼 수 있습니다. _Hello, Bonjour, Holà_ 다시. 그리고 이것들이 실제로 단일 객체로서의 파일 자체가 아니라 프로세스에 전달하고 싶은 것입니다.

따라서 이 CSV 파일을 분석해야 합니다. 압축을 풀고 CSV 파일의 내용을 가져온 다음 채널 내의 내용을 프로세스에 전달해야 합니다.

로그 메시지에서 알 수 있듯이 또 다른 연산자, 또 다른 채널 연산자인 *splitCsv*를 사용하고 싶습니다. 따라서 "*dot" "s"*를 하면 자동 제안되는 것을 볼 수 있습니다. 이런, _splitCsv_ 및 일부 괄호.

그런 다음 _splitCsv_ 후에 다른 _view_ 문을 넣어서 나중에 어떻게 보이는지 볼 수 있도록 하겠습니다. 파이프라인을 실행하고 무엇을 얻었는지 봅시다.

좋습니다. 여전히 실패했지만 새롭고 흥미로운 방식으로 실패했으며 이것은 진전입니다.

이번에도 렌더링된 스크립트에 문제가 있습니다. 이제 최종 경로는 없지만 변수 배열이 있으며, 이것은 고정 입력으로 배열을 전달할 때 이전에 발생한 오류와 매우 유사합니다.

view 연산자의 로깅으로 _splitCsv_ 전이 경로였음을 볼 수 있습니다. 그리고 확실히 _splitCsv_ 후에는 세 개의 다른 출력이 있으며 각 출력은 _greetings.csv_ 파일의 각 행과 매우 유사하며 이치에 맞습니다.

따라서 여기서 일어난 일은 Nextflow가 이 CSV 파일을 분석하여 세 개의 객체를 제공했으며 CSV 파일의 각 줄에 대해 하나의 배열을 제공했다는 것입니다. 따라서 세 번 단일 문자열 값 대신 변수 배열을 채널에 전달했습니다.

좋습니다. 지난번에 이 문제가 있었을 때 *flatten*을 사용했습니다. 매우 빠르게 시도해 봅시다. flatten을 시도하고 무슨 일이 일어나는지 봅시다.

이 변수들을 무엇이든 부를 수 있습니다. 따라서 더 이상 실제로 CSV가 아니기 때문에 *myarray*라고 부르겠습니다. *flatten*으로 다시 실행해 보겠습니다.

이번에는 실행할 것이며 CSV를 세 개의 배열 객체로 분석한 다음 평탄화했습니다. 그리고 이번에는 통과했습니다. 그리고 Nextflow 파이프라인이 실행되었습니다. 그러나 *flatten*이 정말로 열심히 작업하고 모든 것을 평탄화한다는 것을 볼 수 있습니다. 따라서 각 행에 대해 세 개의 독립적인 배열 항목을 얻습니다. 따라서 CSV의 모든 행에 대해 프로세스를 세 번 실행했습니다. 이제 우리가 정말로 원했던 CSV의 첫 번째 열뿐만 아니라 123, 456 및 모든 종류의 것들이 있는 많은 결과 파일이 있습니다.

## 4.3. map() 연산자를 사용하여 인사말 추출하기

그럼 첫 번째 열만 어떻게 얻을까요? flatten이 여기서 너무 단순하다면 실제로 사용자 정의하고 CSV에서 원하는 것을 알려줄 수 있는 더 복잡한 연산자가 필요합니다.

그렇게 하기 위해 *map*을 사용할 것입니다. 기본적으로 *map*은 제공받은 모든 요소에 대해 일부 코드, 일부 함수를 실행하고 일종의 변환을 수행한다고 말합니다. 그리고 매우 유연하기 때문에 Nextflow 코드에서 항상 나타나는 것을 볼 수 있습니다.

그 자체로는 아무것도 하지 않습니다. 따라서 일반 괄호를 원하지 않고 여기에 클로저를 원하며 무엇을 할지 알려줘야 합니다. 따라서 CSV에서 행을 제공받기 때문에 논리적인 변수 이름인 *"row"*라고 말하겠습니다. 입력입니다. 그리고 해당 배열의 첫 번째 요소만 반환하고 싶습니다.

Nextflow의 배열은 0 기반이므로 행 0인 첫 번째 요소만 말할 것입니다. 두 번째 열을 원한다면 1이 될 수 있고 세 번째 열은 2가 될 수 있습니다. 여기서 원하는 것을 반환할 수 있지만 첫 번째 값만 반환하겠습니다.

이제 파이프라인을 다시 실행하고 예상대로 작동하는지 확인할 수 있습니다.

확실히 _splitCsv_ 후에 배열이 있고 _map_ 후에는 _"Hello", "Bonjour"_ 및 *"Holà"*만 있는 깔끔한 문자열이 있습니다. 그리고 파이프라인은 이제 우리가 원하는 것을 하고 있습니다. 훌륭합니다.

따라서 이제 이러한 모든 view 명령을 제거할 수 있습니다. 더 이상 필요하지 않습니다.

## 요약

디버깅을 마쳤으며 이것이 우리가 결국 얻게 되는 코드입니다. *input*이라는 CLI 매개변수를 가져와서 *Path*로 분류합니다. Nextflow가 경로를 찾아 로드하고 CSV 파일을 이해합니다. 모든 다른 행을 반환합니다. 그런 다음 해당 행의 첫 번째 요소만 채널에 매핑하여 채널 내용을 제공하며, 이것은 프로세스에 전달됩니다.

그리고 프로세스는 채널의 각 요소에 대해 실행되며, 이것은 세 개입니다. 그리고 프로세스를 세 번 실행하여 세 개의 작업을 제공합니다. 그런 다음 해당 결과는 워크플로우에서 게시되고 프로세스 output에서 선택되어 워크플로우에서 게시되고 output 블록에서 *"hello_channels"*라는 하위 디렉토리에 저장됩니다.

꽤 멋집니다. 이제 실제 분석을 위해 실행할 수 있는 실제 Nextflow 파이프라인과 더 유사한 것에 도달하고 있습니다.

## 핵심 정리

좋습니다. 이제 Nextflow 채널과 연산자가 무엇인지, 연산자가 채널에서 어떻게 작동하는지, 어떻게 생성할 수 있는지에 대한 느낌을 얻으셨기를 바랍니다.

비디오 시작 부분에서 말했듯이 채널은 Nextflow의 접착제입니다. 그리고 여기서 다른 입력을 가져와서 조작하고 해당 데이터를 가져온 다음 다운스트림 워크플로우 로직에 전달할 수 있음을 볼 수 있습니다.

그리고 여기 이 workflow 블록은 실제로 모든 병렬화와 모든 영리한 로직을 구축하고 워크플로우 DAG를 구축하는 방법과 파이프라인을 조율하는 방법을 Nextflow에 설명하는 곳입니다.

채널은 이해하기 가장 쉬운 개념이 아닙니다. 따라서 휴식을 취하고 이것에 대해 조금 생각하고 자료를 다시 읽어보고 이러한 개념을 정말로 이해했는지 확인하세요. 이것이 Nextflow 이해의 핵심이며 채널과 다른 채널 연산자 및 다른 채널 팩토리를 더 잘 이해할수록 Nextflow를 작성하는 데 더 많은 재미를 느낄 것이고 파이프라인이 더 강력해질 것입니다.

이것은 Python이나 다른 언어의 일반 프로그래밍과 같지 않습니다. 여기서 _if_ 문을 사용하지 않습니다. 이것은 채널과 연산자를 사용하는 함수형 플로우 프로그래밍입니다. 따라서 약간 다르지만 매우 강력하기도 합니다.

이것이 이 챕터의 끝입니다. 잠깐 휴식을 취하시고 파트 3의 다음 비디오에서 뵙겠습니다. 여기서 Hello Workflow를 진행하고 워크플로우에 대해 좀 더 이야기하겠습니다.

이전 챕터와 마찬가지로 여기 웹페이지 하단에 몇 가지 퀴즈 질문이 있으므로 빠르게 실행하고 방금 수행한 자료의 모든 다른 부분을 이해했는지 확인할 수 있습니다. 그리고 그 외에는 다음 비디오에서 뵙겠습니다. 대단히 감사합니다.

좋습니다.
