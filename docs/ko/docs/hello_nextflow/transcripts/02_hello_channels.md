# 파트 2: Hello Channels - 영상 대본

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보기 및 개선 사항 제안](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/yDR66fzAMOg?si=xCItHLiOQWqoqBB9&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 사항"

    이 페이지는 대본만 보여줍니다. 전체 단계별 지침을 보려면 [과정 자료](../02_hello_channels.md)로 돌아가세요.

    대본에 표시된 섹션 번호는 참고용으로만 제공되며 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영합니다

안녕하세요, Hello Nextflow의 파트 2에 다시 오신 것을 환영합니다. 이번 챕터는 Hello Channels입니다.

채널은 Nextflow 파이프라인의 접착제와 같습니다. 모든 다른 프로세스들을 하나로 묶어주는 부분이며, Nextflow가 모든 정보를 전달하고 워크플로우를 조율하는 데 사용합니다.

채널에는 연산자라는 또 다른 부분이 있습니다. 이것들은 기본적으로 채널에서 사용할 수 있는 함수로, 내용을 수정할 수 있게 해줍니다. VS Code로 들어가서 우리가 어디에 있는지 살펴보겠습니다.

VS Code를 상당히 확대해 두었기 때문에, 깔끔하게 정리하기 위해 챕터 1의 모든 _.nextflow\*_ 파일과 _work/_ 디렉토리, _results/_ 및 모든 것을 제거했습니다. 여기서 깨끗하게 새로 시작하고 있습니다. 하지만 너무 걱정하지 마세요. 원하지 않으면 그 파일들을 그대로 둘 수 있습니다. 문제를 일으키지 않습니다.

이번 챕터에서는 _hello-channels.nf_ 작업을 시작할 것이며, 이 파일을 열면 이전에 작업했던 파일과 매우 유사하게 보일 것입니다. 스크립트의 다른 부분들이 다른 위치에 있을 수 있지만, 모든 것이 기본적으로 동일해야 합니다.

한 가지 다른 점은 output 블록의 경로가 이제 이 파트를 위한 _hello_channels_로 되어 있다는 것입니다. 이는 결과 파일들이 results의 다른 하위 디렉토리에 저장된다는 것을 의미합니다. 그래서 출력에 대해 혼란스러워하지 않고 깔끔하고 좋은 시작점이 될 것입니다.

좋습니다, 이 워크플로우를 실행할 때 이 스크립트가 무엇을 하는지 빠르게 기억해 봅시다. _"nextflow run hello-channels.nf"_를 실행합니다. _"--input myinput"_을 할 수 있고, 이것을 실행하면 이 매개변수, params.input을 사용할 것입니다. 이것은 여기 위쪽의 sayHello 프로세스에 변수로 전달되어 greeting으로 들어가고 output.txt에 저장됩니다. 그리고 results 파일에서 그것을 볼 수 있습니다. 좋습니다.

## 1. 채널을 통해 명시적으로 변수 입력 제공하기

좋습니다. 하지만 이것은 꽤 단순합니다. 이 매개변수에 하나의 변수가 있고, 이것이 한 번 실행되는 프로세스로 들어가며, 실제로 확장성이 없습니다. 여기서 생성할 많은 다른 파일들을 줄 수 없습니다. 많은 다른 인사말을 줄 수 없습니다. 단 하나만 있습니다.

실제로 Nextflow는 분석을 확장하는 것이 핵심입니다. 따라서 한 가지 이상의 작업을 수행하기를 원할 것입니다. 그리고 _채널_을 통해 그렇게 합니다.

채널은 Nextflow를 처음 접하는 많은 사람들에게 다소 독특한 개념입니다. 이것은 함수형 프로그래밍의 개념에서 유래했으며, 이해하는 데 약간의 시간이 걸릴 수 있습니다. 하지만 일단 이해하면 Nextflow의 힘을 정말로 열어주며 워크플로우를 작성하는 방법의 핵심입니다.

## 1.1. 입력 채널 생성하기

이 스크립트를 가져와서 _param_ 대신 _채널_을 사용하도록 만들어 봅시다.

워크플로우로 내려가서, 여기가 모든 것을 함께 엮는 워크플로우 로직이 있는 곳입니다. 그리고 여기에 들어가서 새 채널을 만들겠습니다.

새 채널을 생성합니다.

그리고 "_greeting_ch"_라고 부르겠습니다. 이 변수가 채널이라는 것을 기억할 수 있도록 "_\_ch"_를 붙이는 것이 관례입니다. 하지만 원하는 대로 부를 수 있습니다.

그리고 등호를 쓰고, _"Channel.of"_를 할 것입니다.

Channel은 채널과 관련된 모든 것의 네임스페이스와 같습니다. 이전에 Nextflow를 사용했다면 소문자 "c"입니다. 그리고 _".of"_는 채널 팩토리라고 불리는 것으로, 기본적으로 채널을 생성하는 방법입니다.

다양한 채널 팩토리가 있습니다. 여기서 단순히 "."를 하면 VS Code가 많은 것들을 제안하는 것을 볼 수 있지만, _".of"_가 가장 간단하고 입력을 받습니다.

따라서 괄호를 만들고 _"Hello Channels!"_라고 하겠습니다.

좋습니다. 채널이 있습니다. 환상적입니다. 저장을 누르고 다시 실행할 수 있지만, 흥미로운 일은 일어나지 않을 것입니다. VS Code가 여기 아래에 주황색 경고 줄을 주고 이것이 설정되었다고 알려줍니다: 이것을 생성했지만 실제로 아무 것에도 사용하지 않았습니다. 이 채널은 소비되지 않고 있습니다.

좋습니다, 그럼 어떻게 사용할까요? 매우 간단합니다. 이것을 복사하고 _params.input_을 삭제하고 대신 여기에 _"greeting_ch"_를 넣겠습니다. 따라서 이 채널을 sayHello의 입력으로 전달할 것입니다.

지금은 이 문자열을 하드코딩했다는 점에 유의하세요. 이것은 지난 챕터 끝에서 사용했던 멋진 param 이후에 약간 후퇴한 것이지만, 로직을 볼 수 있도록 일단 단순하게 유지하는 것입니다.

좋습니다, 터미널로 가서 워크플로우를 다시 실행하겠습니다. 이번에는 _"--input"_ 없이, 실행될 것이고 우리가 생성한 채널을 사용할 것이며, 이제 _results/hello_channels/_에 파일이 있어야 하고 이제 _"Hello Channels!"_라고 되어 있습니다. 환상적입니다. 그래서 이것이 우리 채널에서 기대했던 것입니다. 좋습니다.

## 1.4. view()를 사용하여 채널 내용 검사하기

여기에 한 가지 더 추가할 것이 있습니다. 채널에서 사용할 수 있는 "_.view"_라는 또 다른 함수에 대한 간단한 소개입니다.

이것은 Python이나 익숙할 수 있는 다른 언어의 _print_ 명령과 유사하며, 실행할 때 이 채널의 내용을 터미널에 덤프합니다.

따라서 "_.view"_를 하고, 워크플로우를 다시 실행하면 생성 시점에 해당 채널의 내용이 무엇인지 터미널에 출력해야 합니다.

과연 터미널에 출력된 것을 볼 수 있습니다. _"Hello Channels!"_.

원하는 경우 이러한 것들을 여러 줄에 걸쳐 나눌 수 있으며, 실제로 Nextflow 자동 포매터가 그렇게 하려고 할 것입니다. 공백은 여기서 그다지 중요하지 않으므로 이러한 것들을 하나씩 연결할 수 있습니다.

## 2. 여러 입력 값에서 실행되도록 워크플로우 수정하기

좋습니다, 우리 채널에 하나의 것이 있는데 이것은 좋지만, 기본적으로 이전과 같습니다. 그래서 좀 더 복잡하게 만들어 봅시다. 채널에 몇 가지를 더 추가해 봅시다.

"_.of()"_ 채널 팩토리는 여러 항목을 받을 수 있으므로, 몇 가지를 더 작성해 봅시다. _Hello, Bonjour, Hej_를 할 것입니다. 그런 다음 이 워크플로우를 다시 실행하고 무슨 일이 일어나는지 보겠습니다.

다시 실행되어야 합니다. 그리고 이제 출력했습니다. view 문으로 _"Hello", "Bonjour"_ 및 _"Hej"_를 터미널에 출력했습니다. 환상적입니다.

## 2.1.2. 명령 실행 및 로그 출력 확인하기

이 시점에서 완료되었다고 생각할 수 있습니다. 하지만 실제로 우리를 걸려 넘어뜨릴 약간의 함정이 있습니다. 여기 출력 파일을 보면, _"Hello"_가 들어 있지만 다른 출력은 없습니다. 실제로 이것 하나뿐입니다.

이 워크플로우를 여러 번 실행하면 때로는 _"Bonjour"_가 있고, 때로는 _"Hej"_가 있는 것을 볼 수 있습니다. 약간 무작위입니다.

터미널을 보면 세 번 실행되었고 다른 view 출력을 볼 수 있습니다. 하지만 work 디렉토리로 가서 _"cat work"_를 할 수 있습니다. 이 해시를 넣고 확장하고 _output.txt_. 이 work 디렉토리의 파일이 results 디렉토리와 다르다는 것을 볼 수 있고, 이것은 _"Hej"_입니다. 그래서 여기서 뭔가 제대로 작동하지 않고 있습니다.

그리고 핵심은 세 개의 작업이 실행되었다는 것입니다. Nextflow 출력은 처리가 진행됨에 따라 요약하려고 하므로 터미널 전체를 완전히 차지하지 않으며, 해당 ANSI 로깅은 기본적으로 다른 작업들을 덮어쓴 ANSI 이스케이프 코드를 사용합니다. 따라서 업데이트된 마지막 것만 보여줍니다.

## 2.1.3. -ansi-log false 옵션으로 명령 다시 실행하기

실제로 이것을 더 잘 이해하기 위해 할 수 있는 몇 가지가 있습니다. work 디렉토리 자체를 살펴볼 수 있고 거기에 모든 다른 work 디렉토리를 볼 수 있지만, 다른 Nextflow 실행 실행과 섞여 있기 때문에 약간 혼란스럽습니다.

또는 Nextflow에게 ANSI 이스케이프 코드를 사용하지 말라고 할 수 있습니다.

따라서 명령을 다시 실행하지만, 이번에는 _"-ansi-log false"_를 해서 끕니다. 환경 변수 _$NO_COLOR_ 또는 _"$NXF_ANSI_LOG=false"_를 사용할 수도 있습니다. 그러면 이러한 이스케이프 코드 없이 Nextflow 로깅의 좀 더 구식 스타일을 사용합니다. 영리한 업데이트 없이 터미널에 직접 출력합니다.

그리고 이제 실행된 이 세 가지 프로세스를 모두 볼 수 있습니다. 그리고 각각 자체 작업 해시가 있습니다. 그리고 이러한 work 디렉토리로 가면 지정한 세 가지 다른 인사말을 볼 수 있습니다.

이제 좀 더 이해가 됩니다. Nextflow가 이것을 하고 있었다는 것을 이해하셨기를 바랍니다. 단지 터미널에서 해당 work 디렉토리로 보여준 것에 약간 영리했을 뿐입니다.

그러나 이것은 work 디렉토리에 대한 한 가지 문제를 해결했지만, 출력 파일에 대한 문제는 해결하지 못했습니다. 여전히 _"Hello"_라고 되어 있는 하나의 출력 파일만 있습니다.

## 2.2. 출력 파일 이름이 고유하도록 보장하기

이제 이것을 이해하려면 워크플로우 스크립트로 돌아가야 합니다. 여기서 채널을 생성하고 프로세스에 전달하며, 프로세스를 보면 greeting을 _"output.txt"_라는 파일에 쓰고 해당 출력 파일을 여기 아래 output 블록으로 다시 전달하여 게시합니다.

그러나 이 프로세스가 이 세 가지 다른 작업을 세 번 실행할 때마다, 모두 _"output.txt"_라는 파일을 생성하고, 모든 출력 파일이 results 디렉토리에 게시되며, 모두 서로를 덮어씁니다. 따라서 거기에 있는 결과 파일이 무엇이든 마지막으로 생성된 것일 뿐이지만, 다른 모든 것을 덮어버렸습니다. 그것은 우리가 원하는 것이 아닙니다.

## 2.2.1. 동적 출력 파일 이름 구성하기

이를 처리하는 다양한 방법이 있지만, 지금으로서는 가장 간단한 것은 다른 고유한 파일 이름을 만드는 것입니다. 따라서 작업이 다른 greeting으로 실행될 때마다 다른 출력 파일을 생성하여 게시될 때 더 이상 충돌하지 않습니다. 그러면 세 개의 고유한 출력 파일을 얻게 됩니다.

정확히 같은 방식으로 합니다. script 블록 내 어디서나 이 변수를 사용할 수 있으며 여러 번 사용할 수 있습니다.

따라서 여기에 붙여넣을 수 있습니다. _"$\{greeting\}\_output.txt"_, 그리고 여기 위에도 붙여넣어야 합니다. 왜냐하면 더 이상 output.txt라는 파일을 생성하지 않기 때문입니다. 따라서 이것을 업데이트하지 않으면 Nextflow가 생성되지 않은 파일이 예상된다는 오류와 함께 충돌할 것입니다.

따라서 거기에도 같은 것을 해야 하고 이 변수가 이해될 수 있도록 작은따옴표가 아닌 큰따옴표를 사용해야 합니다.

좋습니다, 시도해보고 작동했는지 봅시다. 워크플로우를 다시 실행할 것입니다. 세 개의 다른 work 디렉토리 내에서 세 개의 다른 작업을 보여줄 것입니다. 그리고 과연 왼쪽 위 results 폴더에서 볼 수 있습니다. 이제 세 개의 다른 파일 이름을 가진 세 개의 다른 파일이 있고 각각 우리가 기대하는 다른 내용을 가지고 있습니다. 따라서 파일들이 더 이상 서로를 덮어쓰지 않고 모든 것이 예상대로 있습니다.

여기서 우리가 거친 것은 약간 사소한 설정이지만, 파일 게시가 어떻게 작동하는지에 대한 핵심 개념과 함정에 빠질 수 있는 몇 가지 사항을 강조합니다. 따라서 자신의 워크플로우에서 그것을 피할 수 있기를 바랍니다.

여기서 우리가 한 것은 실제 상황에서는 다소 비실용적이라는 점도 주목할 가치가 있습니다. 일부 입력 데이터를 가져와서 해당 데이터를 사용하고 있지만, 해당 데이터에 따라 파일 이름도 지정하고 있는데, 일반적으로 할 수 없는 일입니다.

따라서 실제 더 성숙한 Nextflow 파이프라인에서는 특정 샘플과 관련된 모든 메타데이터가 포함된 메타 객체를 전달하는 경우가 많습니다. 그런 다음 이를 기반으로 동적 파일 이름을 만들 수 있으며, 이것이 훨씬 더 실용적입니다.

모범 사례로 이를 수행하는 방법에 관심이 있다면 _training.nextflow.io_에 메타데이터 및 메타 맵에 대한 사이드 퀘스트가 있으므로 자세한 내용을 파헤칠 수 있습니다.

## 3. 배열을 통해 여러 입력 제공하기

좋습니다. 다음으로 채널이 어떻게 구조화되어 있고 코딩 언어의 다른 종류의 데이터 구조와 어떻게 다른지 조금 탐구하겠습니다. 그리고 다른 언어에서 온 경우 익숙한 개념일 수 있는 배열을 잠재적으로 어떻게 사용할 수 있는지 생각해 보겠습니다.

채널에서 배열을 사용할 수 있을까요? 시도해 봅시다. 배열을 만들 것이고, 문서에서 이것을 복사했습니다. _"greetings_array"_ 및 _"Hello", "Bonjour"_ 및 _"Holà"_. 그리고 하드코딩된 문자열 대신 여기에 넣을 것입니다. 따라서 "Channel.of" _"greetings_array"_라고 하고, 이 배열을 채널에 전달할 것입니다. 시도해 봅시다.

터미널을 불러와서 파이프라인을 실행합니다.

좋습니다. view 문이 예상대로 배열을 출력했지만, 그런 다음 이 모든 빨간색 텍스트, 또는 여전히 _"-ansi-log"_를 끈 경우 빨간색이 아닐 것이지만, 이 모든 빨간색 텍스트는 뭔가 잘못되었다고 알려줍니다.

더 이상 멋진 녹색 체크 표시가 없습니다. 빨간색 십자가가 있고, 이것을 조금 더 넓게 만들어서 읽기 쉽게 하면 Nextflow가 무엇이 잘못되었는지 알려줍니다.

섹션별로 분석해 봅시다. 오류의 원인이라고 말하고, 그 다음 오류 이유는 출력 파일 누락입니다. 기본적으로 output 블록이 이 파일이 생성되어야 한다고 했지만 생성되지 않았습니다. 다음으로 실행된 명령이라고 합니다. 따라서 이것은 기본적으로 _.command.sh_ 파일의 내용입니다. 모든 변수가 입력된 후의 모습입니다.

그리고 여기서 echo 명령이 실제로 한 번만 실행되었고 전체 배열을 사용했지만 문자열 표현으로 사용했다는 것을 볼 수 있습니다. 이것은 우리가 원했던 것이 아닙니다.

그리고 명령이 그렇게 종료되었고, 그것이 우리가 가서 파일을 볼 수 있는 work 디렉토리였습니다.

좋습니다. 그래서 무슨 일이 일어났냐면 Nextflow가 이 전체 배열을 프로세스에 단일 채널 요소로 전달했고, 이는 프로세스가 한 번만 실행되었음을 의미합니다. 하나의 작업이 있었고 우리가 예상한 구조로 데이터를 사용하지 않았습니다.

## 3.2. 연산자를 사용하여 채널 내용 변환하기

따라서 사용하기 전에 이 채널에 무언가를 먼저 해야 합니다. 그리고 이것은 채널 내용을 조작하는 데 사용할 수 있는 특수 함수인 연산자 사용을 위한 단계를 설정합니다.

이 경우 _flatten_이라는 것을 사용할 것입니다. 여기 채널 끝에 전달합니다. 따라서 채널을 생성한 다음 _flatten_을 실행합니다. 다시 말하지만, 마우스를 올리면 VS Code에서 이 명령에 대한 문서를 바로 보여주는데, 이는 매우 유용합니다. Nextflow 웹사이트의 문서에서도 이러한 모든 문서를 찾을 수 있습니다.

지금 이 코드를 실행하고 작동하는지 볼 수 있지만, Nextflow 코드 내에서 연산자와 클로저라고 불리는 동적 코드를 수행하는 방법을 소개할 좋은 기회이기도 합니다.

따라서 _flatten_을 실행하기 전에 여기에 view 명령을 다시 추가하겠습니다. 그리고 여기에 이 중괄호가 있는데, 이것이 동적 클로저입니다. 그리고 view 연산자의 컨텍스트 내에서 실행될 임의의 코드가 여기에 있습니다.

여기서 이것은 greeting을 받는다고 말하고 있는데, 이것이 view 연산자의 입력이고 여기에 있습니다. 원하는 대로 부를 수 있습니다. _"foo"_라고 부를 수 있고 나중에 _"foo"_로 참조하면 됩니다. 그리고 이것으로 이것을 반환한다고 말합니다.

그런 다음 변수에 대해 flatten 전이라고 하는 문자열을 반환하도록 설정합니다. 매우 간단합니다.

이제 정확히 같은 것을 하나 더 추가하겠지만 _flatten_ 후라고 하겠습니다.

이것이 순서대로 실행되기 때문에, _flatten_을 실행하기 전에 채널이 어떻게 보이는지, 그리고 _flatten_을 실행한 후에 다시 어떻게 보이는지 볼 수 있습니다.

그리고 이 greeting 채널이 여전히 생성되므로 여전히 프로세스에 전달될 것입니다. 그리고 이제 워크플로우가 실행될 것입니다. 시도해 봅시다.

좋습니다. 우선 파이프라인이 이번에는 충돌하지 않았습니다. 제대로 실행된 세 개의 프로세스가 있었고 작은 체크 표시가 있습니다. 그리고 view 문이 작동했습니다.

_flatten_ 전에 실패에서 보았던 배열이 있고, 그 다음 _flatten_ 후가 세 번 호출되었고 배열의 세 개의 개별 요소가 이제 우리가 바랐던 대로 채널의 세 개의 개별 요소인 _"Hello", "Bonjour"_ 및 다른 세 개가 있습니다.

그리고 _view_ 연산자가 세 번 실행되었음을 볼 수 있습니다. 이는 _flatten_ 후 이 채널에 이제 세 개의 요소가 있기 때문입니다. 따라서 연산자가 세 번 호출됩니다.

매우 빠르게, 이전에 채널 팩토리를 만들 때 _"."_를 했고, 채널을 만드는 많은 다른 방법이 있다는 것을 보았고, 그 중 하나는 "_fromList"_라고 불립니다. 그리고 그것은 실제로 이 동일한 작업을 수행하도록 특별히 설계되었습니다. 따라서 greetings away에서 from list를 했을 수도 있고, 그것은 작동할 것입니다. 약간 깔끔하고 좋은 구문입니다. 하지만 이 시연의 목적을 위해, 채널이 어떻게 조작되는지, 다른 연산자가 채널 내용을 어떻게 변경할 수 있는지 볼 수 있도록 좀 더 단계별로 만들고 싶었습니다.

## 4. CSV 파일에서 입력 값 읽기

좋습니다, 어떻게 더 현실적으로 만들 수 있을까요? Nextflow 파이프라인에서 하드코딩된 배열로 많은 코드를 만들고 싶지는 않을 것입니다. 시작할 때 외부에서 데이터를 가져오고 싶을 것이고, 그 데이터는 거의 확실히 파일에 있을 것입니다.

따라서 다음으로 할 일은 이것을 복제하는 것이지만, 단일 CLI 매개변수나 하드코딩된 문자열 또는 배열에서 데이터를 가져오는 대신 파일에서 가져올 것입니다.

greetings away를 제거해 봅시다. 그리고 이제 이 채널 팩토리를 다시 변경할 것입니다. 방금 선택할 많은 것들이 있다고 말했고 _".fromPath"_라는 것이 있습니다. 그리고 이 경우 _params.input_을 받도록 하겠습니다. 이것은 이전에 사용했던 입력으로 돌아가는 것입니다.

이제 해당 매개변수는 실제로 사용할 준비가 되지 않았습니다. 여전히 문자열이고 기본값으로 여기에 하드코딩되어 있지만, 해당 문자열을 덮어쓸 수 있습니다. 이제 이것이 파일이기를 원합니다. 따라서 타입이 다릅니다. 더 이상 _String_이 아닙니다. _Path_입니다.

그리고 원하는 경우 다시 기본값을 Path로 설정할 수 있습니다. 그리고 왼쪽 탐색기를 보면 이 저장소, 이 작업 디렉토리에 data라는 디렉토리가 있습니다. 거기에 _"greetings.csv"_라는 파일이 있습니다.

따라서 여기에 기본값을 _"data/greetings.csv"_로 설정할 수 있습니다. 이제 명령줄 옵션 없이 이 파이프라인을 실행하면 이 기본값을 사용할 것입니다. 경로임을 알기 때문에 문자열이 아닌 경로로 처리해야 한다는 것을 알고 있습니다.

그런 다음 이 _params.input_에서 채널 팩토리로 전달되어 채널을 생성하고, 그런 다음 sayHello라는 이 프로세스에서 사용될 것입니다. 시도해 봅시다.

좋습니다. 실패했습니다. 걱정하지 마세요. 이것은 예상된 것이었습니다. 그리고 교육 자료를 따르고 있다면 거기서도 예상되었음을 볼 수 있습니다. 무슨 일이 일어나고 있는지 봅시다.

파이프라인을 실행하려고 했습니다. 프로세스를 실행하려고 했고 이전에 보았던 것과 꽤 유사한 오류가 발생했습니다.

여기서 실행하려고 했다고 말합니다. _echo_, 하지만 이 CSV 파일의 내용을 에코하는 대신 경로만 에코했습니다. 그리고 여기서 이 CSV 파일에 대한 전체 절대 경로인 것을 볼 수 있습니다.

그리고 과연, 이 정말 복잡한 경로에 쓰려고 했기 때문에 무엇을 해야 할지 잘 몰랐습니다. 그리고 프로세스 work 디렉토리의 범위를 벗어났습니다.

처음에 Nextflow가 특수 work 디렉토리 내에서 모든 실행된 작업을 캡슐화한다고 언급했습니다. 그리고 해당 work 디렉토리 외부에 있는 데이터에 쓰려고 하면 Nextflow가 안전 예방 조치로 막을 것입니다. 그리고 그것이 여기서 일어난 일입니다. 절대 경로에 쓰려고 했고 Nextflow가 실패하고 우리를 막았습니다.

## 4.2. splitCsv() 연산자를 사용하여 파일 분석하기

좋습니다, 이 채널을 살펴보고 어떻게 보이는지 봅시다. _".view"_를 할 수 있고, 웹사이트에서 이것을 복사했습니다. 따라서 _.view_, 그리고 여기에 동적 클로저가 있고 변수 이름 "_csv"_를 입력으로 말합니다. 따라서 이것이 채널 내용이고, splitCsv 전이라고 하며 이것이 어떻게 보이는지입니다.

다시 실행하면 여전히 실패하지만 이 채널 내부에 무엇이 있는지 보여줄 것입니다. 그다지 흥미롭지 않습니다. 그것은 _path_ 변수입니다. 터미널에 출력되기 때문에 여기서 단순히 문자열로 볼 수 있지만, 이 파일에 대한 정보와 메타데이터를 포함하는 _path_ 객체입니다.

파일의 메타데이터를 입력으로 전달하고 싶지 않습니다. 해당 파일의 내용을 전달하고 싶습니다. _greetings.csv_ 파일을 보면 여기에 이러한 다른 변수들이 있다는 것을 볼 수 있습니다. _Hello, Bonjour, Holà_ 다시. 그리고 이것들이 실제로 프로세스에 전달하고 싶은 것이지, 단일 객체로서의 파일 자체가 아닙니다.

따라서 이 CSV 파일을 분석해야 합니다. 압축을 풀고 CSV 파일의 내용을 가져와 채널 내의 내용을 프로세스에 전달해야 합니다.

로그 메시지에서 알 수 있듯이, 또 다른 연산자인 _splitCsv_를 사용하고 싶습니다. 따라서 "_dot" "s"_를 하면 자동 제안된 것을 볼 수 있습니다. 죄송합니다, _splitCsv_ 및 괄호.

그리고 _splitCsv_ 후에 어떻게 보이는지 볼 수 있도록 다른 _view_ 문을 넣겠습니다. 파이프라인을 실행하고 무엇을 얻었는지 봅시다.

좋습니다. 여전히 실패했지만, 새롭고 흥미로운 방식으로 실패했으므로 진전입니다.

이번에도 렌더링된 스크립트에 문제가 있습니다. 이제. 더 이상 최종 경로가 없지만, 고정 입력으로 배열을 전달할 때 이전에 발생한 오류와 매우 유사하게 보이는 변수 배열이 있습니다.

view 연산자의 로깅으로 _splitCsv_ 전이 경로였음을 볼 수 있습니다. 그리고 과연 _splitCsv_ 후에 세 개의 다른 출력이 있고 각 출력은 _greetings.csv_ 파일의 각 행과 매우 유사하게 보입니다. 이것은 타당합니다.

따라서 여기서 일어난 일은 Nextflow가 이 CSV 파일을 분석하여 각 CSV 파일 라인에 대해 하나의 배열인 세 개의 객체를 제공했다는 것입니다. 따라서 세 번 단일 문자열 값 대신 채널에 변수 배열을 전달했습니다.

좋습니다, 지난번에 이 문제가 있었을 때 _flatten_을 사용했습니다. 매우 빠르게 시도해 봅시다. flatten을 시도하고 무슨 일이 일어나는지 봅시다.

이 변수들을 무엇이든 부를 수 있습니다. 따라서 더 이상 실제로 CSV가 아니기 때문에 _myarray_라고 부르겠습니다. 다시 실행하고 _flatten_으로 무슨 일이 일어나는지 봅시다.

이번에는 실행할 것이고, CSV를 세 개의 배열 객체로 분석한 다음 평탄화했습니다. 그리고 이번에는 통과했습니다. 그리고 Nextflow 파이프라인이 실행되었습니다. 그러나 _flatten_이 정말로 완전히 작동하여 모든 것을 평탄화한다는 것을 볼 수 있습니다. 그래서 각 행에 대해 세 개의 독립적인 배열 항목을 얻습니다. 따라서 CSV의 모든 행마다 프로세스를 세 번 실행했습니다. 그리고 이제 우리가 실제로 원했던 CSV의 첫 번째 열뿐만 아니라 123, 456 및 모든 종류의 것들의 결과 파일이 많이 있습니다.

## 4.3. map() 연산자를 사용하여 인사말 추출하기

그럼 첫 번째 열만 어떻게 얻을까요? flatten이 여기서 너무 단순하다면, 실제로 사용자 정의하고 CSV에서 원하는 것을 알려줄 수 있는 더 복잡한 연산자가 필요합니다.

그렇게 하려면 _map_을 사용할 것입니다. 기본적으로 _map_은 주어진 모든 요소에 대해 일부 코드, 일부 함수를 실행하고 일종의 변환을 수행한다고 말합니다. 그리고 매우 유연하기 때문에 Nextflow 코드에서 항상 나타나는 것을 볼 수 있습니다.

그 자체로는 아무것도 하지 않습니다. 따라서 일반 괄호를 원하지 않고 여기에 클로저가 필요하며 무엇을 해야 하는지 알려줘야 합니다. 따라서 _"row"_라고 하겠습니다. 왜냐하면 CSV에서 행을 받고 있기 때문에 논리적인 변수 이름입니다. 입력입니다. 그리고 해당 배열의 첫 번째 요소만 반환하고 싶습니다.

Nextflow의 배열은 0 기반이므로 행 0인 첫 번째 요소만 말하겠습니다. 두 번째 열을 원하면 1이 될 수 있고 세 번째 열은 2가 될 수 있으며, 계속됩니다. 여기서 원하는 것을 반환할 수 있지만 첫 번째 값만 반환하겠습니다.

그리고 이제 파이프라인을 다시 실행하고 예상대로 작동하는지 볼 수 있습니다.

과연 _splitCsv_ 후에 배열이 있고, 그런 다음 _map_ 후에 _"Hello", "Bonjour"_ 및 _"Holà"_ 단순한 깨끗한 문자열이 있습니다. 그리고 파이프라인은 이제 우리가 원하는 것을 하고 있습니다. 환상적입니다.

따라서 이제 이러한 모든 view 명령을 제거할 수 있습니다. 더 이상 필요하지 않습니다.

## 요약

디버깅을 완료했고 이것이 우리가 끝낸 코드입니다. _Path_로 분류된 _input_이라는 CLI 매개변수를 가져옵니다. Nextflow가 경로를 찾고 로드하며 CSV 파일을 이해합니다. 모든 다른 행을 반환합니다. 그런 다음 해당 행의 첫 번째 요소만 채널 내용을 제공하는 채널에 매핑하고, 이는 프로세스에 전달됩니다.

그리고 프로세스는 채널의 각 요소에 대해 실행되는데, 이것은 3입니다. 그리고 프로세스를 세 번 실행하여 세 개의 작업을 제공합니다. 그리고 해당 결과는 워크플로우에서 게시되고 프로세스 output에서 선택되어 워크플로우에서 게시되고 output 블록에서 _"hello_channels"_라는 하위 디렉토리에 저장됩니다.

꽤 멋집니다. 이제 실제 분석을 위해 실행할 수 있는 실제 Nextflow 파이프라인과 더 유사한 것에 가까워지고 있습니다.

## 핵심 정리

좋습니다. 이제 Nextflow 채널과 연산자가 무엇인지, 연산자가 채널에서 어떻게 작동하는지, 어떻게 생성할 수 있는지에 대한 느낌을 얻었기를 바랍니다.

이 비디오의 시작 부분에서 말했듯이 채널은 Nextflow의 접착제입니다. 그리고 여기서 다양한 입력을 가져와 조작하고 해당 데이터를 가져와 다운스트림 워크플로우 로직에 전달할 수 있다는 것을 볼 수 있습니다.

그리고 여기 이 workflow 블록은 실제로 모든 병렬화와 모든 영리한 로직을 구축하고 Nextflow에 워크플로우 DAG를 구축하는 방법과 파이프라인을 조율하는 방법을 설명하는 곳입니다.

채널은 이해하기 가장 쉬운 개념이 아닙니다. 따라서 휴식을 취하고, 이것에 대해 조금 생각하고, 자료를 다시 읽어보고, 이러한 개념을 정말로 이해했는지 확인하세요. 왜냐하면 이것이 Nextflow 이해의 핵심이고 채널과 다양한 채널 연산자 및 다양한 채널 팩토리를 더 잘 이해할수록 Nextflow를 작성하는 것이 더 재미있고 파이프라인이 더 강력해질 것이기 때문입니다.

이것은 Python이나 다른 언어에서의 일반 프로그래밍과 같지 않습니다. 여기서는 _if_ 문을 사용하지 않습니다. 이것은 채널과 연산자를 사용하는 함수형 플로우 프로그래밍입니다. 따라서 약간 다르지만, 또한 매우 강력합니다.

이것이 이 챕터의 끝입니다. 빠른 휴식을 취하시면 파트 3의 다음 영상에서 뵙겠습니다. 파트 3에서는 Hello Workflow를 살펴보고 워크플로우에 대해 좀 더 이야기할 것입니다.

이전 챕터와 마찬가지로 여기 웹페이지 하단에 몇 가지 퀴즈 질문이 있으므로 빠르게 살펴보고 방금 완료한 자료의 모든 다른 부분을 이해했는지 확인할 수 있습니다. 그리고 그 외에는 다음 영상에서 뵙겠습니다. 대단히 감사합니다.

좋습니다.
