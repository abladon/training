# Part 2: Hello Channels - 스크립트

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보기 및 개선 제안](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/lJ41WMMm44M?si=xCItHLiOQWqoqBB9&amp;list=PLPZ8WHdZGxmXiHf8B26oB_fTfoKQdhlik" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 사항"

    이 페이지는 스크립트만 보여줍니다. 전체 단계별 지침을 보려면 [교육 자료](../02_hello_channels.md)로 돌아가십시오.

    스크립트에 표시된 섹션 번호는 참고용으로만 제공되며 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영합니다

안녕하십니까, Hello Nextflow의 파트 2에 오신 것을 환영합니다.

이 장의 제목은 Hello Channels입니다. Nextflow의 이 기본적인 부분에 대해 모두 이야기할 것입니다.

Channel은 파이프라인의 서로 다른 단계를 연결하는 것으로, 데이터와 로직이 워크플로우를 통해 흐르는 방식입니다.

좋습니다, 시작해 보겠습니다.

training.nextflow.io로 이동하는 것부터 시작하겠습니다.

사이드바에서 Hello Nextflow를 찾아 파트 2를 클릭하십시오. Hello Channels입니다.

모든 자료가 여기에 작성되어 있으므로 자신의 속도로 따라가며 놓친 부분을 확인할 수 있습니다.

웹사이트를 열었으면 Codespaces를 로드할 수 있으며, 지난 장의 마지막 부분부터 계속 진행하겠습니다.

## 0. 준비운동: hello-channels.nf 실행하기

이 장에서는 다른 파일을 편집할 것입니다. 이 파일의 이름은 Hello Channels이므로 사이드바에서 찾아 더블 클릭하여 여십시오.

이제 막 1장에서 오셨다면 이 파일이 매우 익숙해 보일 것입니다. 여기의 시작점은 기본적으로 1장을 마친 곳으로, sayHello라는 프로세스, 입력, 출력, publishDir, params.greeting, 그리고 간단한 워크플로우가 있습니다.

새로운 파일로 시작하고 있으므로 모두에게 공평한 출발점이지만, 원하시면 이전 파일을 계속 사용하셔도 됩니다.

참고로, 저는 모든 .nextflow\* 파일과 work 디렉토리를 삭제하여 깨끗한 시작점을 만들었습니다. 이것을 하든 안 하든 상관없으며, 선택에 달려 있습니다.

좋습니다. 이 파이프라인이 예상대로 작동하는지 확인하는 것부터 시작하겠습니다. 여기서 터미널을 열겠습니다.

"nextflow run hello-channels.nf"를 입력하고 엔터를 누르십시오.

작은 워크플로우를 실행하고, sayHello 단계를 실행하고, 해시가 있는 work 디렉토리를 생성하며, 여기 results 폴더가 있고 출력 파일이 있습니다. 기본 params.greeting에서 예상한 대로입니다.

좋습니다. 1장과 정확히 같으며, 예상대로 작동합니다.

## 1. 채널을 통해 명시적으로 변수 입력 제공하기

1장에서는 실제로 이미 channel을 사용하고 있었지만, 그것을 깨닫지 못했을 뿐입니다. 여기에 문자열을 지정했을 때, Nextflow는 프로세스를 호출하고 있다는 것을 알았기 때문에 입력 channel이 필요하다는 것을 알고 자동으로 해당 문자열 주위에 channel을 생성했습니다.

우리가 할 첫 번째 일은 실제로 channel 자체를 입력하여 명시적으로 만드는 것입니다.

## 1.1. 입력 채널 생성하기

스크립트 하단의 workflow로 이동하여 greeting_ch라고 입력하겠습니다. 이것은 Nextflow 코드에서 자주 사용하는 관례로, channel일 때 변수 이름 끝에 언더스코어 ch를 붙이는 것입니다. 이렇게 하면 channel임을 쉽게 식별할 수 있지만, 반드시 그렇게 할 필요는 없습니다. equals channel of Hello Channels.

방금 사용한 것은 Nextflow 언어에서 "Channel Factory"라고 불리는 것입니다. 이것이 여기 있는 것으로, 이 변수를 새 channel로 설정하고 있으며, 여기의 이 channel factory가 특정 방식으로 channel을 생성하고 있습니다.

Nextflow에는 다양한 유형의 입력에서 channel을 생성하는 여러 가지 channel factory가 있습니다. Dot of는 가장 간단한 것으로, 우리가 제공하는 모든 문자열을 받습니다.

VS Code에서 이러한 단어 위에 마우스를 올려놓으면 Nextflow 확장 프로그램이 이 구문이 무엇을 하는지 설명하는 팝업을 제공하며, 팝업 창 하단에 더 읽기 텍스트도 있습니다.

그것을 클릭하면 Nextflow 문서가 새 탭에서 열리고 이 특정 항목에 대한 문서로 바로 이동합니다. 이 경우 channel.of에 대한 것입니다.

## 1.2. 프로세스 호출에 채널을 입력으로 추가하기

확장 프로그램이 경고도 제공하고 있으며, 여기서 새 channel을 생성했지만 아무것도 사용하지 않고 있다고 말하고 있습니다.

그러니 고쳐봅시다. 새 channel 이름을 가져와서 이 params.greeting을 우리의 새 channel로 교체하겠습니다.

이제 명령줄 플래그 --greeting을 더 이상 사용하지 않으며, params.greeting이 사용되지 않고, 이 문자열을 다시 하드코딩하고 있습니다. 괜찮습니다. 저는 단순하게 유지하려고 합니다. 나중에 다시 돌아와서 params를 사용하겠습니다.

## 1.3. 워크플로우 명령을 다시 실행하기

좋습니다, 이것이 작동하는지 다시 확인해 봅시다. 터미널을 열고 다시 확인합니다. Nextflow run hello channels. output.txt를 확인하면, 거기 있습니다.

좋습니다. 약간 지루한 예제이지만, 이전과 정확히 같은 일을 하고 있습니다. 하지만 이제 적어도 로직이 좀 더 명확합니다. 새 channel을 작성하는 것에 대해 명시적으로 작성하고 있습니다.

효과적으로 같은 일을 하기 위해 더 많은 코드를 작성했습니다. 하지만 channel을 생성하는 방법이 좀 더 복잡해지면서 이것이 더 의미가 있기 시작할 것입니다.

## 2. 여러 입력 값에서 실행되도록 워크플로우 수정하기

좋습니다, 이것을 좀 더 흥미롭게 만들어 봅시다. Nextflow 파이프라인을 단일 입력에서 실행하는 것은 매우 드물므로 여러 입력을 제공해 봅시다.

## 2.1. 입력 채널에 여러 인사말 로드하기

여기 문서에서 이러한 다른 문자열 세 개를 복사하겠습니다. Hello, Bonjour, Olà. 오, Copilot이 몇 가지 다른 것을 제안하고 있습니다. 그러니 탭으로 입력하겠습니다.

여기 Nextflow 문서는 이 연산자에 여러 값을 제공할 수 있다고 알려주므로 작동해야 하지만, 시도해 보고 무슨 일이 일어나는지 봅시다.

## 2.1.2. 명령을 실행하고 로그 출력 보기

음. 예, 아니오. 봅시다. 여기서 5개 중 5개의 작업이 실행되었다고 말하지만, 하나의 해시만 표시하는데, 이것은 약간 이상합니다. 괜찮습니다. 여기서 모든 것이 예상대로입니다. 기본적으로 Nextflow는 ANSI 제어 코드라고 하는 특별한 유형의 터미널 출력을 사용하며, 이는 실행 중인 모든 다른 프로세스의 멋진 압축 보기를 제공하기 위해 특정 줄을 덮어씁니다.

이것은 더 큰 워크플로우가 있고 수백 또는 수천 개의 다른 샘플을 실행할 때 훨씬 더 의미가 있습니다. 터미널에서 너무 많은 출력을 생성하여 보는 것이 불가능한 반면, 이 업데이트 보기는 실시간 진행 상황을 제공합니다.

## 2.1.3. -ansi-log false 옵션으로 명령을 다시 실행하기

원하시면 다시 실행할 수 있으며, 이번에는 단일 하이픈과 함께 추가 Nextflow 핵심 인수를 사용하여 "-ansi-log false"라고 하겠습니다. 이것은 이전 버전의 Nextflow 로그 출력을 사용합니다. 그리고 여기서 시작된 모든 개별 프로세스를 볼 수 있습니다.

이것을 하든 안 하든 선택 사항입니다. Nextflow의 출력은 두 경우 모두 정확히 같습니다.

## 2.2. 출력 파일 이름이 고유하도록 보장하기

좋습니다, 출력 파일을 봅시다. results로 가겠습니다. 하지만 단일 출력 파일만 있습니다. 무슨 일이 일어났나요? 프로세스가 여러 번 실행되었다는 것을 보았습니다. work 디렉토리로 가서 모든 다른 해시를 볼 수 있으며, 모든 작업이 제대로 실행되었습니다. 하지만 여기 프로세스에서 모든 것을 output.txt 파일에 저장한 다음 이 디렉토리에 게시하는 것을 기억하신다면,

동일한 파일이 5번 생성된 다음 5번 덮어쓰기 되었습니다. 그리고 마지막으로 실행된 작업만 있습니다.

## 2.2.1. 동적 출력 파일 이름 구성하기

이것을 수정하는 방법은 동적 출력 파일 이름을 사용하는 것입니다. 여기 프로세스 내에 이미 greeting이라는 변수가 있으므로 출력 파일 이름에 사용할 수 있습니다. 복사하고 $greeting-output.txt를 수행하겠습니다.

bash가 여기에 들어갈 수 있는 공백으로 인해 혼란스러워하지 않도록 따옴표로 둘러싸겠습니다. 그런 다음 동일한 파일 이름을 가져와 여기 출력을 업데이트하겠습니다.

출력이 이것과 일치하는 것이 정말 중요합니다. 그렇지 않으면 이 파일을 찾을 수 없고 Nextflow가 충돌합니다.

하나 더 정말 중요한 편집을 하겠습니다. 이 단일 따옴표를 이중 따옴표로 변경하겠습니다. 그렇게 했을 때 코드의 색상이 변경된 것을 주목하십시오. 이 변수는 이중 따옴표를 사용할 때만 확장됩니다. 여기서 단일 따옴표를 사용하면 리터럴 값으로 사용되며, $greeting-output이라는 단일 파일을 얻게 되는데, 이것은 제가 원하는 것이 아닙니다.

## 2.2.2. 워크플로우 실행하기

그러니 이중 따옴표를 다시 넣고 시도해 봅시다.

시작하기 전에 디렉토리를 정리하여 새 파일을 쉽게 볼 수 있도록 하겠습니다. .nextflow, work, results라는 모든 것을 삭제하겠습니다.

그리고 Nextflow 명령을 다시 실행하고 어떤 파일이 생성되는지 봅시다. 거기서 5개의 프로세스를 실행합니다. 매우 자세히 보고 있었다면 실행 중에 해당 줄이 업데이트되는 것을 보았을 것입니다.

이제 results 디렉토리로 들어가면, 확실히 5개의 다른 출력이 있고 모두 다른 인사말로 접두사가 붙어 있습니다.

각각을 열면 각각 해당 인사말이 포함되어 있음을 알 수 있습니다. 환상적입니다. 그것이 우리가 원하는 것입니다.

## 3. 연산자를 사용하여 채널의 내용 변환하기

좋습니다, 이제 channel이 무엇인지, channel factory가 무엇인지 알고 있습니다. operator는 어떻습니까? 이것은 Nextflow 언어의 또 다른 용어로, channel에서 작동하여 특정 작업을 수행할 수 있는 일련의 함수입니다. Nextflow는 다양한 방식으로 channel을 조작할 수 있는 일련의 operator와 함께 제공됩니다.

## 3.1. 채널에 입력으로 값 배열 제공하기

예제를 통해 작업해 봅시다. 이러한 입력 문자열을 가져오되, channel factory에 직접 넣는 대신 배열로 정의하고 싶다고 가정해 봅시다.

## 3.1.1. 입력 변수 설정하기

그러니 이것들을 가져와서 위에 새 줄로 만들고 greetings, array라고 하겠습니다.

됐습니다. 그 배열 변수를 가져와 channel.of에 넣고 저장을 누르겠습니다.

## 3.1.3. 워크플로우 실행하기

이제 무슨 일이 일어나는지 봅시다. 터미널로 돌아가겠습니다. 모든 임시 파일을 다시 정리하겠습니다. 그리고 워크플로우를 실행해 봅시다.

좋지 않습니다. 좋습니다. 깨졌습니다. 괜찮습니다. 이번에는 깨질 것으로 예상했습니다. Nextflow 워크플로우가 실패할 때 무엇이 잘못되었는지 디버깅하는 것은 Nextflow 개발자가 되는 핵심 부분입니다. 이것은 많이 발생할 것이며 오류 메시지가 무엇을 말하는지, 어떻게 처리하는지 이해하는 것이 중요합니다.

Nextflow 오류 메시지는 실제로 매우 구조화되어 있습니다. 어떤 프로세스가 잘못되었는지 알려줍니다. 이유에 대한 오류 메시지를 제공합니다. 특정 작업 내에서 실행하려고 시도한 명령이 무엇이었는지, 종료 상태가 무엇이었는지, 해당 작업 work 디렉토리가 어디에 있었는지에 대한 출력이 무엇이었는지 말합니다.

VS Code에서 이것을 옵션 클릭하면 사이드바에서 열리므로 바로 거기로 가서 이전 장에서 이야기한 모든 숨겨진 파일을 볼 수 있습니다. .command.sh 파일을 포함합니다. 이것을 보면 여기에서 실행된 명령과 동일합니다.

이 파일을 보면 배열의 각 요소에 대해 단일 작업을 실행하는 대신 마지막에 수행한 것처럼 전체 배열을 문자열로 한 번에 제공했다는 것을 알 수 있습니다. 그러므로 channel에 전달하기 전에 해당 배열을 개별 값으로 풀어야 합니다. 돌아가서 operator를 사용하여 그렇게 할 수 있는지 봅시다.

## 3.2. 연산자를 사용하여 채널 내용 변환하기

이 경우 channel에 전달하기 전에 배열을 변경하지 않을 것입니다. 예상하는 방식으로 작동하도록 channel을 조정할 것입니다. flatten operator를 사용하여 그렇게 할 것이며 dot를 입력하기 시작하면 VS Code 확장 프로그램이 사용할 수 있는 모든 다른 operator를 제안하기 시작하는 것을 볼 수 있습니다.

## 3.2.1. flatten() 연산자 추가하기

그리고 flatten을 선택하겠습니다. Nextflow에서 이 컨텍스트에서 공백은 중요하지 않습니다. 원하시면 새 줄에 이러한 operator를 넣을 수 있습니다. 그래서 여기 아래로 내려서 ".of" 아래에 오도록 들여쓰기를 할 수 있으며, 사람들이 종종 channel에 많은 operator를 이런 식으로 연결하고 읽기 쉽도록 이런 식으로 들여쓰기하는 것을 볼 수 있습니다.

이전처럼 이것 위에 마우스를 올려놓고 flatten operator가 무엇을 하는지 읽을 수 있으며, 원하시면 문서에 대한 링크를 따라갈 수도 있습니다.

따라서 이 operator는 내부에 단일 배열이 있는 이 channel을 가져와서 배열 값을 분리합니다.

## 3.2.2. view()를 추가하여 채널 내용 검사하기

특별한 view operator를 사용하여 channel을 들여다볼 수 있으며, 여기에 몇 개를 추가하겠습니다. 이것은 다른 언어에서 print 문을 사용하는 것과 비슷합니다. 그래서 dot view를 수행한 다음 이러한 물결 모양 괄호를 사용하겠습니다.

이것을 closure라고 합니다. 이것은 기본적으로 view operator에 추가 코드를 제공하며, channel 내의 각 항목에 대해 실행됩니다. 이 경우 greeting before flatten이라고 하겠습니다. Greeting.

여기서 이 closure의 범위 내에서만 사용되는 변수를 정의하고 있습니다. 따라서 이 변수는 여기서만 사용되며 원하는 대로 호출할 수 있습니다. 읽기 쉽게 하기 위해 greeting을 사용하고 있을 뿐입니다.

일부 Nextflow 파이프라인에서는 사람들이 "$it"라는 특별한 암시적 변수를 사용하는 것을 볼 수 있습니다. 이와 같이. 이것은 Nextflow 코드 내의 특별한 변수로, 작은 변수 정의를 할 필요가 없도록 하는 약어입니다. 그러나 시간이 지남에 따라 우리는 이것이 Nextflow를 처음 접하는 사람들에게 매우 명확하지 않다고 생각하고 있으며, 이제 "$it"의 사용을 권장하지 않습니다.

그러니 greeting을 사용하는 이전 동작을 고수하고 이렇게 사용하겠습니다. 무슨 일이 일어나고 있는지 더 명시적이고 명확하기 때문입니다.

그런 다음 이 줄을 복사하고 flatten 인수 다음에 정확히 같은 작업을 다시 수행하겠습니다. view operator는 요소에서 무언가를 수행하지만 다음 operator로 계속 전달하므로 이와 같이 작업 체인 중간에 연결할 수 있으며 거기에 상태를 인쇄하고 계속 진행합니다. 따라서 이것이 flatten operator 전후에 channel이 어떻게 보이는지 보여줄 것입니다.

## 3.2.3. 워크플로우 실행하기

시도해 봅시다. 워크스페이스의 모든 것을 정리합니다. 파이프라인을 다시 실행합니다.

좋습니다, 5개의 프로세스를 다시 실행했다는 것을 볼 수 있습니다. 오류와 함께 충돌하지 않았으므로 확실히 좋습니다. 이제 before flatten이 있고 확실히 배열이 있으며 after flatten이 5번 인쇄되었으며 배열의 각 요소마다 한 번씩입니다. 그것이 정확히 우리가 바라던 것입니다. 그래서 정말 좋은 소식입니다. 그리고 그것은 코드에서 예상한 것과 정확히 일치합니다.

더 이상 이러한 디버그 문이 필요하지 않으므로 주석 처리하거나 삭제할 수 있습니다. 코드를 깔끔하고 깨끗하게 유지하기 위해 삭제하겠습니다. 좋습니다, 좋습니다. 이 예제는 이제 잘 작동하고 있으며 channel이 좀 더 복잡한 로직을 수행할 수 있는 방법을 보기 시작할 수 있습니다.

## 4. 연산자를 사용하여 CSV 파일에서 입력 값 파싱하기

이제 대신 일련의 입력이 있는 파일을 사용하여 이것을 수행해 보겠습니다. 이것은 샘플 시트 또는 메타데이터 CSV를 사용하여 Nextflow 파이프라인을 작성하는 매우 일반적인 방법입니다.

## 4.1. CSV 파일을 인사말 소스로 예상하도록 스크립트 수정하기

사이드바로 이동하면 예제 리포지토리에서 greetings.csv를 볼 수 있으며, 이것은 세 가지 다른 인사말이 포함된 세 줄만 포함하는 매우 매우 간단한 CSV 파일입니다. 워크플로우 내에서 이 CSV 파일을 사용할 수 있는지 봅시다.

이제 1장에서 했던 것처럼 params를 사용하여 명령줄 입력을 가질 수 있도록 하겠습니다.

이 greetings 배열을 삭제하겠습니다.

## 4.1.1. 입력 매개변수를 CSV 파일을 가리키도록 전환하기

params greeting을 파일 이름인 greetings.csv로 설정하겠습니다. 그리고 이 특별한 변수를 사용하여 channel을 생성하겠습니다. 거기에 넣겠습니다. 오류가 사라집니다. 이것이 기본적으로 이 변수를 설정하고 있다는 것을 기억하십시오. 따라서 인수 없이 파이프라인을 실행하면 greetings.csv를 사용하지만, 원하면 --greeting을 수행하여 이 변수를 덮어쓸 수 있습니다.

## 4.1.2. 파일을 처리하도록 설계된 채널 팩토리로 전환하기

좋습니다, 이제 문자열이나 문자열 배열이 아닌 파일을 전달하고 있으므로 다른 channel factory가 필요할 것입니다.

지금까지 사용해 온 "of"를 없애고 대신 .fromPath를 사용하겠습니다. 이것은 들리는 것처럼 정확히 수행합니다. 문자열 파일 이름이나 glob을 사용하여 값 대신 경로가 있는 channel을 생성합니다. 또한 파일을 전달하고 있으므로 더 이상 필요하지 않으므로 flatten operator를 제거하겠습니다.

## 4.1.3. 워크플로우 실행하기

저장을 누르고 터미널을 열고 워크플로우를 실행한 다음 무슨 일이 일어나는지 봅시다.

좋습니다. 다시 충돌했습니다. 걱정하지 마십시오. 이것도 예상했습니다. 오류 메시지를 살펴보고 무엇이 잘못되고 있는지 알아낼 수 있는지 봅시다. 여기서 실행된 명령을 볼 수 있으며, 전체 배열이 인쇄된 것처럼 이전과 비슷합니다. 이제 파일 내용을 살펴보는 대신 명령으로 에코되는 파일 경로가 있습니다.

## 4.2. splitCsv() 연산자를 사용하여 파일 파싱하기

따라서 대신 파일의 내용을 사용하려면 다른 operator가 필요합니다. 이것에 사용할 operator는 splitCsv라고 합니다. CSV 파일을 로드하고 있으므로 의미가 있습니다.

## 4.2.1. 채널에 splitCsv() 적용하기

좋습니다, splitCsv. 닫는 괄호. 여기에는 인수가 필요하지 않습니다. 그리고 다시, 여기서 무슨 일이 일어나고 있는지에 대한 통찰력을 제공하기 위해 일부 view operator를 사용하겠습니다.

.view csv after splitCsv. Before split Csv.

## 4.2.2. 워크플로우를 다시 실행하기

좋습니다, 이것을 실행하고 무슨 일이 일어나는지 봅시다.

좋습니다, 이번에는 좀 더 많은 출력이 있지만 여전히 실패했습니다. view 문을 보면 여기서 before split CSV를 볼 수 있으며, 이전 오류 메시지에서 보았던 것처럼 파일 경로가 있습니다. After split CSV에서는 이제 CSV 파일의 세 줄에 해당하는 세 개의 값이 있습니다.

그러나 이러한 각 값이 대괄호로 둘러싸여 있는 것을 볼 수 있습니다. 따라서 그 각각은 그 자체로 배열이었고, 이것은 문자열이 아닌 배열을 에코하려고 시도하는 이전과 동일한 영역을 제공했습니다.

CSV 파일에 대해 생각해 보면 이것은 어느 정도 의미가 있습니다. 일반적으로 CSV 파일에는 행과 열이 있으므로 split CSV는 2차원 배열을 수행합니다. 배열의 첫 번째 차원은 각 행이고, 각 행의 각 열인 두 번째 차원이 있습니다.

따라서 여기서는 각 줄에 단일 값만 있으므로 단일 열이 있으므로 파일의 각 줄에 대해 1개 요소 배열이 있습니다.

괜찮습니다. 파싱된 CSV 파일의 각 줄에 대해 해당 배열을 축소하려면 다른 operator가 필요합니다. 이것을 정리합시다. 터미널을 없애고 무엇을 할 수 있는지 봅시다.

## 4.3. map() 연산자를 사용하여 인사말 추출하기

이제 이전에 사용했던 flatten operator를 다시 사용할 수 있습니다. 배열을 일련의 값으로 축소할 수 있는 방법을 보았으며, 여기서 매우 잘 작동할 것입니다. 하지만 map operator라는 워크플로우 내에서 매우 일반적인 다른 operator를 시연할 기회를 사용하겠습니다.

## 4.3.1. 채널에 map() 적용하기

dot map을 수행하고 item item[0]을 수행하겠습니다.

다른 많은 코드 언어를 작성하는 경우 이미 map operator에 익숙할 수 있습니다. 배열이나 channel과 같은 반복 가능한 것을 가져와서 그 각 값에 대해 일부 작업을 수행합니다.

여기서 우리는 이 closure의 범위 내에서 item이라는 변수를 정의해야 한다고 말하고 있으며, 그 다음 해당 배열의 첫 번째 값만 반환하기를 원합니다. 따라서 item index zero입니다.

이것은 효과적으로 배열을 평탄화하고 있습니다. 하지만 이것을 더 복잡하게 확장할 수 있는 방법을 볼 수 있습니다: CSV 파일에 6개의 열이 있지만 네 번째 열에만 관심이 있다면 여기에서 특정 인덱스에 액세스할 수 있습니다. 또는 다운스트림 처리로 전달하기 전에 값에 대해 다른 종류의 작업을 수행할 수 있습니다.

따라서 map operator는 비행 중에 channel을 수정하는 데 매우 유연하고 강력합니다. 실행에서 무엇을 하고 있는지 볼 수 있도록 다른 view 문을 넣겠습니다. 해당 줄을 판결하고 아래로 이동할 수 있습니다. 그리고 after map.

## 4.3.2. 워크플로우를 한 번 더 실행하기

터미널을 열고 워크플로우를 실행해 봅시다.

좋습니다, 이번에는 오류가 없습니다. 좋은 신호입니다. 이제 view 문의 모든 다른 출력을 살펴볼 수 있습니다. Before split CSV에서 단일 경로가 있었습니다. After split CSV에서 단일 값 배열이 있었고, after map 다음에 배열 구문 없이 값만 있습니다. results 디렉토리로 올라가면 출력 파일이 우리가 원하는 대로 정확히 작동하고 있습니다.

여기에 작은 보너스가 있습니다. view operator가 수행한 출력 순서가 약간 섞여 있는 것을 실제로 볼 수 있습니다. 이것은 Nextflow가 이러한 다른 작업의 병렬화를 수행하고 있기 때문입니다. 따라서 CSV를 분할한 후 이 channel에 세 개의 요소가 있으며 이러한 세 요소의 처리를 자동으로 병렬로 처리하고 있습니다. 즉, 출력 순서가 확률적이며 변할 수 있습니다. 이 경우 일부 view operator가 후속 단계가 완료된 후 반환되어 이 순서로 나왔습니다.

동일한 워크플로우를 다시 실행하면. 확실히 다른 순서로 나왔으며 이번에는 예상대로 순서대로 split CSV와 map을 얻었습니다.

따라서 Nextflow가 이 병렬화를 자동으로 처리하고 있기 때문에 프로세스 작업의 출력 순서에 의존할 수 없다는 점을 명심하십시오. Nextflow는 데이터 흐름 로직으로 그것을 수행하며, 그것이 Nextflow의 진정한 힘입니다.

좋습니다, 이것은 아마도 전체 교육에서 가장 중요한 장 중 하나일 것입니다. channel, channel factory 및 operator를 이해하면 Nextflow의 강점과 프로그래밍 언어로서 독특하게 만드는 것에 대한 열쇠를 얻기 시작합니다. 이 기능을 통해 Nextflow는 모든 워크플로우를 자동으로 병렬화하고 매우 깔끔한 구문과 푸시 데이터 흐름 모델로 극도로 복잡한 워크플로우 로직을 생성할 수 있습니다. 처음에는 약간 이상한 개념일 수 있지만, 이와 같은 코드를 작성하는 데 익숙해지면 빠르게 자연스럽게 느껴질 것이며, 알기도 전에 환상적인 워크플로우를 작성하게 될 것입니다.

휴식을 취하고 차 한 잔을 마시고 산책을 하고 이러한 개념을 더 복잡한 워크플로우로 확장하기 시작하는 3장으로 넘어갑시다. 다음 비디오에서 뵙겠습니다.

[다음 비디오 스크립트 :octicons-arrow-right-24:](03_hello_workflow.md)
