# 파트 1: Hello World - 대본

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보기 및 개선 제안](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/8X2hHI-9vms?si=F0t9LFYLjAWoyRXj&amp;list=PLPZ8WHdZGxmXiHf8B26oB_fTfoKQdhlik" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 참고사항"

    이 페이지는 대본만 보여줍니다. 전체 단계별 지침은 [강의 자료](../01_hello_world.md)로 돌아가십시오.

    대본에 표시된 섹션 번호는 참고용으로만 제공되며 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영합니다

안녕하세요, Hello Nextflow 첫 번째 장에 오신 것을 환영합니다.

여섯 파트로 구성된 강의의 첫 번째 파트에서는 Nextflow의 기초를 다루겠습니다. 터미널에서 몇 가지 명령을 실행하는 것부터 시작하여, 그 Bash 명령을 Nextflow 스크립트로 구축하는 방법을 살펴보겠습니다.

첫 번째 Nextflow 파이프라인을 실행해보고, Nextflow가 무엇을 하는지, 어디서 실행되는지, 어떤 파일을 생성하는지, 그리고 그 파일들의 목적이 무엇인지 확인하겠습니다.

좋습니다, 시작하겠습니다.

## training.nextflow.io

먼저, training.nextflow.io로 이동하십시오. 이전과 마찬가지로 모든 자료가 여기에 작성되어 있으며, 단계별로 작업하겠습니다. 교육 단계를 진행하면서 제 화면을 보여드리겠습니다. 제가 말하는 모든 내용은 교육 자료에 있으므로 자신의 속도에 맞춰 따라올 수 있으며, 모두 거기에서 찾을 수 있습니다.

이 비디오는 자막도 활성화되어 있으니, 원하시면 자막을 켜서 제가 말하는 내용을 정확히 따라갈 수 있습니다.

좋습니다, Hello Nextflow로 가겠습니다. 오늘 진행할 강의이며, 첫 번째 비디오에서 오리엔테이션은 이미 완료했으므로 바로 파트 1로 들어가겠습니다. Hello World.

이제 교육 자료를 떠나 Code Spaces 환경으로 이동하겠습니다. 이것은 첫 번째 비디오에서 설정한 것입니다. 여러분의 시스템에도 이와 매우 유사한 것이 있기를 바랍니다. 저는 VS Code를 사용하고 있으며 교육 자료를 보고 있고, hello Nextflow 디렉토리로 디렉토리를 변경했습니다.

## 0. 워밍업: Hello World 직접 실행

좋습니다. 모두에게 익숙하게 느껴질 몇 가지 기본 사항부터 시작하겠습니다. 터미널에서 매우 기본적인 명령을 작성하는 것부터 시작하겠습니다. 여기 아래에서 'echo Hello World!"'라고 입력하고 엔터를 누르겠습니다. 놀랍지 않게도 터미널은 제가 요청한 대로 해당 문자열을 반환합니다. Hello world.

좋습니다, 그 다음 위쪽 화살표를 눌러 해당 명령을 가져와서 조금 더 편집하겠습니다. 이번에는 출력을 파일로 리디렉션하겠습니다. 대신 output.txt에 작성하겠습니다. 엔터를 누르면 이번에는 터미널에 아무것도 나타나지 않습니다. 출력이 터미널로 가지 않았기 때문입니다. 파일로 들어갔습니다.

그런 다음 'cat output.txt'를 수행하여 해당 파일을 읽을 수 있습니다. 여기서 탭을 눌러 파일 이름을 자동 확장하면 거기 있습니다. 파일이 있습니다.

VS Code의 사이드바 파일 탐색기에서도 해당 파일을 볼 수 있습니다. 더블 클릭하면 여기에서 열 수 있습니다. 클릭하지 않고 VS Code에서 열고 싶다면 "code" 다음 "output.txt"를 입력하면 동일하게 작동합니다.

좋습니다. 첫 번째 단계입니다. 매우 간단합니다.

## 1. Hello World 워크플로우 시작 스크립트 검토

좋습니다. 이제 정확히 동일한 작업을 수행하겠지만, 터미널에서 직접이 아니라 Nextflow에서 수행하겠습니다.

시작하기 위해 첫 번째 예제 스크립트를 사용하겠습니다. 이 파일은 Hello World라고 합니다. "ls"를 수행하여 터미널에서 볼 수 있으며, 저는 Mac을 사용하고 있으므로 command 클릭으로 해당 파일을 열 수 있습니다. 또는 여기 사이드바에서 더블 클릭할 수도 있습니다.

이 파일에서 몇 가지를 볼 수 있습니다. 맨 위에는 이것이 Nextflow 파일임을 나타내는 해시 문이 있으며, 이것이 실행될 수 있는 방법입니다. 여기에 연한 회색의 일반 코드 주석이 있으며, 실행에 영향을 주지 않고 스크립트를 읽는 데 도움이 됩니다.

그런 다음 두 가지 주요 구조가 있습니다. 여기에 프로세스와 워크플로우가 있습니다.

Nextflow의 프로세스는 파이프라인의 단계입니다. 실제로 로직을 수행하고 처리를 수행하는 부분입니다.

그런 다음 하단의 워크플로우는 이러한 프로세스를 함께 연결하고 워크플로우의 로직, 모든 것이 서로 어떻게 연결되는지를 관리합니다.

프로세스를 먼저 살펴보겠습니다. 잠시 후 워크플로우로 돌아오겠습니다.

## 1.2 프로세스 정의

모든 프로세스는 process 키워드로 시작합니다. 이름이 있고 중괄호가 있으며 중괄호 내의 모든 것이 해당 단일 프로세스입니다.

프로세스는 script 섹션이 있어야 하며, 여기에는 컴퓨팅 환경에서 실제로 실행되는 코드 부분인 다중 행 문자열의 bash 스니펫이 포함되어 있습니다.

여기에는 output 문도 있습니다. 이것은 Nextflow에게 스크립트에 의해 생성될 것으로 예상되는 파일을 알려줍니다. 여기서 output에는 path 키워드가 있으며, 이것은 Nextflow에게 이것이 값이나 문자열이 아니라 파일임을 알려줍니다.

script 블록 내에서 이것은 일반 bash 문일 뿐이며, 터미널에서 작성한 것과 정확히 동일합니다. output.txt라는 파일에 hello world를 에코합니다. 이 output.txt는 output 정의에 의해 선택됩니다. output 정의는 실제로 아무것도 하지 않습니다. 단지 Nextflow에게 무엇을 기대할지 알려주는 것이며, 이 파일이 생성되지 않으면 Nextflow는 오류를 발생시킵니다.

이 예제는 output.txt와 output.txt를 여기에 하드코딩했기 때문에 좋은 예제가 아닙니다. 이 중 하나가 변경되면 워크플로우에서 오류가 발생합니다.

잠시 후 다룰 변수를 사용하는 더 나은 방법이 있습니다.

## 1.3 워크플로우 정의

좋습니다. 워크플로우로 내려가면 주석이 있고 sayHello라는 프로세스를 실행합니다. 이것은 여기 위에 있는 동일한 키워드입니다. 이것은 워크플로우가 될 수 있는 가장 간단한 형태입니다. 변수 입력 없이 단일 프로세스를 호출하는 것이므로 다른 것에 연결하지 않습니다. 이 강의의 후반부에서는 변수 입력을 사용하고 채널과 연결하여 이를 더 강력하게 만드는 방법에 대해 이야기하겠습니다.

## 2. 워크플로우 실행

좋습니다, 이것이 필요한 전부입니다. 실행해보고 무슨 일이 일어나는지 봅시다. 터미널을 지우고 "nextflow run"을 수행하겠습니다. 파일 이름인 hello-world.nf를 호출하겠습니다. 이것이 Nextflow 파이프라인을 실행하는 데 필요한 전부입니다. 이 파이프라인은 입력을 받지 않으므로 다른 인수가 필요하지 않습니다.

엔터를 누르고 무슨 일이 일어나는지 봅시다.

좋습니다. 다음과 같은 출력이 표시되기를 바랍니다. Nextflow가 실행되었고 어떤 버전을 사용하고 있는지 알려주는 몇 가지 정보가 있습니다. 어떤 스크립트가 시작되었는지 알려주고 이 특정 워크플로우 실행에 대해 무작위로 생성된 이름을 제공합니다. 이 경우 제 것은 "gloomy_crick"이라고 불렸습니다.

그러나 이 중 가장 중요한 부분은 파이프라인에서 어떤 단계가 실행되었는지 알려주는 것입니다. sayHello라는 프로세스가 실행되었으며 한 번 실행되었고 백 퍼센트 완료되었음을 볼 수 있습니다.

여기 이 부분은 해당 특정 워크플로우 작업의 해시입니다. 각 프로세스는 한 번 이상 실행되며, 이러한 각 실행을 작업이라고 합니다.

## 2.2. work 디렉토리에서 출력 및 로그 찾기

모든 작업은 실행되는 자체 격리된 디렉토리를 가지므로 워크플로우의 나머지 실행과 분리됩니다. 이 해시는 work 디렉토리 내의 파일 구조에 해당합니다. "tree work"를 수행하면 a0, 그 다음 짧은 해시의 더 긴 버전, 그리고 output.txt 파일을 볼 수 있습니다. 사이드바에서도 볼 수 있습니다.

사이드바에서 여기에 몇 가지 추가 파일이 있음을 볼 수 있습니다. 터미널에 표시되지 않은 이유는 숨김 파일이기 때문이며, 점으로 시작합니다. 실제로 "tree -a"(모두를 의미)와 "work"를 수행하면 여기에서 볼 수 있습니다.

이러한 점 파일은 Nextflow가 생성하는 모든 단일 work 디렉토리에 존재하며, 각각 약간 다른 작업을 수행합니다. 먼저 .command.begin은 실행하기 전에 작업을 설정하는 Nextflow 지침을 포함합니다. .command.run은 Nextflow 자체에 의해 실행되는 실제 지침입니다. 그런 다음 .command.sh는 아마도 가장 흥미로운 것입니다. 이것은 프로세스 블록 script에서 해석된 스크립트입니다.

열어보면 output.txt 파일에 대한 "echo Hello World"가 있음을 볼 수 있습니다. 이 경우 프로세스와 정확히 동일하지만, Nextflow 코드 내에 변수가 있는 경우 모든 작업은 다른 .command.sh를 가지며, 해당 변수가 어떻게 해석되었는지 볼 수 있습니다.

다른 파일들은 작업이 어떻게 실행되었는지와 관련이 있습니다. 따라서 .command.err, .log 및 .out은 표준 오류, 표준 출력 및 두 가지 결합입니다. 그리고 .exitcode는 Nextflow에게 이 작업이 어떤 종료 코드로 실행되었는지, 성공했는지 아닌지 알려줍니다.

마지막으로 output.txt 파일이 있으며 확실히 "Hello World"입니다. 이것은 우리가 기대했던 것이고 생성된 것입니다.

좋습니다. 처음으로 Nextflow를 실행했습니다. 축하합니다. 정말 그렇게 간단합니다.

다음으로, 파이프라인 실행 방식을 변경할 때마다 코드를 편집할 필요가 없도록 좀 더 편리하게 수행하는 방법으로 넘어가겠습니다.

## 3. 워크플로우 실행 관리

이 디렉토리 구조는 모든 작업을 분리하고 모든 것을 정리하는 데 좋지만, 물론 출력 파일을 찾기에는 그다지 편리하지 않습니다. 파이프라인 결과를 찾기 위해 중첩된 많은 디렉토리를 뒤지고 싶지 않을 것입니다.

## 3.1. 출력 게시

좋은 소식은 그럴 필요가 없다는 것입니다. work 디렉토리는 실제로 Nextflow 자체가 사용하기 위한 것입니다. 따라서 우리가 할 일은 publishDir라는 Nextflow 함수를 사용하는 것입니다.

워크플로우로 돌아가서 프로세스로 이동합니다. 여기에 지시문이라는 새로운 문을 추가할 수 있습니다. 이것은 Nextflow가 기능 작동 방식을 증강하는 프로세스 상단의 이러한 것들을 부르는 것이며, 우리가 사용할 것은 publishDir라고 합니다.

여기에서 입력을 시작했으며 VS Code용 Nextflow 확장이 지시문을 제안했음을 볼 수 있으므로 엔터를 누르면 됩니다.

좋습니다. "results"라는 디렉토리를 지정하고 출력 파일을 거기에 복사하도록 지시하겠습니다. 따라서 mode copy라고 하겠습니다. 좋습니다. 저장하고 워크플로우를 다시 실행하겠습니다.

nextflow run hello-world.nf

정확히 동일하게 실행됩니다. 이번에는 해시가 약간 다르지만. Nextflow는 워크플로우를 실행할 때마다 다른 해시를 사용합니다. 그 결과 다른 work 디렉토리 세트가 있습니다. 영역이 대신 EB라고 불리지만, 모든 파일이 동일함을 볼 수 있습니다. 그러나 이번에 새로운 것은 "results"라는 디렉토리도 있다는 것입니다.

여기 "results" 내에 출력 파일이 있습니다. 이것이 Nextflow에게 지시한 것입니다. "results"라는 디렉토리에 결과 파일을 저장하고 거기에 복사하라고 말했습니다. 따라서 이제 찾기가 훨씬 쉽습니다. 워크플로우를 시작한 위치 옆에 있으며 Nextflow가 실제 실행을 실행한 위치나 방법과 관계없이 원하는 대로 다른 파일을 거기에 구성할 수 있습니다.

publishDir는 심볼릭 링크를 처리할 수 있으며, 공유 파일 시스템에서 작업하고 공간을 절약하려는 경우 유용합니다. 또한 프로세스에 의해 생성된 모든 파일을 출력으로 정의할 필요가 없습니다.

Nextflow는 이 output 블록에 정의된 것만 복사합니다. 따라서 이 프로세스의 다운스트림에서 필요하지 않은 단계에서 생성된 중간 파일이 있는 경우 출력에 정의하지 않으면 publishDir에 나타나지 않습니다. 따라서 이것은 파이프라인의 출력 파일을 깨끗하게 유지하고 작업 위치가 완료되면 중간 파일을 쉽게 삭제하는 방법입니다.

간단한 참고사항입니다. workflow output definitions라는 새로운 Nextflow 구문이 나오고 있으며, 이는 결국 publishDir를 대체할 것입니다. 이것은 workflow 블록의 파이프라인 수준에서 워크플로우의 모든 출력을 정의하는 방법을 제공합니다. 시도해보고 싶다면 Nextflow 문서에 설명되어 있습니다. 그러나 지금은 publishDir가 한동안 있을 것이므로 2025년 교육에 여전히 포함되어 있습니다.

## 3.2. -resume으로 워크플로우 재시작

좋습니다. 여기 work 디렉토리에는 이제 워크플로우를 실행할 때마다 다른 해시의 두 세트 결과가 있다고 언급했습니다. 좋습니다. 그러나 때로는 필요하지 않은 경우 매번 단계를 다시 계산하고 싶지 않습니다.

워크플로우를 반복적으로 구축하고 단계를 추가하고 있으며 첫 번째 단계가 캐시된 버전을 재사용하기를 원할 수 있습니다. 또는 워크플로우 중간에 컴퓨팅 시스템에 문제가 발생하여 중단된 위치에서 계속하되 이미 완료한 단계는 건너뛰기를 원할 수 있습니다.

Nextflow에는 resume이라는 이를 위한 내장 기능이 있습니다. 시도해봅시다. 먼저 work 디렉토리를 살펴보겠습니다. 그래서 거기에 무엇이 있었는지 기억할 수 있습니다.

그런 다음 "nextflow run hello-world.nf"를 수행하고 여기에 단일 명령 "-resume"을 추가하겠습니다.

단일 대시에 주목하십시오. 정말 중요합니다. 실행하면 출력이 몇 가지 작은 차이점을 제외하고는 기본적으로 정확히 동일하게 보일 것입니다.

여기 회색으로 "cached"라고 표시되어 있습니다. 이것은 Nextflow가 이번에 작업을 실행하지 않았음을 의미합니다. 요구 사항과 일치하는 것을 찾았고 단계를 다시 실행하는 대신 해당 출력을 직접 재사용했습니다.

확실히 여기 해시를 보면 이전 실행에서 가졌던 기존 해시에 해당함을 볼 수 있습니다.

## 3.3. 이전 work 디렉토리 삭제

좋습니다. 그러나 반복적으로 개발하는 경우 이러한 워크플로우 파일이 많이 쌓일 것입니다. 공간이 부족한 경우 문제가 될 수 있습니다.

Nextflow는 몇 가지 도우미 명령으로 이러한 work 디렉토리를 정리하는 데 도움을 줄 수 있습니다. "nextflow log"를 수행하면 이 디렉토리에서 수행한 모든 다른 워크플로우 실행 목록이 제공되며, 여기에 실행 이름이 있습니다. 처음 실행한 gloomy quick 하나와 이 두 개의 새로운 것을 볼 수 있습니다.

이제 해당 이름을 가져와서 "nextflow clean" 명령과 함께 사용할 수 있습니다. 단일 실행 이름을 지정할 수 있습니다. 또는 더 나은 방법은 "-before"로 단일 워크플로우 이름 이전의 모든 것을 삭제하도록 Nextflow에 지시할 수 있으며, "stupefied_shaw"를 입력하겠습니다. 그것이 가장 최근 실행이었습니다. "-n".

"-n" 명령은 Nextflow에게 실제로 아무것도 삭제하지 않고 드라이 런으로 수행하도록 지시했으며, 제거되었을 해시 디렉토리를 알려줍니다. 확실히 첫 번째 실행에서 그 하나만 있습니다. 두 번째 실행 모두 동일한 해시 디렉토리를 사용합니다.

다시 실행하겠지만 이번에는 드라이 런을 위한 "-n" 대신 force를 위한 "-f"를 수행하겠습니다. 그러면 해당 해시 디렉토리가 제거되었습니다. 이제 "tree work"를 수행하면 이 출력 파일만 남아 있음을 볼 수 있습니다.

좋습니다. 그래서 거기서 많은 디스크 공간을 정리할 수 있었습니다.

work 디렉토리를 삭제할 때 주의해야 할 몇 가지 사항이 있습니다. results 디렉토리에 심볼릭 링크한 경우 해당 심볼릭 링크 소스가 이제 삭제되고 결과가 영원히 사라집니다. 그래서 copy 모드를 사용하는 것이 더 안전한 일이며 일반적으로 권장하는 것입니다.

둘째, Nextflow의 resume 기능은 이러한 work 디렉토리에 의존합니다. 따라서 삭제하고 Nextflow를 다시 실행하면 resume 기능이 더 이상 작동하지 않습니다. 따라서 필요할 수도 있고 필요하지 않을 수도 있는 것을 추적하고 안전하다고 확신할 때만 삭제하는 것은 사용자의 몫입니다.

우리가 할 수 있는 다른 방법은 워크플로우 실행을 완료하고 더 이상 필요하지 않다고 확신하는 경우 전체 work 디렉토리를 삭제하는 것입니다.

따라서 "rm -r work"를 수행할 수 있습니다. 거기에 중요한 것이 없다는 것을 알고 있습니다. 우리가 복사한 results 디렉토리에 우리가 관심 있는 결과가 있습니다. 따라서 work 디렉토리를 삭제하는 것이 안전했습니다. 어떤 접근 방식을 사용할지는 사용자에게 달려 있습니다.

## 4. 명령줄에서 전달된 변수 입력 사용

좋습니다, 다음은 무엇입니까? 여기 워크플로우 스크립트에 output.txt 파일의 일부 값을 하드코딩했으며, 더 나은 방법이 있을 수 있다고 언급했습니다.

이것을 시작하겠습니다. 세 가지 작업을 수행할 것입니다. 프로세스에 새 입력을 추가하고, 프로세스 스크립트에 해당 입력을 사용하는 방법을 알려주고, Nextflow를 실행할 때 명령줄 플래그로 동적으로 사용할 수 있도록 워크플로우에 연결하겠습니다.

먼저 할 일. 여기에 input 블록을 추가하겠습니다. output과 마찬가지로 이것은 프로세스의 새 섹션이며, "val greeting"이라고 하겠습니다.

여기서 "val"이라고 하는 것에 주목하십시오. 이것은 path가 아니라 변수임을 나타냅니다.

그런 다음 스크립트로 내려가서 여기 하드코딩된 텍스트를 제거하고 $greeting을 수행할 수 있습니다. 이것은 다른 프로그래밍 언어와 마찬가지로 작동합니다. 여기에서 변수를 정의하고 이 script 블록 내에서 참조합니다. Nextflow가 이 프로세스를 실행하면 변수가 보간됩니다. 그리고 .command.sh 파일을 보러 가면 대신 실제 하드코딩된 문자열을 여기에서 볼 수 있습니다.

## 4.1.3. CLI 매개변수 설정 및 프로세스 호출에 입력으로 제공

좋습니다, 그러나 변수를 어디에 제공합니까? 다음으로 workflow 섹션으로 이동하면, 여기 확장이 이제 입력을 기대한다고 말하고 있으며 경고를 주었습니다.

이제 가장 간단하게 할 수 있는 것은 하드코딩하는 것입니다. "Hello World"를 작성하고 해당 문자열 입력을 프로세스에 제공할 수 있습니다. 그러나 다시 말하지만 그것은 실제로 어떤 문제도 해결하지 못할 것입니다. 무언가를 변경하고 싶을 때마다 파이프라인 코드를 편집해야 하므로 좋지 않습니다.

좋은 소식은 Nextflow에 매개변수라는 명령줄 인수를 처리하는 내장 시스템이 있다는 것입니다. 따라서 대신 params라는 특수 변수 중 하나를 사용할 수 있으며 원하는 대로 호출할 수 있지만 워크플로우 로직과 일치하도록 greeting이라고 하겠습니다.

저장하고 이것으로 무엇을 할 수 있는지 봅시다.

터미널로 돌아가면 "nextflow run hello-world.nf"를 수행합니다. 이전과 마찬가지지만 주요 차이점은 --greeting을 수행한다는 것입니다.

여기에 두 개의 대시가 있다는 점에 주목하십시오. 이것은 매개변수이기 때문입니다. 이전에 워크플로우를 재개했을 때 단일 대시였습니다. 그것은 resume이 핵심 Nextflow 옵션이고 이것은 파이프라인에 특정한 매개변수이기 때문입니다.

두 가지를 혼동하지 마십시오. 그렇게 하기 쉽습니다. 단일 대시 대신 --resume을 수행했다면 "params.resume"이 되어 아무것도 하지 않을 것입니다. 마찬가지로 여기에서 단일 대시를 수행했다면 Nextflow는 이것을 주요 인수로 인식하지 못할 것입니다.

따라서 params.greeting에 해당하는 --greeting입니다.

이제 원하는 텍스트를 뒤따를 수 있습니다. 현재 스웨덴에 있으므로 "Hej världen"이라고 하겠습니다.

실행해서 무슨 일이 일어나는지 봅시다. 진실의 순간입니다.

좋습니다. 이전과 마찬가지로 프로세스가 단일 실행으로 sayHello가 실행되었음을 볼 수 있습니다.

이것은 publishDir "results" 디렉토리에 있던 파일을 덮어썼을 것입니다. 따라서 파일을 다시 실행할 때 주의하십시오. 게시 영역의 것들이 덮어쓰여질 것이기 때문입니다.

이제 "code results/output.txt"를 수행할 수 있으며, 확실히 출력이 업데이트되어 이제 "Hej världen"이라고 표시됩니다.

## 4.2. 명령줄 매개변수에 기본값 사용

좋습니다, 훌륭합니다. 그러나 이제 문제는 워크플로우가 항상 이 매개변수를 정의하는 것에 의존한다는 것이며, 기본값을 재정의하지 않는 한 워크플로우에 대해 합리적인 방식으로 실행되도록 합리적인 기본값을 갖는 것이 좋습니다.

따라서 우리가 하는 방법은 워크플로우 스크립트에서 매개변수에 대한 기본값을 설정하는 것입니다.

hello-world.nf 파일로 돌아가서 workflow 바로 위의 스크립트로 이동하여 "params.greeting"을 입력하고 다른 변수처럼 정의할 수 있습니다. 여기에 문자열을 넣고 "Holà mundo!"라고 하겠습니다.

이제 이 매개변수에는 여기서 사용될 기본값이 정의되어 있거나 이전과 마찬가지로 --greeting으로 명령줄에서 여전히 재정의할 수 있습니다.

작동하는지 확인해 봅시다. "nextflow run hello-world.nf"

이번에는 명령줄 인수가 없으며 올바른 작업을 수행했는지 확인합니다.

"code results/output.txt". 거기 있습니다. 기본값을 얻었습니다.

좋습니다. 다시 시도해 봅시다. 거짓말을 하고 있지 않은지 확인하십시오. 다시 실행하되 --greeting을 수행하고 교육 자료의 예제를 사용하여 "Konnichiwa!"라고 하겠습니다.

워크플로우를 다시 실행하면 확실히 상단의 출력 파일이 명령줄에서 제공한 새 값으로 업데이트되었습니다.

좋습니다. 이것은 Nextflow 워크플로우를 작성하는 데 있어 정말 중심적인 측면입니다. 파이프라인 코드에서 합리적인 기본값을 정의하되, 터미널에 명령줄 인수를 사용하여 최종 사용자가 구성하기 매우 쉽게 만듭니다.

최종 사용자는 여러 다른 위치에서 config를 덮어쓸 수 있습니다. 수행하는 모든 단일 Nextflow 실행에 적용되는 홈 디렉토리에 config 파일이 있을 수 있습니다. 시작 디렉토리에 config 파일이 있을 수 있습니다. 파이프라인 디렉토리에 config 파일이 있을 수 있습니다. 이러한 모든 다른 config 위치는 Nextflow 문서에 설명된 특정 순서로 로드됩니다.

좋습니다, 섹션 1의 끝입니다. 프로세스와 워크플로우를 포함한 Nextflow의 첫 번째 워크플로우 스크립트를 가졌습니다. 입력, 출력, 스크립트 및 게시, 그리고 매개변수와 입력 채널을 프로세스에 연결하는 방법을 살펴보았습니다.

축하합니다. Nextflow 코드 작성을 위한 첫 번째 단계가 완료되었습니다.

잠시 쉬고 몇 분 후 2장에서 뵙겠습니다.

[다음 비디오 대본 :octicons-arrow-right-24:](02_hello_channels.md)
