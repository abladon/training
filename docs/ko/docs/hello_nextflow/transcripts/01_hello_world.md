# 파트 1: Hello World - 비디오 대본

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보고 개선 사항 제안하기](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/tOukLxWCHiA?si=F0t9LFYLjAWoyRXj&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 참고사항"

    이 페이지는 대본만 보여줍니다. 전체 단계별 지침은 [교육 자료](../01_hello_world.md)로 돌아가세요.

    대본에 표시된 섹션 번호는 참고용으로만 제공되며, 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영합니다

안녕하세요, 다시 오신 것을 환영합니다.

지금 여러분은 "Hello Nextflow" 과정의 파트 1인 "Hello World"에 있습니다. 이 챕터에서는 Nextflow의 가장 기본적인 내용에 대한 이해를 쌓기 시작할 것입니다.

이제 여러분은 Codespaces나 이에 준하는 환경에서 VS Code가 실행되도록 설정되어 있고, 작업 공간의 탐색기에 Hello Nextflow 폴더와 여기 있는 모든 다양한 파일들을 갖추고 있을 것입니다.

먼저 터미널에서 Bash를 사용하여 매우 기본적인 작업을 수행한 다음, Nextflow 내에서 동일한 작업을 수행할 수 있는지 확인하여 구문이 어떻게 생겼는지 감을 잡을 것입니다.

## 0. 준비 운동

정말 간단하게 시작해 봅시다. "echo"로 시작하여 터미널에 무언가를 출력해 봅시다. "Hello World". Enter를 누르면 터미널에 출력됩니다. Hello World. 이 과정을 보는 분들에게는 놀라운 일이 아니기를 바랍니다.

좋습니다, 이것으로 무언가를 해봅시다. 터미널에 출력하는 대신 파일에 써봅시다. 키보드의 위쪽 화살표를 눌러서 Bash 히스토리를 순환하면 마지막 명령이 나오는데, 그 끝에 작은 큰따옴표 기호를 추가하겠습니다. 이것은 이 명령의 출력을 파일로 리다이렉션하며, output.txt라고 부르겠습니다.

다시 Enter를 눌러서 명령을 실행하면, 이번에는 터미널에 아무것도 나오지 않지만, 왼쪽에 output.txt라는 새 파일이 나타난 것을 볼 수 있습니다.

cat과 같은 명령으로 터미널에서 볼 수 있습니다. cat output.txt를 실행하면 확실히 "Hello World"라고 나옵니다. 더블 클릭하면 VS Code의 코드 편집기에서 열립니다.

## 1.1. 코드 살펴보기

좋습니다. 간단하다고 말씀드렸죠. 다음은 무엇일까요? 이 프로세스를 다시 시도해 보되, 이번에는 Nextflow 내에서 해봅시다.

말씀드린 것처럼, 이 과정의 모든 챕터는 스크립트로 시작하며 이것은 Hello World라고 합니다. Hello World를 찾아보겠습니다. 한 번 클릭하면 미리보기가 나오고, 더블 클릭하면 여기 편집기에서 열립니다. 그리고 터미널을 빠르게 없애겠습니다.

이것은 매우 간단한 스크립트이므로, 가능한 한 간단합니다. 길이가 22줄에 불과하며 기본적으로 같은 작업을 수행합니다. 사실 이 중 일부는 친숙해 보일 것입니다. 방금 입력한 bash 명령이 파일로 리다이렉션되는 것을 볼 수 있습니다.

좋습니다. 다른 것은요? 또한 이 파일에서 Nextflow의 핵심 개념 중 일부를 보기 시작할 수 있습니다. 여기 빨간색으로 표시된 process와 workflow가 있습니다. 이것들은 Nextflow의 특수 키워드이자 특수 용어입니다.

## 1.1.1. 프로세스 정의

워크플로우 내의 다양한 프로세스는 워크플로우의 서로 다른 논리적 단위를 감쌉니다. 각 프로세스는 한 가지 작업을 수행합니다.

실행하면 작업(task) 또는 여러 작업을 생성하는데, 이것들은 파이프라인의 실제 실행 단계입니다. 모든 프로세스는 아래에 보이는 workflow 블록 내에서 조율되며, 이 경우에는 그 하나의 프로세스만 실행합니다.

프로세스 이름은 이 키워드 뒤에 오며, 기본적으로 무엇이든 될 수 있습니다. 그런 다음 프로세스의 내용은 이 중괄호 안에 있습니다.

프로세스에 대한 실제로 하나의 요구사항만 있는데, 어떤 종류의 script 또는 exec 블록을 포함해야 한다는 것입니다. 이것은 여기 삼중 따옴표 안에 있으며, 파이프라인을 실행할 때 작업 디렉토리에 작성되는 bash 스크립트이고, 실제로 컴퓨터나 서버에서 실행되는 것입니다.

일반적으로 bash이지만, 맨 위에 다른 shebang을 넣을 수도 있으며, Python 스크립트나 R 스크립트가 될 수도 있습니다. 상관없습니다. 이 스크립트에 있는 것은 무엇이든 실행됩니다.

여기 이 프로세스에 추가한 것이 하나 더 있는데, output 선언입니다. 이것은 Nextflow에게 이 프로세스가 output.txt라는 출력 파일을 예상한다고 알려줍니다. path라고 되어 있으므로 파일처럼 처리해야 하며, val이라고 하면 변수나 값처럼 처리해야 합니다.

이것이 이 파일을 생성하는 것은 아닙니다. 실제로 생성하지 않습니다. 그것은 여기 아래 스크립트에서 수행됩니다. Nextflow에게 이 파일 이름으로 출력 파일을 예상하라고 알려주는 것일 뿐입니다.

## 1.1.2. 워크플로우 정의

좋습니다. 그리고 아래에 여기 workflow가 있고, 다시 선언이 있습니다. 이것은 Main이라고 합니다. 이것은 원하신다면 script 블록의 워크플로우 등가물입니다. 무언가를 수행하는 워크플로우의 부분입니다. 이 경우에 우리는 sayHello라는 프로세스를 호출한다고 말하고 있습니다.

물론 일반적으로 파이프라인은 이것보다 훨씬 더 복잡해 보일 것입니다. 아마도 하나 이상의 프로세스가 있을 것이고, 채널을 사용하여 그들 사이의 데이터 흐름을 조율할 것입니다. 이 과정의 다음 파트에서 다룰 예정이지만, 지금으로서는 이것으로 충분합니다. 이것은 작동해야 하는 유효한 파이프라인입니다.

VS Code에서 여기 "preview DAG"를 클릭할 수도 있습니다. DAG는 파이프라인의 데이터 흐름 구조를 나타내며, 옆에 mermaid 다이어그램으로 렌더링되는 것을 볼 수 있습니다. 이 경우 매우 간단합니다. 워크플로우인 하나의 상자와 sayHello라는 하나의 프로세스가 있지만, 진행하면서 더 흥미로워질 수 있습니다.

## 1.2. 워크플로우 실행하기

좋습니다, 이 워크플로우를 실행해서 어떻게 되는지 봅시다.

아래에 터미널을 다시 불러오고 출력을 지우고 Nextflow Run을 입력하겠습니다. 그런 다음 스크립트 이름인 hello-world.nf를 입력하겠습니다. 그리고 Enter를 누르겠습니다.

좋습니다, 상단에 표준 내용이 있는데, Nextflow가 실행되었고 어떤 버전이 실행되었는지, 스크립트 이름과 모든 것이 무엇이었는지 알려줍니다.

그리고 실제로 우리가 찾고 있는 중요한 것은 _여기_인데, 실행된 다양한 작업의 요약입니다.

여러분의 것이 작은 녹색 체크 표시와 함께 이렇게 보인다면, 잘하셨습니다. 방금 첫 번째 파이프라인을 실행하셨습니다. 훌륭합니다.

여기서 실행된 프로세스의 이름이 Say Hello라고 알려주고, 한 번 실행되었고 성공했다고 알려줍니다. 이것은 진행하면서 업데이트되므로 더 큰 파이프라인을 실행할 때 여기에 진행 상황이 표시됩니다. 하지만 이것은 너무 작아서 기본적으로 즉시 실행됩니다.

## 1.2.2. work 디렉토리에서 출력과 로그 찾기

이제 Nextflow 파이프라인을 실행하면 각 프로세스가 함께 연결되고, 각 프로세스는 앞서 말한 것처럼 작업을 하나 또는 여러 개 생성할 수 있습니다. 이 경우 이 프로세스에서 단일 작업이 있었습니다. 한 번만 실행되었고 이 작업 _해시_ 아래에서 수행되었습니다.

Nextflow는 작업 디렉토리의 파일을 직접 다루지 않고, work라는 특수 폴더를 생성합니다. "ls"를 실행하면 여기에 나타난 것을 볼 수 있습니다: _work_, 그리고 여기 안에는 실행되는 모든 단일 작업에 대한 하위 디렉토리가 있습니다. 그리고 이것은 이 해시와 일치합니다. "ls work/c4"를 실행하면, 그 다음 잘렸지만 203으로 시작하는데, 이것이 파이프라인을 실행할 때 이 프로세스에 의해 생성된 작업 디렉토리입니다. 측면에서도 볼 수 있습니다.

그 파일들을 나열하면 output.txt 파일이 생성된 것을 볼 수 있습니다. 여기서도 볼 수 있습니다. 그리고 일반 "ls"로는 표시되지 않는 숨겨진 파일들이 많이 있습니다.

output.txt를 클릭하면 확실히 출력이 있습니다. 훌륭합니다. 파이프라인이 작동했습니다.

본질적으로 한 줄의 bash 스크립트를 실행하는 것치고는 상당히 많은 보일러플레이트처럼 보일 수 있지만, 프로세스가 더 복잡해지면 더 이해가 될 것입니다. 그리고 Nextflow를 사용한 이 work 디렉토리와 생성되는 이 파일들이 Nextflow를 매우 강력하게 만드는 진정한 근간입니다.

각 작업, 파이프라인의 각 요소는 다른 모든 작업으로부터 격리됩니다. 재현 가능합니다. 서로 충돌하지 않으며 모든 것이 병렬로 실행될 수 있습니다. 실제로 이 격리 때문에 익숙해지면 정말 좋은 방식인데, 단일 작업에 대해 정확히 무슨 일이 일어났는지 들어가서 볼 수 있고 디버그할 수 있습니다.

work 디렉토리의 다른 파일들을 빠르게 살펴봅시다. 위에서 아래로, _.command.begin_이라는 파일이 있습니다. 이것은 비어 있습니다. Nextflow가 "작업을 시작하겠습니다"라고 말하며 생성한 센티널 파일일 뿐입니다. 거기에 흥미로운 것은 없습니다.

그런 다음 _.command.error_, _.command.log_ 및 _.command.out_이 있습니다. 이것들은 모두 실행된 bash 명령 또는 이 스크립트의 출력입니다. 이것은 표준 에러입니다. 이것은 표준 출력이고, 이것은 나온 대로 두 개를 결합한 것입니다. 따라서 논리적 순서를 얻습니다.

좋습니다, 이것들도 모두 비어 있어서 별로 흥미롭지 않지만, _.command.run_에 도착하면 더 흥미로워집니다.

일반적으로 매우 긴 스크립트입니다. 그리고 이것이 Nextflow가 실제로 실행하는 것입니다. 여기에 들어가면 Nextflow의 모든 내부 로직을 보기 시작하고 무엇을 하고 있는지, 프로세스를 어떻게 실행하는지 볼 수 있습니다. 이것은 어디에서 실행하고 있는지, 로컬에서 실행하는지 또는 SLURM에 작업으로 제출하는지에 따라 달라지며, 그 경우 상단에 SLURM 헤더가 있을 것입니다. 이 모든 다양한 설정들.

일반적으로 이 파일을 실제로 볼 필요는 없습니다. Nextflow에 의해 자동 생성되며 파이프라인에 고유한 특별한 것은 없습니다. 하지만 이것이 실제로 실행되는 핵심입니다.

다음 것은 훨씬 더 흥미롭습니다. _.command.sh_는 프로세스에서 나온 생성된 스크립트이며, 여기서 Nextflow가 Bash 헤더를 추가한 다음 스크립트 블록에 있던 명령을 실행한 것을 볼 수 있습니다.

그리고 _.command.run_ 파일이 하는 일은 이 _.command.sh_ 파일을 실행하는 것뿐입니다.

이것은 정말 유용한 파일인데, 무언가를 디버그하고 Nextflow 파이프라인의 로직이 예상대로 수행되는지 확인하려고 할 때 보통 가장 많이 보게 되는 파일입니다.

마지막으로 _.exitcode_라는 파일이 있는데, 이것은 작업의 종료 코드를 캡처하는 것으로, 이 경우 성공했으므로 종료 코드가 0이었습니다.

메모리가 부족하거나 다른 문제가 발생하여 실패하면 무엇이 잘못되었는지 이해하는 데 매우 유용합니다.

## 1.3. 워크플로우 다시 실행하기

work 디렉토리에 대해 이해해야 할 한 가지가 더 있는데, 이 파이프라인을 반복적으로 계속 실행하면, _"nextflow run hello-world.nf"_를 실행하면 정확히 같은 작업을 수행하지만, 이번에는 새로운 작업 ID를 갖게 됩니다. 여기 이 해시가 다른 것을 볼 수 있고, 이제 work를 보면 두 개의 해시 디렉토리가 있습니다. 그리고 이것들은 다시 서로 분리되어 있습니다.

따라서 Nextflow 워크플로우를 실행할 때마다, 캐시를 사용하는 resume을 사용하지 않는 한, 나중에 다루겠지만, 서로 분리된 새로운 work 디렉토리에서 해당 프로세스를 다시 실행할 것입니다. 파일 이름 충돌이 발생하지 않으며, 그런 문제가 없을 것입니다. 모든 것이 격리되고 깨끗합니다.

이 디렉토리에 들어가면 동일한 모든 파일과 처음부터 재생성된 동일한 _output.txt_를 볼 수 있습니다.

## 2. 출력 퍼블리시하기

좋습니다, 파이프라인을 실행하는 동안 모든 것이 서로 분리되고 깨끗하며 관리될 수 있도록 Nextflow 자체에는 훌륭합니다.

하지만 결과를 탐색하려는 사람에게는 그다지 유용하지 않습니다. 결과 파일을 찾으려고 수천 개의 다른 work 디렉토리를 파헤치고 싶지는 않을 것입니다. 그리고 실제로 그렇게 하도록 의도되지 않았습니다. work 디렉토리는 파일이 생성되는 최종 상태가 되도록 의도되지 않았습니다.

우리는 파일을 퍼블리시하여 이를 수행합니다.

## 2.1.1. sayHello 프로세스의 출력 선언하기

스크립트로 돌아가면, 여기 workflow 블록에서 작업하겠습니다. 예상되는 파일, 우리가 관심 있는 파일이 무엇인지 알려주고, 그런 다음 output 블록이라는 아래에 새로운 블록을 생성할 것입니다.

이것은 Nextflow 버전 26.04에서 구문 분석기와 함께 제공되고 기본값이 된 새로운 구문입니다. 따라서 Nextflow를 조금 사용해 본 적이 있다면, 이것이 새로운 것 중 하나입니다.

main 블록이 있고, 다음으로 publish라고 말하고 퍼블리싱에서 무엇을 기대하는지 Nextflow에 알려줄 것입니다. _first_output_이라고 부르고, _sayHello.out_이라고 부르겠습니다.

거기서 실수로 오타를 냈지만, 이것은 Nextflow VS Code 확장의 일부 기능을 지적할 좋은 기회이기도 합니다. 즉시 이 아래에 작은 빨간색 물결선이 나타나 무언가 잘못되었다고 말합니다. 그리고 마우스를 올리면 이 변수가 정의되지 않았다고 알려줍니다. 무엇인지 모릅니다.

이 경우 매우 명백합니다, 오타를 냈습니다. sayHello를 입력하려고 했는데, 그러면 물결선이 사라집니다.

이제 보라색입니다. Nextflow 구문 분석기는 이것이 프로세스라는 것을 알고 있으며 마우스를 올리면 이 프로세스가 어떻게 보이는지 축소된 표현을 제공합니다. 따라서 입력을 받지 않고 이 출력을 제공한다는 것을 한눈에 매우 빠르게 볼 수 있습니다. 따라서 이 확장을 사용하여 VS Code에서 작업하면 코드를 작성할 때 많은 컨텍스트 정보를 얻을 수 있습니다.

_.out_ 구문으로 이 프로세스의 출력을 참조할 수 있다는 점에 유의하세요. 그리고 현재로서는 이것을 원하는 대로 호출할 수 있으며, 임의의 변수 이름일 뿐입니다.

## 2.1.2. 스크립트에 output: 블록 추가하기

그것이 중요해지는 것은 여기서 새로운 블록을 수행할 때이며, 이것은 이제 workflow 블록 아래에 있습니다. 더 이상 workflow 안에 있지 않습니다. 다시 중괄호입니다. 그리고 여기서 워크플로우에 의해 생성된 모든 파일을 어디에 놓을지 Nextflow에 알려줍니다.

이제 여기서 생성한 이 변수 이름을 가져와서 거기에 넣고 이것에 대한 중괄호를 넣겠습니다. 그리고 Nextflow에게 path를 사용하라고 알려줄 것입니다. 이런. Path, 따옴표 안에. 그리고 점을 사용하겠습니다. 이것은 Nextflow에게 results 디렉토리의 루트에 파일을 넣으라고 말합니다. 하위 디렉토리나 그런 것은 없습니다.

워크플로우를 다시 실행해 봅시다. _"nextflow run hello-world.nf"_를 실행하면 기본적으로 정확히 동일하게 보일 것입니다. Nextflow와 관련하여 실제로 변경된 것은 없습니다. 같은 작업을 수행하고 있습니다. work 디렉토리에서 다시 수행하고 있을 뿐입니다.

하지만 이제 _"ls results/"_를 실행하면 results라는 새 디렉토리가 생성된 것을 볼 수 있는데, 이것은 워크플로우 퍼블리싱의 기본 기본 디렉토리입니다. 그리고 거기에 _output.txt_라는 파일이 있습니다.

_"ls -l results"_를 실행하면 이것이 실제로 work 디렉토리에 소프트 링크되어 있음을 알 수 있습니다. 따라서 이것은 실제 파일이 아니며 work 디렉토리에 링크되어 있으며 거기에서 모든 파일을 수집했습니다.

## 2.2. 사용자 정의 위치 설정하기

"Results"는 이 경로의 기본 이름입니다. 워크플로우를 다시 실행하고, 이번에는 _단일_ 하이픈으로 _"-"_를 수행합니다. 이것은 핵심 Nextflow 옵션이기 때문입니다. _"-output-dir **my**results"_. 줄여서 _"-o"_라고도 할 수 있습니다. 그러면 파일이 저장되는 위치에 대한 다른 기본 디렉토리가 설정되고, 다시 한 번 여기 _myresults/_ 위에 _output.txt_가 있습니다.

좋습니다만, 모든 파일을 루트에만 두고 싶지는 않을 것입니다. 약간의 구조가 필요하므로 여기에 원하는 대로 호출할 수 있는 하위 디렉토리를 만들 수도 있습니다. _"path 'hello_world'"_라고 말하고, 이것을 다시 실행하겠습니다. _"nextflow run hello-world.nf"_. results 디렉토리의 하위 디렉토리로 들어가야 하고, 확실히 이제 상단의 results 아래에 _hello_world/_가 있고 _output.txt_가 있습니다.

주의해야 할 중요한 점은 기존 _output.txt_ 파일이 여전히 있다는 것입니다. 이렇게 할 때 results 디렉토리가 지워지지 않습니다. 새 파일만 거기에 복사됩니다. 동일한 파일 이름을 가진 파일이 이미 있으면 덮어쓰지만, 기존 파일을 지우지는 않습니다. 따라서 파이프라인을 다시 실행할 때 약간 주의해야 합니다. 이미 있는 파일 위에 놓이기를 원하지 않는다면. 빈 디렉토리를 사용해야 합니다.

## 2.3. 퍼블리시 모드를 copy로 설정하기

좋습니다, 이 파일들이 소프트 링크라고 언급했으므로, _"ls -l results/hello_world/"_를 실행하면 work 디렉토리에 소프트 링크되어 있는 것을 볼 수 있습니다. 일반적으로 HPC 같은 곳에서 작업하고 있고 이것들이 정말 거대한 파일이며 중복하고 싶지 않다면 좋은 일입니다. 파일이 파일 시스템에 한 번만 저장되기 때문입니다.

그러나 work 디렉토리를 삭제하면: _"rm -r work"_를 실행하고 생성된 모든 중간 파일을 지우면. 이제 이 파일 _"results/hello_world/"_를 읽으려고 하면. 더 이상 존재하지 않는 파일에 대한 소프트 링크로 가리키고 있고 데이터가 영원히 사라져 복구할 수 없는데, 이는 그다지 좋지 않을 수 있습니다.

따라서 일반적으로 가능하면 소프트 링크 대신 파일을 복사하는 것이 좋은 관행이라고 말하는데, 더 안전하기 때문입니다. 그러한 work 디렉토리를 삭제하지 않는 한 디스크 공간을 두 배로 사용한다는 점만 알아두세요.

output 블록으로 그렇게 하려면 여기 first output으로 가겠습니다. 전에 path를 설정했고 이제 mode를 설정하겠습니다. 입력하면 VS code 확장이 제안하고 있는 것을 볼 수 있습니다. 여기가 output 지시문이라는 것을 알고 있습니다. 그리고 copy라고 말하겠습니다. 저장을 누릅니다.

워크플로우를 다시 실행해 봅시다. 파일을 다시 생성하고, 새로운 work 디렉토리가 생성됩니다.

이제 _"ls -l results/hello_world/"_로 가면 이것이 실제 파일이고 더 이상 소프트 링크가 아니며, Nextflow가 그것을 복사한 것을 볼 수 있습니다. 알아두면 좋습니다. 따라서 path와 mode는 꽤 자주 작성하게 될 것입니다.

물론 이것은 매우 간단합니다. 진행하면서 이것을 더 복잡하고 강력하게 만들 것이며, 이것들을 동적으로 만들고 너무 장황하지 않게 만드는 방법을 볼 수 있을 것입니다.

## 2.4. 프로세스 수준 publishDir 지시문에 대한 참고사항

이제 이것을 시작할 때 말한 것처럼, 이것은 상당히 새로운 형태의 구문입니다. 제가 녹화하는 시점에서 최신 버전의 Nextflow에서만 사용할 수 있으며, Workflow Outputs라고 합니다.

이것을 사용하면 훌륭합니다. Nextflow 내에서 Nextflow Lineage와 같은 다른 많은 멋진 기능을 잠금 해제하여 파일이 생성될 때 그 계보를 추적하는 데 도움이 되며, 곧 26.04에서 기본값이 될 것입니다. 그리고 나중에 미래의 어느 시점에 이것이 워크플로우를 작성하는 유일한 방법이 될 것입니다.

그러나 지금 이 전환 단계에 있는 동안, publishDir이라는 것을 사용하는 실제 파이프라인을 볼 수 있으며, 이것이 그것을 수행하는 오래된 방법이고, 이것은 워크플로우 및 output 수준이 아니라 프로세스 수준에서 정의됩니다.

그리고 이 선언은 기본적으로 같은 것을 말합니다. results라는 디렉토리에 결과 파일을 퍼블리시하고 copy 모드를 사용한다고 말합니다. 따라서 구문이 매우 유사한 것을 볼 수 있습니다. 하지만 지금 새로운 파이프라인을 작성할 때는, AI 결과나 문서 또는 다른 파이프라인에서 보더라도 이 publishDir 지시문을 사용하지 마세요. 그것이 오래된 방법이기 때문입니다.

2026년에는 모두 workflow outputs를 사용해야 합니다.

이것은 모두 문서화되어 있으며, 이것을 수행하고 이전에 Nextflow를 사용한 적이 있다면, 여기 Nextflow 문서 nextflow.io/docs/로 갈 수 있습니다. 튜토리얼로 스크롤하면 _Migrating to Workflow Outputs_라는 튜토리얼이 있습니다.

정말 좋습니다. 모든 구문, 이전 구문과 어떻게 동등한지, 왜 변경했는지를 다루고 타임라인 등이 모두 있습니다. 그리고 많은 예제와 함께 다양한 시나리오를 모두 다룹니다. 따라서 기존 Nextflow 코드를 새 구문으로 쉽게 변환할 수 있습니다.

## 3.1. sayHello 프로세스를 변수 입력을 받도록 변경하기

좋습니다, 프로세스를 실행하고 파일을 생성하고 Nextflow에게 출력이라고 알려주고, Nextflow에게 그 파일을 어디에 저장할지 알려주는 간단한 스크립트가 있습니다. 좋은 시작입니다.

하지만 모두 하드코딩되지 않으면 더 흥미로울 것입니다. 다음으로 이 프로세스가 변수 입력을 받을 수 있다고 Nextflow에 알려주는 방법에 대해 생각해 봅시다. 이것은 워크플로우를 시작할 때 런타임에 제어할 수 있는 것입니다.

이것을 실현하려면 몇 가지 다른 작업을 수행해야 합니다.

첫째, 이 프로세스가 입력 변수를 받을 수 있다고 알려주어야 하며 여기에 _input_을 새로운 선언 블록으로 입력합니다. 그리고 _"val greeting"_이라고 부르겠습니다.

val 비트는 아래의 path와 동등합니다. Nextflow에게 이것이 이 경우 문자열과 같은 변수라고 알려줍니다. 그리고 마우스를 올리면 확장에서 이것이 무엇을 의미하는지 알려줍니다.

다음으로 Nextflow에게 이것으로 무엇을 할지 알려줄 것입니다. 변수가 있다고 말하는 것만으로는 충분하지 않습니다. 스크립트에서 그 변수를 어떻게 사용할지 말해야 합니다. 따라서 여기 이 하드코딩된 문자열을 없애고 변수를 넣겠습니다.

중괄호 없이 빠르게 수행하겠습니다. 이것이 허용된다는 것을 보여주기 위해서인데, 이것이 오래된 스타일 방식입니다. 하지만 이제 새로운 구문으로 이것처럼 중괄호 안에 넣는 것을 정말 권장하며, 이것이 여기서 Nextflow에 의해 보간되고 있다는 것을 정말 명확하게 만듭니다.

좋습니다. 따라서 _"input greeting"_이 _$\{greeting\}_으로 들어갑니다. 마지막으로 워크플로우 수준에서 Nextflow에게 이 프로세스가 이제 입력을 받는다고 알려주어야 합니다. 그리고 그렇게 하기 위해 기본적으로 변수를 제공할 것입니다.

## 3.2. 사용자 입력을 캡처하기 위한 명령줄 매개변수 설정하기

Hello World처럼 다시 하드코딩할 수 있으며 잘 작동할 것이지만, 분명히 실제로 이점을 제공하지 않습니다. 런타임에 이것을 구성할 수 있기를 원했으므로 Nextflow를 시작할 때 CLI에서 할 수 있기를 원합니다.

그리고 그렇게 하는 방법은 _params_라는 특별한 Nextflow 개념입니다. _params.input_이라고 부르겠습니다.

이것이 하는 일은 CLI에서 이 input 변수를 노출하는 것이며, Nextflow를 시작할 때 이중 대시를 사용하는 곳입니다.

이것을 원하는 대로 _hello, greeting_이라고 부를 수 있습니다. 상관없습니다. 거기서 무엇을 하든 파이프라인을 시작할 때 CLI 옵션으로 노출됩니다. 그리고 이것은 Nextflow의 진정한 마법인데, 이러한 매개변수로 워크플로우 스크립트를 매우 빠르게 구축할 수 있고, 본질적으로 파이프라인에 대한 사용자 정의 CLI를 구축하여 시작할 때 다양한 옵션을 즉석에서 매우 쉽게 사용자 정의할 수 있기 때문입니다.

그래서. 시도해 봅시다. 터미널로 돌아갑니다. 여기에 _"nextflow run"_ 명령이 있습니다. 그리고 이제 _"--input"_을 수행하겠습니다. 이것은 앞서 본 _"params.input"_과 일치합니다. 문서에서는 프랑스어로 되어 있다고 생각합니다. Geraldine은 프랑스어를 좋아합니다. 저는 스웨덴에 살기 때문에 스웨덴어로 하겠습니다. "_Hej Världen_"이라고 하고 Enter를 누르겠습니다.

작은따옴표나 큰따옴표를 사용할 수 있으며, Bash가 어떻게 해석하는지에만 영향을 미칩니다.

Nextflow 파이프라인을 정확히 같은 방식으로 실행합니다. 작업 디렉토리와 모든 것이 동일한 것을 볼 수 있습니다. 하지만 이제 _"results/hello_world/output"_으로 가면. 대신 멋진 스웨덴어를 볼 수 있습니다.

따라서 CLI에서 매개변수로 입력을 동적으로 전달했습니다. 프로세스에 입력으로 전달했고 프로세스가 그것을 해석하여 스크립트 블록에 넣었으며, 그 스크립트 결과의 출력을 동적으로 변경했습니다. 정말 멋집니다.

여기서 매우 적은 구문으로 꽤 복잡한 로직입니다. 그리고 이것이 이제 어떻게 확장되는지 볼 수 있기를 바랍니다. 그리고 이것이 우리가 실제로 파이프라인의 로직과 사용자 정의 가능성을 Nextflow 스크립트에 구축하는 방법입니다.

## 3.4. 명령줄 매개변수에 기본값 사용하기

좋습니다, 훌륭합니다. 하지만 이제 문제는 이 파이프라인을 실행할 때마다 실행하려면 대시, input을 수행해야 한다는 것입니다.

이 매개변수 없이 실행하려고 하면, Nextflow는 이 매개변수가 필요했지만 설정되지 않았다고 말하며 오류를 발생시킬 것입니다. 그래서 무엇을 해야 할지 몰랐습니다.

그건 그렇고, 이것은 멋진 새로운 것입니다. 과거에는 Nextflow가 빈 문자열로 실행되었을 것이고, 이해하기 어려운 온갖 이상한 오류가 발생했을 것입니다. 하지만 새로운 Nextflow 구문 분석기에서는 조금 더 조심스럽고 즉시 알려줍니다.

따라서 모든 단일 옵션을 항상 지정하고 싶지는 않습니다. 합리적인 기본값을 지정하는 것이 좋은 관행입니다. 스크립트에서 어떻게 하나요?

이것을 작성할 때 _params.input_을 사용하는 곳에 바로 넣었다는 것을 알 수 있습니다. 따라서 명백한 해결책은 기본값을 정의하는 것이며, 여기 워크플로우의 스크립트 상단에 있는 특별한 params 블록에서 수행합니다. 이것은 여기 workflow 스크립트에 있습니다.

다시 말하지만, 여기에 새로운 구문이 있으므로 주의하세요. 정말 멋진 것입니다. 여기에 예상되는 매개변수의 이름이 있습니다.

그런 다음 이 콜론 문자 다음에 변수의 타입을 정의합니다. 이것을 수행할 필요는 없으며, 그냥 비워둘 수 있지만, 정말 좋습니다. Nextflow에게 문자열을 기대하고 있으며 그렇게 처리하라고 알려줍니다.

예를 들어 숫자를 원한다면 float라고 쓸 수 있으며, 부동 소수점 숫자를 원한다고 말할 것입니다. 그것으로 실행하려고 하면 오류가 발생할 것입니다. float가 아닌 문자열을 제공하면. 그리고 그렇게 전달할 것입니다. string을 수행하면 문자열이라는 것을 알고 있습니다. 그리고 선행 0이 있고 모두 숫자이더라도 실제 문자열로 전달할 것입니다.

따라서 그 타입 안전성은 Nextflow의 매우 새로운 기능이지만, 코드를 작성하고 실행하는 것을 더 안전하게 만들기 위해 정말 강력합니다.

그런 다음 그 다음에 등호 기호가 있고 여기에 기본값이 있습니다. Nextflow는 원래 바르셀로나에서 작성되었으므로, 기본값으로 _"Holà mundo!"_와 같은 스페인어가 있는 것이 적절해 보입니다.

그 스크립트를 저장하고, 돌아가서, _--input_ 없이 스크립트를 다시 실행하겠습니다. 그리고 이번에는 실행되어야 하며 _results_에 새 파일을 생성할 것입니다. 그리고 이 파일에는 이제 _"Holà mundo!"_라고 나옵니다.

그러나 이것은 단지 기본값일 뿐이므로, 이전과 같은 작업을 여전히 수행할 수 없다는 의미는 아닙니다. 돌아가서 여기 이전 스크립트 _"Hej Världen"_을 찾으면, 명령줄에서 _--input_을 수행하기 때문에 그 기본값을 덮어쓰고 output.txt 파일에서 다시 사용할 것입니다.

따라서 스크립트에서 이것은 제가 설정하는 기본값일 뿐입니다.

워크플로우를 더 복잡하게 구축하고 더 많은 매개변수를 포함함에 따라 스크립트 상단의 이 params 블록은 한 곳에 모두 수집하기 시작할 것입니다.

그리고 스크립트에서 이 꽤 멋진 대칭을 얻게 되는데, 여기에 모든 워크플로우 입력이 있고 아래에 워크플로우 출력이 있습니다. 그리고 워크플로우의 외부 세계에 대한 인터페이스가 무엇인지 매우 명확합니다. 따라서 새로운 구문으로 새로운 파이프라인을 매우 빠르게 선택하고 사용 방법을 이해할 수 있습니다.

마지막으로 하나 더 멋진 것. 이것으로 기본값을 설정할 필요가 없습니다. params input을 수행하지만 기본값을 설정하지 않으면 Nextflow에게 이 매개변수가 필요하다고 알려주고, 다시 파이프라인은 그것 없이는 실행되지 않지만, null에 대한 것보다 더 유용한 오류 메시지를 제공할 것입니다.

따라서 입력이 필요하지만 명령줄에서 지정되지 않았다고 예상하고 있다고 말합니다. 매우 좋습니다.

좋습니다, 이제 변수 입력과 매개변수로 Nextflow 파이프라인을 설정하는 방법, 기본값을 설정하는 방법, 타입을 설정하는 방법이 명확해지기를 바랍니다. 여기서 Boolean true false 플래그나 정수 또는 다른 타입일 수 있습니다. 워크플로우에 어떻게 전달하는지, 프로세스로 보간되는 곳을 통과합니다. 그리고 Nextflow를 시작할 때 명령줄에서 이것들을 사용자 정의하는 방법도 알고 있습니다. 이것은 간단한 bash 명령보다 더 흥미롭게 보이기 시작했습니다.

## 4. 워크플로우 실행 관리하기

좋습니다. 다음은 무엇일까요? 이 챕터의 마지막 부분에서는 다양한 워크플로우 실행을 관리하는 방법에 대해 조금 이야기하겠습니다. 여기 사이드바와 work 아래 탐색기를 보면 여러 다른 파이프라인을 실행했고 이러한 work 디렉토리가 꽤 길어지고 있으며, 많이 있습니다.

그리고 또 다른 것은, 앞서 말했듯이, 이 파이프라인을 다시 실행할 때마다 새로운 work 디렉토리 세트를 생성하고 있으며, 처음부터 모든 프로세스를 다시 실행하고 있다는 것입니다. 이것은 좋은 일입니다. 의도된 동작입니다. 재현 가능하고 모든 것을 새로 재생성하고 있습니다. 하지만 명백히 매우 오래 실행되는 프로세스를 실행하는 경우, 중간에 충돌하거나 파이프라인 끝에서 무언가를 변경한 경우 항상 파이프라인을 처음부터 시작해야 한다면 짜증납니다.

## 4.1. -resume으로 워크플로우 다시 시작하기

다행히 Nextflow는 이전에 실행된 것과 사용 가능한 것을 아는 데 정말 능숙하며, 이전 결과를 재사용하는 것은 매우 간단합니다. 명령 끝에 새 플래그 _"-resume"_을 추가하기만 하면 됩니다.

이제 input에는 이중 하이픈이 있는데, 그것이 매개변수이기 때문입니다. resume에는 하나의 하이픈만 있는데, 그것이 핵심 Nextflow 옵션이기 때문입니다.

이것은 항상 사람들을 혼란스럽게 하며, 오랫동안 Nextflow를 사용한 경우에도 마찬가지입니다. 따라서 항상 하나 또는 두 개의 하이픈을 기억하세요. 핵심 Nextflow 옵션인지 아닌지에 따라 다릅니다.

좋습니다, 이제 _-resume_을 수행하고 정확히 같은 워크플로우를 다시 실행합니다. 그리고 이번에는 한 가지 주요 차이점을 제외하고 거의 정확히 동일하게 보일 것입니다.

여기 출력에서 결과가 캐시되었다는 것을 볼 수 있습니다. 그리고 실제로 여기 이 작업 해시는 이전 실행과 정확히 동일하며, 그 work 디렉토리를 전체적으로 재사용했습니다. 입력과 출력 및 스크립트가 모두 수정되지 않았습니다. 따라서 그것에서 그 파일을 가져왔고 프로세스에 다운스트림 단계가 있다면 파이프라인의 다음 단계로 전달할 것입니다.

따라서 여전히 처음부터 끝까지 전체 파이프라인을 실행하고 있지만, 가능한 각 작업에 대해 캐시된 결과를 사용하고 있습니다.

이제 _-resume_을 수행하면 작업 디렉토리에서 마지막 파이프라인 실행을 재개하는데, 그것이 무엇이든 간에. 하지만 실제로 거기에서 수행한 이전 실행 중 어느 것에서나 재개할 수 있습니다. 그리고 이제 꽤 많이 했습니다.

## 4.2. 과거 실행의 로그 검사하기

모두 살펴보려면 _"nextflow run"_ 대신 _"nextflow log"_를 수행할 수 있으며, 그러면 이러한 모든 다른.. 화면을 조금 작게 만들어야 볼 수 있는데, 실행했을 때 이러한 모든 다른 실행, 세션 ID, 명령 및 모든 것을 보여주는 멋진 출력을 제공합니다.

그리고 여기를 살펴보고 이들 중 아무거나의 실행 이름을 가져와서 해당 특정 것 중 하나를 재개할 수 있습니다. 돌아가서 _hungry_ekeblad_라는 것을 재개할 수 있습니다. 그리고 resume 뒤에 넣으면 됩니다.

그건 그렇고, 궁금하시다면, 이 모든 형용사와 과학자 이름은 Nextflow 소스 코드에 있습니다. 가서 찾아서 좋아하는 과학자를 추가하여 Nextflow에 대한 첫 번째 풀 리퀘스트를 받는 정말 좋은 방법입니다.

어쨌든 그렇게 했고 돌아가서 이 워크플로우 실행의 캐시된 결과를 살펴보고 여전히 재사용할 수 있다는 것을 깨달았고, 그렇게 했습니다. 따라서 캐시된 결과를 다시 얻었습니다.

## 4.3. 이전 work 디렉토리 삭제하기

훌륭합니다. 이러한 work 디렉토리를 정리하고 싶다면 어떻게 할까요? 여기에 많이 있습니다. 파일이 많습니다. 아마도 마지막 몇 개의 파이프라인 실행에서 재개하고 싶다는 것을 확실히 알고 있지만, 그 이전의 모든 것은 신경 쓰지 않습니다.

그런 다음 여기서 하나를 선택하고 또 다른 Nextflow 명령인 _"nextflow clean"_을 사용할 수 있으며, _"nextflow clean"_을 수행할 수 있습니다. _"-before"_를 수행하고 특정 실행 이름을 사용하겠습니다. 이 경우 _reverent_pike_였고 _"-n"_을 수행하겠습니다. 이것은 Nextflow에게 드라이 런만 수행하라고 알려줍니다. 따라서 무엇을 삭제할지 알려줍니다. 실제로 아무것도 하지 않고, 이러한 work 디렉토리를 제거할 것입니다.

합리적으로 보입니다. 따라서 같은 명령을 다시 수행하겠지만, _"-n"_ 대신 _"-f"_를 수행하여 실제로 정리를 수행하겠습니다. 그리고 이번에는 실제로 이러한 모든 디렉토리를 제거했습니다. 그리고 work 디렉토리를 살펴보면 이제 훨씬 가벼워 보입니다. 훌륭합니다.

따라서 캐시를 완전히 파괴하지 않고 모든 로컬 work 디렉토리를 꽤 안전한 방식으로 정리하는 방법입니다. 따라서 원한다면 여전히 재개할 수 있습니다.

이러한 플래그가 무엇인지 잊어버린 경우 모든 Nextflow 명령에 대해 _"nextflow help"_를 수행한 다음 명령 이름을 수행할 수 있습니다. _"nextflow help clean"_을 수행하면 모든 다른 옵션을 볼 수 있습니다: _-after, -before, -but_, 이 정리 동작을 구성하는 모든 다른 방법. 정말 멋집니다.

## 핵심 정리

좋습니다, Hello Nextflow의 파트 1이 끝났습니다. 과정의 꽤 강도 높은 시작이지만, 이제 Nextflow 스크립트가 어떻게 생겼는지 꽤 잘 이해하고 있기를 바랍니다. 다양한 핵심 부분, 프로세스, 워크플로우, 출력 및 매개변수. 명령줄에서 기본 재정의로 구성하는 방법, 동적 스크립트로 동적 입력 블록을 만드는 방법을 알고 있으며, 모든 워크로드 실행을 관리하는 방법을 알고 있습니다: 이미 실행한 것을 보고, 재개하고, 정리하는 것. 많은 것들이 있습니다. 먼 길을 왔습니다. 따라서 휴식을 취하고 빠르게 산책하고 차 한 잔을 마시고 싶다면, 지금이 아마 좋은 시기입니다. 자격이 있습니다.

여기서부터는 기본적으로 이 기초를 쌓고 있습니다. 이것을 어떻게 더 복잡하고 강력하게 만들 수 있을까요? 어떻게 더 유연하게 만들 수 있을까요? 대규모로 분석을 수행하고 싶은 작업을 수행합니다.

## 퀴즈

이제 웹페이지의 파트 1, hello world로 스크롤하면 작은 퀴즈를 볼 수 있으며, 이것은 이 버전의 Nextflow 교육을 위해 수행한 새로운 것입니다. 그리고 이 챕터에서 수행한 모든 자료를 이해했는지 확인하기 위해 스스로 퀴즈를 풀 수 있습니다.

이것은 우리에게 전송되거나 그런 것이 아니며, 브라우저에 저장됩니다. 따라서 우리는 여러분의 답이 무엇인지 모르지만, 아무것도 놓치지 않았거나 오해하지 않았는지 확인하기 위한 작은 자가 점검일 뿐입니다. 그리고 원하는 만큼 시도할 수 있습니다.

저처럼 VS Code 인스턴스의 터미널에 머물고 싶다면, _quiz_ 명령을 입력한 다음 어느 챕터에 있는지 알려주기만 하면 됩니다. _"Hello World"_를 수행하면 웹 브라우저에 있는 것과 정확히 동일한 퀴즈 질문을 수행할 수 있지만, 터미널에서만 수행할 수 있습니다.

멋집니다. 좋습니다. 즐기시기 바라며, 조금 재미있게 보내시고, 다음 챕터에서 잠시 후에 Nextflow 채널에 대해 이야기하기 위해 뵙겠습니다.
