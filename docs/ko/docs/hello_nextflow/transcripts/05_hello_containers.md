# 파트 5: Hello Containers - 영상 대본

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보기 및 개선 제안하기](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Xqr--bKEN9U?si=QinuAnFwFj-Z8CrO&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 사항"

    이 페이지는 대본만 표시합니다. 전체 단계별 지침은 [과정 자료](../05_hello_containers.md)로 돌아가세요.

    대본에 표시된 섹션 번호는 참고용으로만 제공되며, 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영 및 배경

안녕하세요, Hello Nextflow에 다시 오신 것을 환영합니다. 이번은 Hello Containers라고 불리는 파트 5입니다. 과정의 이 부분에서는 파이프라인의 소프트웨어 요구 사항을 캡슐화하는 방법에 대해 다룰 예정입니다. 그래서 파이프라인을 실행하는 사람들은 소프트웨어 설치에 대해 걱정할 필요가 없습니다.

제가 해왔던 만큼 오랫동안 생물정보학 분야에서 일하셨다면, 제가 종종 나쁜 옛날이라고 부르는 시절을 기억하실지도 모릅니다. 다른 사람의 파이프라인을 실행하거나 그들의 작업을 복제하려고 할 때, 그들이 사용한 모든 다른 소프트웨어 도구들을 같은 버전으로 설치하려고 시간이나 며칠을 보내곤 했습니다. 여러분의 컴퓨터에서 그것들을 컴파일하려고 시도하면서요. 정말 악몽이었습니다. 정말 어려웠습니다.

HPC에서 실행하고 있다면, 시스템 관리자들이 여러분을 위해 소프트웨어를 설치하려고 노력했던 환경 모듈(environment modules)을 사용했을 수도 있습니다. 이것은 괜찮았지만 여전히 불완전했습니다.

하지만 이제 우리는 이를 수행할 더 나은 방법을 가지고 있습니다. Nextflow는 다양한 소프트웨어 컨테이너 기술에 대한 지원을 내장하고 있습니다. Docker가 가장 일반적입니다. 그것이 오늘 우리가 사용할 것입니다. Codespaces에서 잘 작동하고, 로컬 컴퓨터에서도 잘 작동하며, 클라우드에서도 잘 작동합니다.

또한 Singularity나 Apptainer도 있습니다. 이들은 HPC 시스템에서 매우 일반적이며 실제로 정확히 같은 방식으로 작동합니다. 또는 Podman, Shifter 등 여러 다른 것들이 있으며, 이들은 모두 매우 유사합니다.

약간 유사하지만 정확히는 아닌 추가적인 하나는 Nextflow가 지원하는 Conda입니다. Nextflow는 프로세스별로 Conda 환경을 관리할 수 있으며, 이는 자신만의 Conda 환경을 하는 것보다 훨씬 좋습니다. 그리고 다시 말하지만, 파이프라인과 함께 제공될 수 있습니다.

우리는 이 챕터를 시작하면서 컨테이너 기술과 Docker, 그리고 그것들이 어떻게 작동하는지에 대해 조금 이야기할 것입니다. 그리고 우리는 전반부를 Docker에서 수동으로 진행할 것입니다. 그래서 여러분은 내부에서 무엇이 일어나고 있는지, 이것이 어떻게 작동하는지 이해할 수 있습니다. 왜냐하면 Nextflow가 무엇을 하고 있는지, 워크플로우가 실행될 때 무엇을 하고 있는지 이해하는 것이 정말 중요하기 때문입니다.

그럼, 우리의 Codespaces로 넘어가 봅시다. 이제 모든 것을 다시 정리했지만, Hello Containers로 이동하면 모듈 챕터의 끝과 같이 모든 스크립트와 모든 것이 그곳에 있는 것을 볼 수 있을 것입니다. 그래서 우리는 여기 modules 디렉토리에 생성한 다양한 모듈들을 가지고 있습니다.

그것들은 여전히 그곳에 있습니다. 실행될 수 있도록 그곳에 있어야 합니다. 그리고 워크플로우와 출력은 모두 동일합니다. 단, 출력 게시 경로를 Hello Containers로 변경했으므로 파일들이 해당 디렉토리에 저장됩니다.

원한다면 지금 실행해서 작동하는지 확인할 수 있습니다. 또는 터미널로 계속 진행할 수 있습니다.

## 1. '수동으로' 컨테이너 사용하기

우리는 컨테이너를 관리하기 위해 Docker를 사용할 것입니다. "docker -v"를 실행하여 Codespaces에 설치되어 있는지 확인할 수 있습니다. 이것은 설치된 버전과 모든 것이 제대로 작동하고 있다는 것을 보여줍니다.

이제 컨테이너와 Docker는 정말 중요한 두 가지 개념을 가지고 있습니다. 하나는 이미지(image)라고 불리고, 하나는 컨테이너(container)라고 불립니다. 이미지는 여러분이 사용할 전체 파일 시스템의 스냅샷입니다. 그리고 컨테이너는 실행 중인 환경입니다. 따라서 이미지를 사용하여 컨테이너를 생성합니다.

컨테이너 안에 들어가면, 일반적으로 전체 운영 체제처럼 작동합니다. 외부 세계로부터 차단되어 있습니다. 다른 모든 것과 분리되어 있으며, 이것은 좋은 일입니다. 이것이 Nextflow로 이렇게 좋은 재현성을 얻는 방법입니다.

왜냐하면 컨테이너 내부에서 실행되는 작업의 경우, 로컬 시스템의 어떤 설정 파일에도 영향을 받지 않습니다. 다른 외부 영향도 없습니다. 그들은 자신만의 작은 샌드박스에서 실행됩니다. 그런 다음 파일들은 매우, 매우 재현 가능한 방식으로 생성됩니다. 왜냐하면 여러분은 모든 다른 컴퓨팅 환경에서 실행하는 모든 사람에게 동일한 기본 라이브러리, 모든 동일한 의존성, 정확히 동일한 소프트웨어를 사용하고 있기 때문입니다. 솔직히 저는 이것이 환상적이고 놀랍다고 생각하며, 심지어 오늘날까지도 이것이 가능하다는 것이 제 마음을 놀라게 합니다.

## 1.1. 컨테이너 이미지 가져오기

그래서 우리는 일부 Docker 이미지와 Docker를 사용해 볼 것입니다. 여러분의 시스템에서 실행할 때, 여러분의 컴퓨터, 또는 이 경우 코드 스페이스에 Docker 레지스트리가 있습니다. 이것은 과거에 다운로드되고 사용된 모든 다른 이미지들과 그것들이 구축된 다양한 레이어를 추적합니다.

"docker image ls"를 실행하여 Docker로 로컬에 어떤 이미지가 있는지 볼 수 있습니다. 그리고 이 경우 여기에 Docker 이미지 묶음이 있는 것을 볼 수 있습니다. 이것들은 모두 이 Codespaces를 설정하는 것과 관련이 있습니다. 모두 dev 컨테이너와 관련된 것들입니다. 그래서 너무 걱정할 필요는 없지만, 더 많은 이미지를 추가하고 다운로드하면서 이 과정이 진행됨에 따라, 해당 리스트를 확인할 수 있으며 로컬 레지스트리가 우리가 가져온 모든 것들을 추적하고 있다는 것을 볼 수 있습니다.

하지만 우리는 "docker pull"을 실행하여 새 것을 가져올 것입니다. 그리고 이것은 Docker에게 웹에서 새 이미지를 가져오라고 말합니다.

그런 다음 해당 컨테이너의 URI를 입력합니다. 이제 이것은 여러분이 로컬에서 빌드한 다음 인터넷에 푸시한 Docker 이미지일 수 있습니다. 다른 사람이 만든 이미지일 수도 있습니다. Docker 이미지를 만드는 많은, 많은, 많은 다른 방법이 있습니다. 하지만 틀림없이 가장 간단한 방법 중 하나는 그것을 아웃소싱하고 다른 사람이 여러분을 위해 해주도록 하는 것입니다.

그리고 이 튜토리얼에서 우리가 사용할 것은 Seqera Containers라는 Seqera의 서비스입니다.

이제 Seqera Containers는 완전히 무료이며, Wave라는 우리가 개발한 오픈 소스 소프트웨어를 사용합니다. 이것은 Nextflow에 보완적인 방식으로 컨테이너를 관리하기 위해 만들어졌습니다. 그리고 Nextflow와 함께 우리가 직면하는 많은 일반적인 사용 사례를 처리합니다.

우리가 필요로 하는 소프트웨어가 Conda, Bioconda 또는 conda-forge 채널이나 다른 더 도메인 특화된 채널에 패키지되어 있는 것이 매우 일반적입니다. 그리고 Wave와 Seqera Containers는 그것으로부터 이미지를 빌드하는 데 정말 좋습니다.

그래서 저는 이 웹 UI로 갈 수 있고, 우리는 "cowpy"라는 패키지를 가지고 놀 것입니다. 그래서 원하는 패키지의 이름을 입력합니다. 검색하면, Python 패키지 인덱스에서 찾았으므로 사용할 수 있습니다. 또는 조금 더 기다리면, bioconda와 conda-forge를 검색합니다. 그리고 여기서 어떤 Conda 채널이든 지정할 수 있습니다. 따라서 Nvidia 채널이나 다른 것을 찾고 싶다면, 그것도 작동해야 합니다.

그리고 Docker 이미지를 빌드할지 Singularity 이미지를 빌드할지 지정할 수 있으며, 또한 사용하고 싶은 CPU 아키텍처도 지정할 수 있습니다. amd64 또는 arm64입니다.

그리고 bioconda 결과가 나열되면, 이제 사용 가능한 모든 다른 버전도 볼 수 있습니다. 그것을 넣을 것입니다. 그리고 이제 계속 검색하고 원한다면 Conda에서 더 많은 패키지를 가져올 수 있으며, 원하는 방식으로 이 컨테이너를 구성할 수 있습니다. 하지만 저는 그것만 원합니다. 그래서 Get Container를 클릭하겠습니다.

이제, 다른 사람이 이미 같은 컨테이너를 요청했고 레지스트리에서 반환되었으므로, 우리는 즉시 그것을 얻습니다. 하지만 만약 이 소프트웨어 패키지나 소프트웨어 패키지의 이 조합을 이전에 아무도 요청한 적이 없었다면, Wave와 Seqera Containers가 즉시 빌드해 줄 것입니다.

이 URL을 복사할 수 있으며, 빌드 세부 정보 보기도 할 수 있습니다. 그리고 이것은 서비스가 백엔드에서 무엇을 했는지 보여줍니다. Conda 환경 파일을 생성했습니다. Docker 파일, 그리고 이것이 Docker 빌드 프로세스를 실행하는 것입니다. 또한 스캔, 보안 스캔을 실행했으므로, CVE를 볼 수 있습니다. 그리고 언제 생성되었는지 알려줍니다.

Wave와 Seqera Containers는 이보다 훨씬 더 많은 것을 할 수 있지만, 이것은 가장 일반적인 간단한 사용 사례입니다. 그리고 이러한 이미지는 최소 5년 동안 호스팅된다는 것을 말씀드려야 합니다. 따라서 여러분은 이러한 URL을 파이프라인에 빌드할 수 있으며, 그것들이 곧 사라지지 않을 것이라는 것을 알 수 있습니다.

그래서 저는 cowpy에 대한 Docker 이미지의 URL을 얻었습니다.

이제 "docker pull" 해당 URL을 실행할 수 있으며, 모든 다른 레이어를 가져오고 이 이미지를 다운로드하여 로컬에서 사용할 수 있게 합니다.

## 1.2. 컨테이너를 사용하여 cowpy를 일회성 명령으로 실행하기

좋습니다, 이제 실제로 사용해 봅시다. 그래서 이제 "docker pull" 명령 대신 "docker run" 명령을 사용할 것입니다. 그리고 "--rm" 플래그를 사용할 것입니다. 이것은 제가 요청한 작업을 완료하면 이 컨테이너를 종료하라고 Docker에게 말하는 것입니다. 그런 다음 컨테이너의 식별자를 입력합니다. 이것은 단지 URI입니다.

그리고 마지막에, Docker가 컨테이너 내부에서 실행하기를 원하는 명령을 지정합니다. 저는 cowpy라고 말할 것입니다. 이것은 이미지 내부에서 사용 가능한 Conda Forge에서 설치된 도구의 이름입니다.

Enter를 누르면 됩니다. 그리고 거기 있습니다. 우리는 시스템에서 cowpy를 실행했습니다. 우리에게 정보를 주는 작은 소가 있습니다.

이제 cowpy는 제 로컬 시스템에 설치되어 있지 않습니다. 그래서 Docker 관련 것들 없이 그냥 실행하면, command not found라고 말합니다. 따라서 이것은 이미지를 가져왔습니다. Docker를 사용하여 컨테이너를 생성했습니다. 그런 다음 해당 컨테이너로 들어가서 우리를 위해 이 명령을 실행하고 출력을 우리 터미널로 다시 전달했습니다. 매우, 매우 멋집니다.

## 1.3. 컨테이너를 사용하여 cowpy를 대화형으로 실행하기

좋습니다, 이제 한 걸음 더 나아가서 이 컨테이너를 대화형으로 실행하고 살펴볼 것입니다. 그래서 컨테이너 내부에서 무슨 일이 일어나고 있는지 볼 수 있습니다.

그래서 뒤로 가서 실행 명령을 가져오고 끝에 있는 cowpy를 제거하겠습니다. 왜냐하면 실제로 cowpy를 실행하고 싶지 않기 때문입니다. Bash 터미널을 실행하고 싶습니다.

그리고 여기로 돌아가서 "-it"를 입력할 것입니다. 이것은 Interactive와 Terminal 또는 TTY를 의미하며, Enter를 누를 것입니다.

그리고 이제 프롬프트, 입력하기 전의 비트가 변경된 것을 볼 수 있습니다. 이것은 디렉토리를 표시했던 Codespaces 프롬프트였고, 이제 base와 roots와 tmp라고 표시됩니다. 그래서 이제 컨테이너 내부에 있으며, "ls"를 수행하면 이 디렉토리에서 보는 파일들이 작업 공간에 있는 파일들과 다른 것을 볼 수 있습니다.

그리고 실제로, 컨테이너 내부에서 로컬 코드스페이스 작업 공간이나 로컬 드라이브의 파일을 볼 수 없습니다. Docker 컨테이너 런타임은 완전히 격리되어 있으며, 외부의 호스트 파일 시스템에서 파일을 쓰거나 읽을 수 없습니다.

그러나 컨테이너 내부에 설치된 소프트웨어를 보고 실행할 수 있습니다. 그래서 cowpy를 실행할 수 있으며, cowpy를 사용하는 방법에 대해 조금 더 볼 수 있습니다. 여기서 "cowpy 'Hello World'"를 실행할 수 있으며, 이것은 제 인용문을 작은 말풍선 안에 넣으라고 지시합니다. 그리고 다른 유형의 소들도 실행할 수 있으므로, 소일 필요는 없습니다. "-c"를 실행할 수 있습니다. 그리고 저는 스웨덴에 있으므로, 무스를 선택하겠습니다. 매우 좋습니다. 뿔을 달았습니다.

그리고 교육 문서에 설명된 것처럼 여러분이 가지고 놀 수 있는 다양한 것들이 많이 있습니다.

## 1.3.4. 컨테이너에 데이터 마운트하기

좋습니다. 우리 파일 시스템의 파일에서 cowpy를 실행할 수 있다면 좋을 것 같습니다.

물론, 컨테이너만 있고 아무것도 접근할 수 없다면 그다지 유용하지 않습니다. 안전하고 재현 가능할 수 있지만, 그다지 유용하지 않습니다.

그럼 어떻게 할까요? 이 Docker 컨테이너에서 exit를 입력하여 나갈 것입니다. 그리고 프롬프트가 우리가 이제 일반 Codespaces로 돌아왔다는 것을 알려줍니다.

그리고 같은 명령을 다시 실행할 것입니다. 하지만 이번에는 여기에 몇 가지 추가 플래그를 추가할 것입니다. 그리고 중요한 것은 "-v"입니다. 이것은 볼륨 마운트를 의미하며, 이것은 기본적으로 디스크 공간의 일부와 같습니다.

"-v"는 두 부분을 가집니다: 문자열이 있고 콜론이 있고 문자열이 있습니다. 그리고 첫 번째 부분은 컨테이너에 마운트되어야 하는 로컬 파일 시스템입니다. 그리고 두 번째 부분은 컨테이너 내부에서 어디에 있어야 하는지입니다.

이제 저는 여기에 전체 로컬 파일 시스템을 로드하고 싶습니다. 그래서 "."는 현재 작업 디렉토리입니다. 그래서 "."를 입력한 다음 ":"를 입력하고, 그런 다음 그것을 "my_project"라는 컨테이너 내부의 새 디렉토리에 넣을 것입니다. 이것은 정말 무엇이든 불릴 수 있습니다.

그리고 다시 실행할 것입니다.

제가 던져진 작업 디렉토리인 /tmp에서 파일들은 거기에 없습니다. 하지만 "ls my_project"를 수행하면, 거기 있습니다: 로컬 Codespaces에 있던 모든 동일한 파일들이 이제 해당 경로의 컨테이너 내부에서 사용 가능합니다.

이것은 읽기 및 쓰기 액세스이므로 이 디렉토리에 새 파일을 생성할 수 있으며, 호스트 파일 시스템에 표시됩니다. 따라서 이 특정 디렉토리는 컨테이너 외부에 있는 것처럼 정확히 동작하므로, 이제 읽고 쓰고 작업을 수행할 수 있습니다.

## 1.3.5. 마운트된 데이터 사용하기

좋습니다, 우리가 이것을 할 수 있다는 것을 증명해 봅시다. "cat /my_project/data/greetings.csv"를 실행합니다. 이 파일 내용이 이렇게 생겼다는 것을 기억하신다면, 이제 그것을 cowpy에 파이프할 수 있으며, 소가 작은 말풍선에 해당 파일의 다양한 출력을 인쇄할 것입니다. 이것은 꽤 재미있습니다.

그래서 여러분은 컨테이너의 소프트웨어를 사용하여 호스트 시스템의 파일과 상호 작용할 수 있다는 것을 볼 수 있습니다.

좋습니다, 다시 나가서 나머지 교육 자료를 진행하겠습니다.

## 2. Nextflow에서 컨테이너 사용하기

그래서 컨테이너를 사용하는 것은 정말 멋집니다. 이해가 되기를 바랍니다. 그리고 이러한 컨테이너의 가치와 분석 소프트웨어를 실행하는 데 왜 유용한지 알 수 있습니다.

하지만 Nextflow 내부에서 이 전체 프로세스를 어떻게 수행할까요? 우리는 많은 Docker 명령을 직접 실행하고 싶지 않습니다. Nextflow가 우리를 위해 모든 것을 처리하도록 하고 싶습니다.

그럼 이것을 진행해 봅시다. cowpy를 실행하기 위해 파이프라인에 새 프로세스를 추가할 것입니다. 좋습니다, 새 프로세스를 위한 새 모듈을 생성합시다. modules로 가서, cowPy.nf라고 부르고, 그런 다음 여기 교육 자료에서 코드를 복사하겠습니다.

하지만 프로세스가 매우 간단한 것을 볼 수 있습니다. 지금까지 해왔던 것과 매우 유사합니다. 입력 파일인 경로가 있는 입력 블록이 있고, 여기에 값도 있어서 이것은 문자가 될 것입니다. 그래서 원한다면 무스를 다시 사용할 수 있습니다.

그리고 출력, 이것은 여기에 단일 파일입니다. 경로, 그리고 스크립트입니다. 그리고 우리는 컨테이너 내부에서 대화형으로 했던 것과 같은 것을 하고 있습니다: 입력 파일을 읽기 위해 "cat"을 하고 있습니다. 해당 내용을 cowpy로 파이프하고 있습니다. 해당 입력을 기반으로 특정 캐릭터를 선택하고, cowpy input file이라는 출력 파일에 쓰고 있으며, 이것은 출력으로 에코됩니다.

좋습니다. 그것을 포함시킵시다. 그래서 include \{ cowpy \} from "./modules/cowpy.nf", 제가 cowpy라고 불렀나요? 네.

그리고 워크플로우의 메인 블록 아래에서 새 프로세스를 호출합시다. 그래서 cowpy를 실행합시다. 그리고 새 cowpy 프로세스를 가져올 것이며, collectGreetings.out이라고 말할 것입니다.

그리고 기억하신다면, 이 모듈에 대한 두 개의 출력이 있었습니다. outfile이라고 불리는 하나와 report라고 불리는 하나입니다. VS Code 확장이 우리를 위해 자동 제안하고 있으며, .outfile을 원합니다.

여기서 프로세스를 항상 호버할 수 있습니다. 그것을 호버하면 출력이 무엇인지 빠르게 보여줘야 합니다. 그리고 command 클릭할 수도 있으며, 더 자세히 보고 싶다면 모듈 파일을 열 것입니다.

그래서 여기 있습니다. 그것이 거기 있는 outfile이고, 그것이 경로입니다. 따라서 이제 이것은 우리 cowpy 프로세스의 입력 파일이 될 것입니다. 환상적입니다.

이제 기억하신다면, cowpy 프로세스는 두 개의 입력을 가지고 있습니다. 캐릭터를 위한 값 채널도 있었습니다. 그래서 여기에 "params.character"를 추가할 수 있습니다. 원한다면 이것을 하드코딩할 수 있었지만, CLI 옵션으로 만들어서 dash, dash character를 할 수 있도록 합시다.

맞습니다. 이제 방금 호출한 입력 매개변수를 정의하고 기본값을 제공해야 합니다. character, String. 그리고 저는 무스를 좋아하므로, 기본값으로 moose로 설정하겠습니다.

맞습니다, 실행해 봅시다. 그래서 Nextflow run hello containers를 하면, 무슨 일이 일어나는지 볼 것입니다.

오래된 작업 디렉토리가 주변에 있었다면 dash resume을 사용할 수 있었습니다. 그리고 다시, 이러한 첫 번째 프로세스들은 캐시되었을 것이고 조금 더 빨랐을 것입니다. 하지만 기본적으로 동일해야 합니다.

이제 새 프로세스에 도달했을 때 오류가 발생한 것을 바로 볼 수 있습니다. 여기서 cowpy 프로세스를 실행하는 오류가 있었고 종료 상태 127로 종료되었다고 알려주고 있습니다. 이것은 실행하려고 시도한 명령입니다. 그것은 올바른 것처럼 보입니다. 우리가 예상한 대로 보입니다. 올바른 것처럼 보이는 해당 출력 파일 이름을 가져와서 무스 캐릭터로 실행하고 저장하려고 합니다.

하지만 여기 명령 오류는 cowpy command's not found라고 말하고 있는 것을 볼 수 있습니다. 그리고 그것은 이해가 됩니다. 왜냐하면 우리는 실제로 Nextflow에게 아직 컨테이너를 사용하라고 말하지 않았기 때문입니다. 우리는 그냥 cowpy 명령을 제공했습니다. 그리고 제가 전에 말했듯이, cowpy는 우리 로컬 시스템에 설치되어 있지 않습니다. 따라서 실행하려고 시도했을 때 실패했습니다.

## 2.3.1. cowpy에 대한 컨테이너 지정하기

우리는 Nextflow에게 사용 가능한 컨테이너가 있고 사용할 수 있다고 말해야 합니다. 그럼 어떻게 할까요?

여기 모듈로 들어가면, 상단에 "container"라는 새로운 선언을 추가할 것입니다. 그리고 그것을 문자열로 설정할 것입니다.

이제 기억하신다면, Seqera Containers에서, 해당 URL을 복사할 수 있으며, 그냥 여기 따옴표 안에 넣습니다.

이제 돌아가서 다시 실행해 봅시다.

이번에는 작동하는지 봅시다.

불행히도, 프로세스가 실행될 컨테이너를 정의했음에도 불구하고 정확히 같은 방식으로 실패합니다. Docker 이미지를 사용하려면, 워크플로우를 실행할 때 Nextflow에게 Docker 사용을 활성화하라고 말해야 합니다.

그리고 새 설정 파일을 생성하여 그렇게 할 것입니다. 그래서 touch nextflow.config를 말할 것입니다.

이것은 파이프라인을 시작하는 동안 작업 디렉토리에 있으면 자동으로 로드될 특별한 파일 이름입니다. 그래서 이 Nextflow dot config 파일로 들어가면, 실제로 이미 존재한다는 것을 볼 수 있습니다. 제가 잊어버렸던 것입니다. 그리고 여기에 이미 docker.enabled가 있지만 false로 설정되어 있으며, 이것이 기본값입니다.

그래서 대신 equals True로 변경하면, docker.enabled입니다. 그리고 Nextflow 문서에 이러한 모든 설정 범위에 대한 참조 문서가 있습니다. 그리고 VS Code 확장으로 호버할 때 이것에 특정한 문서를 가져와서 무엇을 의미하는지, 어떻게 설정하는지 알려주는 것도 볼 수 있습니다.

그래서 이제 우리는 true로 설정했고, Nextflow를 다시 실행하면, Nextflow는 이제 로컬에 아직 없다면 우리를 위해 해당 Docker 이미지를 가져오고, 그런 다음 해당 컨테이너 환경으로 해당 프로세스를 실행한다는 것을 알게 될 것입니다.

그리고 성공적으로 실행된 것을 볼 수 있으며, cowpy 옆에 작은 체크 표시가 있습니다. 환상적입니다. 올라가서 results 디렉토리를 보면, 파일이 아직 거기에 없습니다. 그리고 그것은 우리가 여전히 이 출력 파일을 다른 모든 것들과 마찬가지로 게시해야 하기 때문입니다.

그래서 워크플로우 내의 게시 블록으로 가서, mycowpy equals cowpy.out이라고 말합니다.

그리고 여기 출력 블록 아래에서, mycowpy, 중괄호 path입니다. 이런. Hello containers. Mode, copy입니다.

이제 다시 실행하면, 정확히 같은 방식으로 실행되어야 합니다. dash resume을 사용할 수 있었는데 매번 잊어버립니다. 그리고 올라가면 이제 cowpy-COLLECTED라는 새 파일이 생성되었으며, 거기에 BONJOUR, HELLO, HOLà라고 말하는 제 무스가 있습니다. 환상적입니다.

물론 이제 "--character"를 전달할 수도 있습니다. 다른 옵션은 무엇입니까? 칠면조가 있는 것 같나요? 그래서 character Turkey를 사용할 수 있습니다. 정확히 같은 방식으로 실행될 것입니다. 다시 dash resume을 사용할 기회를 놓쳤습니다. 그리고 이제 파일을 로드하면 칠면조가 있습니다. 환상적입니다.

## 2.3.4. Nextflow가 컨테이너화된 작업을 시작한 방법 검사하기

좋습니다. 마지막 작은 것입니다. 이 명령을 다시 빠르게 실행하고, 이번에는 resume하고, 작업 디렉토리를 빠르게 살펴보고 Nextflow가 내부적으로 우리를 위해 이 모든 것을 작동하게 하기 위해 무엇을 하고 있는지 봅시다.

이번에는 매우 빠릅니다. cd work/로 이 작업 디렉토리로 들어가 봅시다. 이제 기억하신다면 여기에 여러 닷 파일들이 있으며, 이 경우 우리가 관심 있는 것은 제가 거의 볼 필요가 없다고 말했던 .command.run이라는 것입니다.

code dot command run을 수행하면, 편집기에서 열립니다. 그리고 이 파일에서 검색할 수 있으며, 스크롤 다운하면 Docker run이 보일 것입니다. 그리고 Nextflow가 설정에서 Docker가 활성화되었을 때 우리를 위해 docker run 명령을 수행하고 있는 것을 볼 수 있습니다. 여기에 여러 다른 플래그와 것들이 있지만, 우리가 직접 사용했을 때의 "-v" 플래그를 볼 수 있습니다. 그리고 로컬 작업 공간 디렉토리를 컨테이너에 마운트하고 있는 것을 볼 수 있습니다. 그래서 컨테이너가 우리의 입력 파일에 액세스하고 출력을 저장할 수 있습니다. 그리고 마지막에, cowpy 명령이 들어 있는 생성된 스크립트인 .command.sh도 실행하고 있습니다.

그리고 Nextflow가 우리 분석에 특정한 것인 우리가 실제로 관심 있는 것인 워크플로우 로직을 가져와서 우리 시스템에서 Docker가 작동하도록 하는 모든 영리한 뒷단 작업을 수행하고 있는 것을 볼 수 있습니다.

그리고 Nextflow는 최종 사용자가 사용하는 기술을 전환할 수 있도록 정말 휴대 가능한 방식으로 그것을 수행하고 있습니다: Docker, Singularity, Apptainer, Conda. 그것은 파이프라인 로직에 실제로 중요하지 않지만, Nextflow는 어디서나 실행되도록 모든 기본 인프라 요구 사항을 처리할 것입니다.

그리고 그것이 정말 Nextflow의 초능력입니다. 재현성과 휴대성입니다. 그리고 Nextflow로 여러분은 실제로 워크플로우를 공유할 수 있으며, 다른 사람들이 그들의 시스템에서 실행할 수 있으며, 그냥 작동할 것입니다.

그것은 정말, 정말 어려운 일이며, 이제 여러분도 워크플로우로 그것을 하는 방법을 알게 되었습니다.

좋습니다, 이 챕터는 여기까지입니다. 과정의 끝으로 내려가면, 컨테이너에 대한 퀴즈를 다시 찾을 수 있습니다. 모두 이해가 되기를 바랍니다. 분석 작업을 하는 정말 멋진 방법입니다. 그리고 컨테이너를 처음 접하신다면, 이것이 가야 할 길이라는 것을 확신시켜드렸기를 바라며, 절대 뒤돌아보지 않으실 것입니다.

하지만 그것으로, 잠깐 쉬고, 몇 분 후에 제가 Hello Nextflow의 마지막 파트 6을 진행하는 데 함께해 주세요. 이것은 모두 설정에 관한 것입니다.

대단히 감사합니다.
