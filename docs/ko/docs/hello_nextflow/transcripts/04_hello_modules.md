# 파트 4: Hello Modules - 비디오 스크립트

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보기 및 개선 사항 제안](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/43Ot-f0iOME?si=0AWnXB7xqHAzJdJV&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요한 사항"

    이 페이지는 스크립트만 보여줍니다. 단계별 전체 지침은 [과정 자료](../04_hello_modules.md)로 돌아가세요.

    스크립트에 표시된 섹션 번호는 참고용으로만 제공되며, 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영합니다

안녕하세요. Hello Nextflow 파트 4에 다시 오신 것을 환영합니다. 이 섹션은 모듈에 관한 것이며, 과정의 꽤 짧은 섹션입니다. 실제로 코드를 많이 작성하지는 않을 것이며, 파이프라인에서 코드를 어떻게 구성하는지에 더 중점을 둡니다.

지금까지 모든 것을 단일 파일에 넣어왔으며, 이것도 괜찮습니다. 실제로 예전에는 이런 방식으로 Nextflow 파이프라인을 구축했습니다.

하지만 파이프라인이 커지면 스크립트가 점점 더 길어지고, 탐색하고 유지 관리하기가 점점 더 어려워집니다. 또한 코드를 공유할 수 없게 됩니다.

Nextflow 모듈을 사용하면 메인 스크립트에서 프로세스를 분리한 다음 가져올 수 있습니다. 이는 코드를 탐색하기가 더 쉬워지며, 서로 다른 파이프라인 간에 모듈 코드를 공유할 수 있음을 의미합니다.

문서 메인 페이지의 이 작은 다이어그램이 개념을 잘 보여줍니다. 하나의 거대한 스크립트 대신 서로 다른 모듈 스크립트에서 이러한 별도의 모듈 파일을 포함할 것이며, 모두 워크플로우로 가져와지지만 정확히 동일한 방식으로 실행됩니다.

이제 GitHub Codespaces로 들어가서 살펴보겠습니다. 이전과 마찬가지로 여기 작업 공간을 약간 정리했습니다. 이전 Nextflow 디렉토리와 work 디렉토리 등을 제거했습니다. 하지만 여전히 해당 파일들이 있어도 상관없습니다.

hello modules 파일에서 작업을 시작하겠습니다. 이 파일은 기본적으로 이전 챕터 끝에 남겨둔 상태입니다. 여기에 세 개의 프로세스가 있습니다. 몇 개의 매개변수가 있고, 워크플로우 블록이 있으며, 여기서 세 프로세스를 실행하고 채널로 연결합니다. 그런 다음 출력 채널을 게시하고, 출력 블록에서 해당 파일을 게시하는 방법을 지정합니다.

## 1. 모듈을 저장할 디렉토리 생성

이제 말했듯이 실제로 코드를 많이 작성하거나 편집하지는 않을 것입니다. 이미 가지고 있는 코드를 이동하기만 하면 됩니다. Nextflow 모듈 파일은 일반적으로 단일 프로세스를 포함하며, 관례상 보통 modules라는 디렉토리에 보관합니다. 하지만 원하는 대로 이름을 지을 수 있습니다. 하지만 저는 여기 저장소에 modules 디렉토리를 유지하고, 각 프로세스에 대해 하나의 파일을 생성하겠습니다. 새 파일, sayHello.nf라고 하겠습니다.

## 2. sayHello()에 대한 모듈 생성

이제 프로세스를 가져와서 이 코드를 선택하고, 메인 hello modules 파일에서 잘라내어 여기에 붙여넣겠습니다.

당연히 그것만으로는 아무것도 하지 않습니다. 메인 스크립트는 여전히 해당 프로세스가 필요하므로, 어떻게든 다시 가져와야 합니다. 그리고 include 문으로 이를 수행합니다.

그래서 include를 입력하고 중괄호를 입력한 다음, 프로세스 이름을 입력합니다. 그리고 from이라고 말하고, 상대 파일 경로를 제공합니다. 이 스크립트가 저장된 위치를 기준으로 상대 경로이므로 ./로 시작합니다. 따라서 modules sayHello.nf입니다.

VS Code 확장 프로그램이 여기서 꽤 도움이 된다는 것을 알 수 있습니다. 이 파일을 찾을 수 있는지, 그리고 제가 이름을 지정한 프로세스를 찾을 수 있는지 알려줍니다. 여기에 의도적으로 오타를 입력하면 즉시 오류가 표시되며, 가져오려는 프로세스를 찾을 수 없다고 알려줍니다. 따라서 발견한 오류를 주시하세요.

그리고 그게 전부입니다. 여전히 프로세스가 여기 있습니다. 아래에는 변경이 필요 없습니다. 프로세스는 동일한 이름을 가지고 있으며 정확히 동일한 방식으로 실행됩니다. 프로세스의 실제 코드만 이제 별도의 파일에 있습니다.

Nextflow 워크플로우를 다시 실행할 수 있으며, 정확히 동일한 방식으로 작동할 것입니다. 그리고 이것이 기본적으로 과정의 나머지 챕터는 이 세 프로세스를 각각의 파일로 이동하는 것입니다.

이제 그것을 해봅시다. 두 번째 프로세스를 위해 빠르게 새 모듈 파일을 생성하겠습니다: convertToUpper.nf. 해당 코드를 잘라내어 여기에 붙여넣겠습니다. 그런 다음 그것을 포함하겠습니다. 좋습니다.

그런 다음 collectGreetings.nf에 대한 새 파일을 생성하겠습니다. 잘라내겠습니다.

많은 잘라내기, 복사 및 붙여넣기입니다.

이제 메인 워크플로우 스크립트가 갑자기 훨씬 더 짧아지고, 훨씬 더 접근하기 쉬우며, 읽기가 훨씬 쉬워졌습니다.

그리고 이제 프로젝트가 서로 다른 파일로 구성되는 것을 볼 수 있습니다. 원하는 곳에서 세부 사항을 자세히 살펴볼 수 있습니다. 파이프라인의 특정 단계를 훨씬 더 쉽게 찾을 수 있으며, 파이프라인이 수행하는 작업의 개요를 빠르게 파악할 수 있습니다.

## VS Code로 모듈 탐색하기

물론 이렇게 하는 단점은 큰 파이프라인이 있는 경우, 많은 모듈 파일이 있고 여러 하위 디렉토리나 온갖 것들로 구성될 수 있다는 것입니다. 이제 다시 한 가지 작은 팁입니다. VS Code 확장 프로그램은 코드베이스를 탐색하고 거기에 있는 코드에 대해 알려주는 데 꽤 능숙합니다.

VS Code가 이 프로세스가 무엇인지 이해하고 마우스를 올려놓으면 개요를 제공하는 것을 볼 수 있습니다. 따라서 소스 코드를 찾아가지 않고도 입력과 출력이 무엇인지 볼 수 있습니다. 이것은 일반적으로 워크플로우에서 사용할 때 가장 중요한 것입니다.

또한 Mac에서 Command 키를 누르고 프로세스 이름을 클릭하면 파일이 즉시 바로 열립니다. 가져옵니다. 따라서 실제 파일 경로가 무엇인지 생각하지 않고도 바로 거기로 이동할 수 있습니다. 그리고 이것은 어디서나 작동하며, 프로세스가 호출되는 곳에서도 할 수 있습니다. 따라서 정말 빠릅니다.

## 4.4. 워크플로우 실행

좋습니다. 파이프라인이 예상대로 여전히 실행되는지 확인해봅시다. 터미널을 불러옵니다. "nextflow run hello modules"를 실행하고 문제 없이 실행되는지 확인해봅시다.

이것의 전체 요점은 파이프라인이 기본적으로 변경되지 않았다는 것이므로, 이전에 실행했을 때와 실제로 변경 사항을 보지 못해야 합니다. 여기 출력은 정확히 동일하게 보이며, 모든 동일한 파일이 있는 results 디렉토리를 볼 수 있으므로 좋습니다. 변경 사항이 없다는 것은 좋습니다.

## nf-core/modules에 대한 참고 사항

마무리하기 전에 모듈과 관련된 협업의 힘에 대해 간단히 언급하고 싶습니다. 이러한 파일은 제 저장소에 있으므로, 어떻게 협업할 수 있는지 즉시 명확하지 않습니다. 이를 수행할 수 있는 여러 가지 방법이 있지만, 아마도 가장 크고 잘 알려진 예는 nf-core입니다.

nf-core 웹사이트로 가서 리소스, 모듈로 갑니다. nf-core에는 제가 볼 때 거의 1700개에 가까운 거대한 모듈 라이브러리가 있습니다. 따라서 좋아하는 도구의 이름을 입력하고, 다른 사람이 이미 모듈을 작성했는지 찾아보고, 모든 입력, 출력, 소프트웨어 컨테이너, 모든 정보가 포함된 이 미리 작성된 모듈 프로세스를 볼 수 있습니다. 그리고 옆에서 얼마나 많은 서로 다른 nf-core 파이프라인이 이 단일 공유 프로세스를 모두 사용하고 있는지 볼 수 있습니다.

이것은 약간 극단적인 예이지만, 이것이 실제로 이 코드를 재사용하는 것을 볼 수 있습니다. 그리고 이것에 대한 GitHub 소스를 클릭하면 우리가 하고 있는 것과 정확히 동일합니다. 파일 안의 큰 프로세스일 뿐입니다.

이제 nf-core 측에서는 해당 파일을 공유하고 서로 다른 저장소로 가져올 수 있도록 몇 가지 트릭을 사용합니다. 그리고 이에 대해 더 알고 싶다면, nf-core를 사용하고 구축하는 것에 대한 과정을 확인하세요. 하지만 이 코드 재사용 개념이 얼마나 강력할 수 있는지에 대한 아이디어를 제공하고 싶었습니다.

## 마무리

좋습니다. 모듈에 대한 내용은 이것으로 끝입니다. 과정의 짧은 섹션이라고 말씀드렸습니다. 퀴즈를 확인하고, 이해했는지 확인하고, 모든 것이 여전히 제대로 작동하는지 확인하세요. 그리고 소프트웨어 컨테이너에 관한 다음 비디오에서 뵙겠습니다. 대단히 감사합니다.
