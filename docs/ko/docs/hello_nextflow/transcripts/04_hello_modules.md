# 파트 4: Hello Modules - 비디오 스크립트

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI 지원 번역 - [자세히 알아보기 및 개선 제안](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/43Ot-f0iOME?si=0AWnXB7xqHAzJdJV&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "중요 참고 사항"

    이 페이지는 스크립트만 표시합니다. 전체 단계별 지침은 [과정 자료](../04_hello_modules.md)로 돌아가세요.

    스크립트에 표시된 섹션 번호는 참고용으로만 제공되며, 자료의 모든 섹션 번호를 포함하지 않을 수 있습니다.

## 환영합니다

안녕하세요, Hello Nextflow 파트 4에 다시 오신 것을 환영합니다. 이 섹션은 모듈에 관한 내용이며, 과정 중 상당히 짧은 섹션입니다. 실제로 코드를 많이 작성하지는 않을 것입니다. 파이프라인에서 코드를 어떻게 구성하는지에 더 중점을 둡니다.

지금까지 우리는 모든 것을 단일 파일에 넣어왔습니다. 이것도 괜찮고, 실제로 예전에는 이런 방식으로 Nextflow 파이프라인을 구축했습니다.

하지만 파이프라인이 커지면서 스크립트가 점점 더 길어지고, 탐색하고 유지 관리하기가 점점 더 어려워집니다. 또한 코드를 공유할 수도 없게 됩니다.

Nextflow 모듈을 사용하면 메인 스크립트에서 프로세스를 분리한 다음 가져올 수 있습니다. 이는 코드를 더 쉽게 탐색할 수 있게 하고, 서로 다른 파이프라인 간에 모듈 코드를 공유할 수 있게 합니다.

문서의 메인 페이지에 있는 이 작은 다이어그램이 개념을 잘 보여줍니다. 하나의 거대한 스크립트 대신, 서로 다른 모듈 스크립트에서 이러한 별도의 모듈 파일을 포함할 것입니다. 모든 것이 워크플로우로 가져와지지만, 여전히 정확히 같은 방식으로 실행됩니다.

그럼 GitHub Codespaces로 들어가서 살펴보겠습니다. 이전과 마찬가지로 여기 작업 공간을 조금 정리했습니다. 이전 Nextflow 디렉토리와 work 디렉토리 등을 제거했습니다. 하지만 여전히 그 파일들이 있어도 상관없습니다.

hello modules 파일에서 작업을 시작하겠습니다. 이 파일은 기본적으로 이전 챕터의 끝에서 남겨둔 상태입니다. 여기에 세 개의 프로세스가 있습니다. 몇 개의 매개변수가 있고, 워크플로우 블록이 있으며, 여기서 세 개의 프로세스를 실행하고 채널로 연결합니다. 그런 다음 출력 채널을 게시하고, 출력 블록에서 해당 파일을 게시하는 방법을 지정합니다.

## 1. 모듈을 저장할 디렉토리 생성

이제 말씀드린 것처럼, 실제로 코드를 많이 작성하거나 편집하지는 않을 것입니다. 이미 가지고 있는 코드를 이동시킬 것입니다. Nextflow 모듈 파일은 일반적으로 하나의 프로세스를 포함하며, 관례적으로 modules라는 디렉토리에 보관합니다. 하지만 원하는 대로 이름을 지을 수 있습니다. 저는 여기 저장소에 modules 디렉토리를 만들고, 각 프로세스마다 하나의 파일을 만들겠습니다. 새 파일을 만들어서 sayHello.nf라고 하겠습니다.

## 2. sayHello()를 위한 모듈 생성

이제 프로세스를 가져와서 이 코드를 선택하고, 메인 hello modules 파일에서 잘라내어 여기에 붙여넣겠습니다.

당연히 이것만으로는 아무것도 하지 않습니다. 메인 스크립트는 여전히 그 프로세스가 필요하므로, 어떻게든 다시 가져와야 합니다. 그리고 include 문으로 그렇게 합니다.

include를 입력하고 중괄호를 넣은 다음, 프로세스의 이름을 가져옵니다. 그리고 from이라고 말하고, 상대 파일 경로를 제공합니다. 이 스크립트가 저장된 위치를 기준으로 상대 경로이므로 ./로 시작합니다. 그래서 modules sayHello.nf입니다.

VS Code 확장 프로그램이 여기서 꽤 도움이 되는 것을 알 수 있습니다. 이 파일을 찾을 수 있는지, 제가 지정한 프로세스를 찾을 수 있는지 알려줍니다. 여기에 일부러 오타를 넣으면 즉시 오류가 표시되고, 가져오려는 프로세스를 찾을 수 없다고 알려줍니다. 그러니 발견하는 오류를 주의 깊게 살펴보세요.

그리고 그게 전부입니다. 여전히 프로세스가 여기 있습니다. 아래쪽에는 변경이 필요하지 않습니다. 프로세스는 같은 이름을 가지고 있고 정확히 같은 방식으로 실행됩니다. 단지 프로세스의 실제 코드가 이제 별도의 파일에 있을 뿐입니다.

Nextflow 워크플로우를 다시 실행할 수 있으며, 정확히 같은 방식으로 작동할 것입니다. 그리고 이것이 기본적으로 이 과정 챕터의 나머지 부분입니다. 이 세 개의 프로세스를 각각의 파일로 옮기는 것입니다.

그럼 지금 해보겠습니다. 두 번째 프로세스를 위한 새 모듈 파일을 빠르게 만들겠습니다: convertToUpper.nf. 그 코드를 잘라내서 여기에 붙여넣겠습니다. 그런 다음 그것을 include하겠습니다. 좋습니다.

그리고 collectGreetings.nf를 위한 새 파일을 만들겠습니다. 그것을 잘라냅니다.

많은 잘라내기, 복사, 붙여넣기가 있습니다.

이제 메인 워크플로우 스크립트가 갑자기 훨씬 더 짧아지고, 훨씬 더 접근하기 쉬워지고, 읽기가 훨씬 더 쉬워졌습니다.

그리고 이제 프로젝트가 서로 다른 파일들로 구성되기 시작하는 것을 볼 수 있습니다. 원하는 곳에서 세부 사항을 살펴볼 수 있습니다. 파이프라인의 특정 단계를 찾기 위해 훨씬 더 쉽게 탐색할 수 있고, 파이프라인이 무엇을 하는지 빠르게 개요를 파악할 수 있습니다.

## VS Code로 모듈 탐색하기

물론 이렇게 하는 것의 단점은 큰 파이프라인이 있으면 많은 모듈 파일이 있고, 여러 하위 디렉토리나 온갖 것들로 구성될 수 있다는 것입니다. 이제 다시 한 가지 작은 팁을 드리겠습니다. VS Code 확장 프로그램은 코드베이스를 탐색하고 거기에 있는 코드에 대해 알려주는 데 꽤 좋습니다.

VS Code가 이 프로세스가 무엇인지 이해하고, 마우스를 올리면 간단한 개요를 제공하는 것을 볼 수 있습니다. 소스 코드를 찾아가지 않고도 입력과 출력이 무엇인지 볼 수 있습니다. 이것은 일반적으로 워크플로우에서 사용할 때 가장 중요한 것입니다.

또한 command 키를 누르고 있으면(저는 Mac을 사용합니다), 프로세스 이름을 클릭하면 파일이 바로 직접 열립니다. 가져옵니다. 그래서 실제 파일 경로가 무엇인지 생각하지 않고도 바로 거기로 이동할 수 있습니다. 그리고 이것은 어디서나 작동합니다. 프로세스가 호출되는 곳에서도 할 수 있습니다. 그래서 정말 빠릅니다.

## 4.4. 워크플로우 실행

좋습니다, 파이프라인이 여전히 예상대로 실행되는지 확인해 보겠습니다. 터미널을 불러옵니다. "nextflow run hello modules"를 실행하고, 문제없이 실행되는지 확인해 보겠습니다.

이것의 전체 요점은 파이프라인이 기본적으로 변경되지 않았다는 것이므로, 이전에 실행했을 때와 실제로 어떤 변화도 보이지 않아야 합니다. 여기 출력은 정확히 같아 보이고, 모든 같은 파일이 있는 results 디렉토리를 볼 수 있습니다. 좋습니다. 변화가 없는 것이 좋습니다.

## nf-core/modules에 대한 참고 사항

마무리하기 전에, 모듈과 관련된 협업의 힘에 대해 간단히 언급하고 싶습니다. 이 파일들은 제 저장소에 있으므로, 어떻게 협업할 수 있는지 바로 명확하지 않습니다. 이를 수행할 수 있는 여러 가지 방법이 있지만, 아마도 가장 크고 잘 알려진 예는 nf-core입니다.

nf-core 웹사이트로 가서 resources, 그리고 modules로 가면, nf-core가 거대한 모듈 라이브러리를 가지고 있는 것을 볼 수 있습니다. 제가 볼 때 거의 1700개에 가까운 모듈이 있습니다. 그래서 제가 좋아하는 도구의 이름을 입력하고, 다른 사람이 이미 모듈을 작성했는지 찾아보고, 모든 입력, 출력, 소프트웨어 컨테이너, 모든 정보가 있는 이 미리 작성된 모듈 프로세스를 볼 수 있습니다. 그리고 여기 옆에서 얼마나 많은 서로 다른 nf-core 파이프라인이 이 단일 공유 프로세스를 모두 사용하고 있는지 볼 수 있습니다.

이것은 약간 극단적인 예이지만, 이 코드를 정말로 재사용하고 있는 것을 볼 수 있습니다. 그리고 이것의 GitHub 소스를 클릭하면, 우리가 하고 있는 것과 정확히 같습니다. 파일 안에 큰 프로세스가 있을 뿐입니다.

이제 nf-core 측에서는 이러한 파일을 공유하고 서로 다른 저장소로 가져올 수 있도록 몇 가지 트릭을 사용합니다. 그리고 그것에 대해 더 알고 싶다면, 특히 nf-core를 사용하고 구축하는 것에 관한 과정을 확인해 보세요. 하지만 이 코드 재사용 개념이 얼마나 강력할 수 있는지에 대한 아이디어를 드리고 싶었습니다.

## 마무리

좋습니다, 모듈에 대한 내용은 여기까지입니다. 과정의 짧은 섹션이라고 말씀드렸습니다. 퀴즈를 확인하고, 이해했는지 확인하고, 모든 것이 여전히 제대로 작동하는지 확인하세요. 그리고 다음 비디오에서 뵙겠습니다. 다음은 소프트웨어 컨테이너에 관한 내용입니다. 대단히 감사합니다.
