# भाग 1: Hello World - ट्रांसक्रिप्ट

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI-सहायता प्राप्त अनुवाद - [अधिक जानें और सुधार सुझाएं](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/8X2hHI-9vms?si=F0t9LFYLjAWoyRXj&amp;list=PLPZ8WHdZGxmXiHf8B26oB_fTfoKQdhlik" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "महत्वपूर्ण नोट"

    यह पेज केवल ट्रांसक्रिप्ट दिखाता है। पूर्ण चरण-दर-चरण निर्देशों के लिए, [कोर्स सामग्री](../01_hello_world.md) पर वापस जाएं।

    ट्रांसक्रिप्ट में दिखाए गए सेक्शन नंबर केवल संकेत के उद्देश्य से दिए गए हैं और हो सकता है कि सामग्री में सभी सेक्शन नंबर शामिल न हों।

## स्वागत

नमस्ते, Hello Nextflow के पहले अध्याय में आपका स्वागत है।

छह भागों के इस कोर्स के पहले भाग में, हम Nextflow की बिल्कुल बुनियादी बातों में जाने वाले हैं। हम टर्मिनल में कुछ कमांड चलाकर शुरुआत करेंगे, और फिर हम उन Bash कमांड को लेंगे और देखेंगे कि उन्हें Nextflow स्क्रिप्ट में कैसे बनाया जाता है।

हम उस पहले Nextflow pipeline को चलाने की कोशिश करेंगे, देखेंगे कि Nextflow क्या करता है, यह कहाँ चलता है, यह कौन सी फ़ाइलें बनाता है, और उन फ़ाइलों का उद्देश्य क्या है।

ठीक है, चलिए शुरू करते हैं।

## training.nextflow.io

सबसे पहले, training.nextflow.io पर जाएं। बिल्कुल पहले की तरह, सारी सामग्री यहाँ लिखी गई है, और मैं इसे चरण-दर-चरण करूँगा। मैं प्रशिक्षण के चरणों को करते समय अपनी स्क्रीन दिखाऊंगा, लेकिन जो कुछ भी मैं कह रहा हूँ वह सब प्रशिक्षण सामग्री में है, इसलिए आप इसे अपनी गति से फॉलो कर सकते हैं, और आप सब कुछ वहाँ लिखा हुआ पा सकते हैं।

इस वीडियो में वीडियो सबटाइटल भी सक्षम हैं, इसलिए बेझिझक उन्हें देखें और मैं जो कह रहा हूँ उसे सटीक रूप से ट्रैक करें।

ठीक है, चलिए Hello Nextflow पर जाते हैं। यह वह कोर्स है जिसे हम आज करने जा रहे हैं, और हमने पहले वीडियो में पहले ही ओरिएंटेशन कर लिया है, इसलिए हम सीधे भाग एक में जाएंगे। Hello World.

ठीक है, मैं अब इस प्रशिक्षण सामग्री को छोड़ रहा हूँ और अपने Code Spaces वातावरण में जा रहा हूँ। यह वही है जो हमने पहले वीडियो में सेटअप किया था। उम्मीद है कि आपके अपने सिस्टम में भी कुछ ऐसा ही दिखता होगा। मैं VS Code का उपयोग कर रहा हूँ और मैं प्रशिक्षण सामग्री को देख रहा हूँ और मैंने hello Nextflow डायरेक्टरी में डायरेक्टरी बदल दी है।

## 0. Warmup: Hello World सीधे चलाएं

ठीक है। चलिए कुछ बुनियादी बातों से शुरुआत करते हैं, जो उम्मीद है कि सभी को परिचित लगेंगी। मैं टर्मिनल में बहुत ही बुनियादी कमांड लिखकर शुरुआत करने जा रहा हूँ। यहाँ नीचे मैं 'echo Hello World!"' लिखने जा रहा हूँ, एंटर दबाएं और कोई आश्चर्य नहीं, टर्मिनल वही करता है जो मैं इसे करने के लिए कहता हूँ और वह स्ट्रिंग रिटर्न करता है। Hello world.

ठीक है, फिर मैं उस कमांड को पाने के लिए ऊपर दबाने जा रहा हूँ और इसे थोड़ा और संपादित करूँगा। चलिए इस बार उस आउटपुट को एक फ़ाइल में रीडायरेक्ट करते हैं। मैं इसे output.txt में लिखने जा रहा हूँ और एंटर दबाता हूँ, इस बार टर्मिनल पर कुछ नहीं क्योंकि आउटपुट टर्मिनल पर नहीं आया। यह उस फ़ाइल में चला गया।

फिर मैं 'cat output.txt' करके उस फ़ाइल को पढ़ सकता हूँ, फ़ाइल नाम को ऑटो विस्तारित करने के लिए वहाँ टैब दबाएं और वह रहा। फ़ाइल वहाँ है।

मैं उस फ़ाइल को साइडबार में VS Code के फ़ाइल एक्सप्लोरर में भी देख सकता हूँ। मैं इसे डबल क्लिक कर सकता हूँ और इसे यहाँ खोल सकता हूँ। यदि आप किसी भी चीज़ को क्लिक किए बिना इसे VS Code में खोलना चाहते हैं, तो आप "code" और फिर "output.txt" भी कर सकते हैं और यह वही काम करता है।

बढ़िया। यह पहला चरण है। बहुत सरल।

## 1. Hello World workflow स्टार्टर स्क्रिप्ट की जांच करें

ठीक है। अब हम बिल्कुल वही काम करने जा रहे हैं, लेकिन सीधे टर्मिनल में करने के बजाय Nextflow में।

हम शुरुआत करने के लिए पहली उदाहरण स्क्रिप्ट का उपयोग करने जा रहे हैं, इस फ़ाइल को Hello World कहा जाता है। मैं टर्मिनल में इसे देखने के लिए "ls" कर सकता हूँ, और मैं Mac पर हूँ, इसलिए मैं उस फ़ाइल को खोलने के लिए command क्लिक कर सकता हूँ, या मैं साइडबार में यहाँ डबल क्लिक कर सकता था।

इस फ़ाइल में हम कुछ चीजें देख सकते हैं। बिल्कुल ऊपर, एक हैश स्टेटमेंट है जो कहता है कि यह एक Nextflow फ़ाइल है और इसे इस तरह निष्पादित किया जा सकता है। हल्के भूरे रंग में यहाँ कुछ कमेंट हैं, जो केवल नियमित कोड कमेंट हैं, जो निष्पादन को प्रभावित नहीं करते हैं, और बस हमें स्क्रिप्ट पढ़ने में मदद करते हैं।

और फिर दो मुख्य संरचनाएं हैं। यहाँ एक process है और एक workflow।

Nextflow में processes pipeline के चरण हैं। वे वे भाग हैं जो वास्तव में तर्क करते हैं और प्रोसेसिंग करते हैं।

फिर नीचे workflow इन processes को एक साथ जोड़ता है और workflow के तर्क को नियंत्रित करता है, कि सब कुछ एक दूसरे से कैसे जुड़ता है।

हम एक process को देखकर शुरुआत करने जा रहे हैं। हम एक पल में workflow पर वापस आएंगे।

## 1.2 process की परिभाषा

तो हर process एक कीवर्ड process से शुरू होता है। एक नाम होता है और फिर कुछ कर्ली ब्रैकेट होते हैं और उन कर्ली ब्रैकेट के भीतर सब कुछ उस एकल process का है।

एक process में एक script सेक्शन होना चाहिए, और यहाँ एक मल्टी-लाइन स्ट्रिंग में एक bash स्निपेट होता है, जो कोड का वह हिस्सा है जो वास्तव में कंप्यूट वातावरण में निष्पादित होता है।

हमारे यहाँ एक output स्टेटमेंट भी है, जो Nextflow को बताता है कि script द्वारा कौन सी फ़ाइलें बनने की उम्मीद है। ध्यान दें कि यहाँ output में एक कीवर्ड path है, जो Nextflow को बताता है कि यह एक फ़ाइल है, न कि एक value या स्ट्रिंग।

script ब्लॉक के भीतर, यह केवल एक नियमित bash स्टेटमेंट है, और यह बिल्कुल वैसा ही है जैसा हमने टर्मिनल में लिखा था। हम output.txt नामक फ़ाइल में hello world को echo कर रहे हैं। यह output.txt फिर output परिभाषा द्वारा उठाया जाता है। output परिभाषा वास्तव में कुछ नहीं कर रही है। यह बस Nextflow को बता रही है कि क्या उम्मीद करनी है, और अगर यह फ़ाइल नहीं बनाई गई, तो Nextflow एक एरर थ्रो करेगा।

ध्यान दें कि यह उदाहरण बहुत अच्छा नहीं है क्योंकि हमने यहाँ फ़ाइल नाम हार्डकोड किया है, output.txt और output.txt। अगर इनमें से कोई भी बदला गया, तो यह हमारे workflow में एरर का कारण बनेगा।

इसे variables के साथ करने का एक बेहतर तरीका है, जिसे हम एक मिनट में कवर करेंगे।

## 1.3 workflow की परिभाषा

ठीक है। workflow की ओर बढ़ते हुए, हम देख सकते हैं कि हमारे पास एक कमेंट है और फिर हम sayHello नामक process को चलाते हैं। यह वही कीवर्ड है जो यहाँ ऊपर है। यह जितना सरल हो सकता है एक workflow के बारे में है। हम बस एक single process को बिना किसी variable input के कॉल कर रहे हैं, इसलिए हम इसे किसी और चीज़ से कनेक्ट नहीं कर रहे हैं। इस कोर्स के बाद के भाग में, हम बात करेंगे कि variable inputs का उपयोग करके और channels के साथ चीजों को जोड़कर इसे और अधिक शक्तिशाली कैसे बनाया जाए।

## 2. workflow चलाएं

ठीक है, यह सब कुछ है जो हमें चाहिए। चलिए देखते हैं कि क्या हम इसे चला सकते हैं और देखते हैं कि क्या होता है। मैं बस टर्मिनल को साफ़ करने जा रहा हूँ और फिर मैं "nextflow run" करने जा रहा हूँ, और मैं फ़ाइल नाम कॉल करने जा रहा हूँ, जो hello-world.nf है। एक Nextflow pipeline चलाने के लिए बस इतना ही चाहिए। यह pipeline कोई input नहीं लेता है, इसलिए हमें किसी अन्य arguments की आवश्यकता नहीं है।

चलिए एंटर दबाते हैं और देखते हैं कि क्या होता है।

ठीक है। उम्मीद है कि आपके पास कुछ आउटपुट होना चाहिए, जो इस तरह दिखता है। हमारे पास कुछ जानकारी है जो हमें बताती है कि Nextflow चला और यह किस संस्करण का उपयोग कर रहा था। हमें बताता है कि कौन सी स्क्रिप्ट लॉन्च की गई थी और यह हमें इस विशेष workflow निष्पादन के लिए एक यादृच्छिक रूप से उत्पन्न नाम देता है। इस मामले में, मेरा "gloomy_crick" कहलाया।

हालांकि, इसका सबसे महत्वपूर्ण हिस्सा यह है कि यह हमें बताता है कि pipeline में कौन से चरण चले। आप देख सकते हैं कि हमारा sayHello नामक process चला, और यह एक बार चला और यह सौ प्रतिशत पूर्ण था।

यहाँ यह हिस्सा उस विशेष workflow task के लिए hash है। प्रत्येक process एक या अधिक बार चलता है, और उन निष्पादनों में से प्रत्येक को एक task कहा जाता है।

## 2.2. work डायरेक्टरी में आउटपुट और लॉग खोजें

प्रत्येक task को अपनी अलग डायरेक्टरी मिलती है जहाँ यह चलता है, इसलिए यह workflow के बाकी निष्पादन से अलग है। यह hash work डायरेक्टरी के भीतर फ़ाइल संरचना से मेल खाता है। अगर मैं "tree work" करता हूँ, तो हम a0 देख सकते हैं, और फिर एक छोटे hash का एक लंबा संस्करण, और फिर हमारी output.txt फ़ाइल। आप इसे साइडबार में भी देख सकते हैं।

आप साइडबार में देख सकते हैं कि यहाँ कुछ अतिरिक्त फ़ाइलें हैं। इनके टर्मिनल में न दिखने का कारण यह है कि ये हिडन फ़ाइलें हैं, वे एक डॉट से शुरू होती हैं। और वास्तव में, अगर मैं "tree -a" सभी के लिए और "work" करता हूँ, तो हम उन्हें यहाँ देख सकते हैं।

ये डॉट फ़ाइलें हर एक work डायरेक्टरी में मौजूद होती हैं जो Nextflow बनाता है, और प्रत्येक का थोड़ा अलग कार्य होता है। सबसे पहले .command.begin में Nextflow के लिए कुछ निर्देश शामिल हैं जो task को चलने से पहले सेटअप करते हैं। .command.run वे वास्तविक निर्देश हैं जो Nextflow द्वारा स्वयं निष्पादित किए जाते हैं। फिर .command.sh शायद सबसे दिलचस्प है। यह वह स्क्रिप्ट है जो हमारे process ब्लॉक script से resolve की गई थी।

अगर मैं इसे खोलता हूँ, तो आप देख सकते हैं कि हमारे पास output.txt फ़ाइल में हमारा "echo Hello World" है। यह इस मामले में हमारे process के बिल्कुल समान है, लेकिन अगर हमारे Nextflow कोड के भीतर कोई variables हैं, तो प्रत्येक task का एक अलग .command.sh होगा, और आप देख सकते हैं कि उन variables को कैसे resolve किया गया।

अन्य फ़ाइलें इस बारे में हैं कि task कैसे निष्पादित हुआ। तो .command.err, .log और .out स्टैंडर्ड एरर, स्टैंडर्ड आउटपुट और दोनों संयुक्त हैं। और .exitcode Nextflow को बताता है कि यह task किस exit code के साथ निष्पादित हुआ, चाहे वह सफल हो या नहीं।

अंत में, हमारी output.txt फ़ाइल है और निश्चित रूप से, "Hello World" यह वही है जिसकी हम उम्मीद कर रहे थे और यह वही है जो बनाया गया था।

ठीक है, बढ़िया। यह आपका पहला Nextflow रन था। बधाई हो। यह वास्तव में उतना ही सरल है।

इसके बाद, हम इस बारे में जाएंगे कि इसे थोड़ा और सुविधाजनक तरीके से कैसे किया जाए ताकि हमें हर बार pipeline को चलाने के तरीके में बदलाव करने के लिए कोड को संपादित न करना पड़े।

## 3. workflow निष्पादन प्रबंधित करें

यह डायरेक्टरी संरचना सभी कार्यों को अलग रखने और सब कुछ व्यवस्थित रखने के लिए बहुत अच्छी है, लेकिन निश्चित रूप से, आपकी आउटपुट फ़ाइलों को खोजना बहुत सुविधाजनक नहीं है। आप अपने pipeline के परिणामों को खोजने की कोशिश करते हुए बहुत सारी नेस्टेड डायरेक्टरी के माध्यम से खोदना नहीं चाहते।

## 3.1. आउटपुट प्रकाशित करें

अच्छी खबर यह है कि आपको ऐसा करना नहीं है। work डायरेक्टरी वास्तव में सिर्फ Nextflow के उपयोग के लिए हैं। तो हम जो करने जा रहे हैं वह है Nextflow के लिए publishDir नामक एक फ़ंक्शन का उपयोग करना।

हम अपने workflow पर वापस जाते हैं, process पर जाते हैं। हम यहाँ एक नया स्टेटमेंट जोड़ सकते हैं जिसे एक directive कहा जाता है। यह वह है जो Nextflow इन चीजों को processes के शीर्ष पर कहता है जो यह बढ़ाती हैं कि कार्यक्षमता कैसे काम करती है, और हम जिसका उपयोग करने जा रहे हैं उसे publishDir कहा जाता है।

आप देख सकते हैं कि मैंने यहाँ टाइप करना शुरू किया है और VS Code के लिए Nextflow एक्सटेंशन ने मेरे लिए directive सुझाया है, इसलिए मैं बस एंटर दबा सकता हूँ।

ठीक है। मैं इसके बाद "results" नामक एक डायरेक्टरी बनाने जा रहा हूँ और हम इसे आउटपुट फ़ाइलों को वहाँ कॉपी करने के लिए कहेंगे। तो मैं mode copy कहने जा रहा हूँ। बढ़िया। सेव करने जा रहा हूँ और चलिए workflow को फिर से चलाते हैं।

nextflow run hello-world.nf

यह बिल्कुल उसी तरह चलता है। हालांकि ध्यान दें कि इस बार हमारे पास थोड़ा अलग hash है। हर बार जब आप workflow चलाते हैं तो Nextflow एक अलग hash का उपयोग करेगा। और परिणामस्वरूप हमारे पास work डायरेक्टरी का एक अलग सेट है। क्षेत्र, एक eb कहा जाता है, लेकिन आप देख सकते हैं कि सभी फ़ाइलें समान हैं। हालाँकि, इस बार जो नया है वह यह है कि हमारे पास "results" नामक एक डायरेक्टरी भी है।

यहाँ "results" के भीतर हमारी output फ़ाइल है। यही हमने Nextflow से करने के लिए कहा था। हमने कहा, results फ़ाइलों को "results" नामक डायरेक्टरी में सेव करें और उन्हें वहाँ कॉपी करें। और इसलिए अब यह खोजना बहुत आसान है। यह बस वहाँ है जहाँ हमने workflow लॉन्च किया था और सभी अलग-अलग फ़ाइलों को वहाँ व्यवस्थित किया जा सकता है, हालांकि हम चाहें, इस बात की परवाह किए बिना कि Nextflow ने वास्तविक निष्पादन कहाँ या कैसे चलाया।

ध्यान दें कि publishDir symlinks को संभाल सकता है, जो अच्छा है यदि आप एक shared file system पर काम कर रहे हैं और आप स्पेस बचाना चाहते हैं। और साथ ही आपको एक process द्वारा बनाई गई सभी फ़ाइलों को एक output के रूप में परिभाषित करने की आवश्यकता नहीं है।

Nextflow केवल उन चीजों को कॉपी करेगा जो इस output ब्लॉक में परिभाषित हैं। इसलिए यदि आपके पास चरण द्वारा बनाई गई मध्यवर्ती फ़ाइलें हैं, जो इस process के downstream की आवश्यकता नहीं हैं, तो आप उन्हें output में परिभाषित नहीं करते हैं और वे publishDir में नहीं दिखाई देंगी। तो यह एक pipeline से आपकी आउटपुट फ़ाइलों को साफ़ रखने और कार्यस्थल समाप्त होने के बाद मध्यवर्ती फ़ाइलों को आसानी से हटाने का एक तरीका है।

एक त्वरित नोट यहाँ। कुछ नया Nextflow syntax आ रहा है जिसे workflow output definitions कहा जाता है, जो अंततः publishDir को बदल देगा। यह हमें workflow level पर workflow ब्लॉक में नीचे workflow से सभी आउटपुट परिभाषित करने का एक तरीका देता है। यह Nextflow docs में वर्णित है यदि आप इसे आज़माना चाहते हैं। लेकिन अभी के लिए, publishDir कुछ समय के लिए रहेगा, इसलिए 2025 के लिए अभी भी प्रशिक्षण में है।

## 3.2. -resume के साथ एक workflow को फिर से लॉन्च करें

ठीक है। मैंने उल्लेख किया कि work डायरेक्टरी में अब हर बार जब हम workflow चलाते हैं तो एक अलग hash के साथ दो सेट परिणाम हैं। यह अच्छा है। हालाँकि, कभी-कभी हम हर बार चरणों को फिर से गणना नहीं करना चाहते हैं यदि हमें इसकी आवश्यकता नहीं है।

शायद आप अपने workflow को पुनरावृत्त रूप से बना रहे हैं और आप चरणों को जोड़ रहे हैं और आप चाहते हैं कि पहले चरण केवल cached versions का पुन: उपयोग करें। या शायद आपके कंप्यूट सिस्टम पर आपके workflow के बीच में कुछ गलत हो गया और आप चाहते हैं कि यह वहीं से आगे बढ़े जहाँ यह छूट गया था, लेकिन उन चरणों को छोड़ दें जो इसने पहले ही पूरा कर लिए थे।

Nextflow में इसके लिए अंतर्निहित कार्यक्षमता है जिसे resume कहा जाता है। चलिए इसे आज़माते हैं। तो सबसे पहले, मैं बस work डायरेक्टरी पर एक नज़र डालने जा रहा हूँ ताकि हम याद रख सकें कि वहाँ क्या था।

और फिर मैं "nextflow run hello-world.nf" करने जा रहा हूँ और मैं यहाँ एक single कमांड जोड़ने जा रहा हूँ, "-resume"।

ध्यान दें, single dash, यह वास्तव में महत्वपूर्ण है। मैं इसे चलाने जा रहा हूँ और आउटपुट मूल रूप से बिल्कुल समान दिखने वाला है, कुछ छोटे अंतरों के साथ।

ध्यान दें यहाँ यह भूरे रंग में "cached" कहता है। इसका मतलब है कि Nextflow ने task नहीं चलाया। इस बार इसे कुछ ऐसा मिला जो आवश्यकताओं से मेल खाता था और इसने चरण को फिर से चलाने के बजाय सीधे उन आउटपुट का पुन: उपयोग किया।

और निश्चित रूप से, यदि आप यहाँ hash को देखते हैं, तो आप देख सकते हैं कि यह मौजूदा hash से मेल खाता है जो हमारे पास पिछले रन से था।

## 3.3. पुरानी work डायरेक्टरी हटाएं

ठीक है। लेकिन यदि आप पुनरावृत्त रूप से विकसित कर रहे हैं, तो आप इन workflow फ़ाइलों में से बहुत सारे बनाने जा रहे हैं। यह एक समस्या हो सकती है यदि आपकी स्पेस कम हो सकती है।

Nextflow कुछ सहायक कमांड के साथ इन work डायरेक्टरी को साफ़ करने में हमारी मदद कर सकता है। अगर मैं "nextflow log" करता हूँ। यह मुझे इस डायरेक्टरी में किए गए सभी विभिन्न workflow runs की एक सूची देगा, और उनके रन नाम यहाँ हैं। आप gloomy quick देख सकते हैं, जो पहला था जो हमने चलाया, और फिर ये दो नए।

अब हम उस नाम को ले सकते हैं और "nextflow clean" कमांड के साथ उनका उपयोग कर सकते हैं। मैं एक single रन नाम निर्दिष्ट कर सकता हूँ। या इससे भी बेहतर, मैं Nextflow को "-before" के साथ एकल workflow नाम से पहले की हर चीज़ को हटाने के लिए कह सकता हूँ, और मैं "stupefied_shaw" में डालने जा रहा हूँ। यह मेरा सबसे हालिया रन था, "-n"।

"-n" कमांड ने Nextflow को वास्तव में कुछ भी हटाए बिना इसे dry run के रूप में करने के लिए कहा, और यह हमें बताता है कि कौन सी hash डायरेक्टरी हटा दी गई होंगी। निश्चित रूप से, यह पहले निष्पादन से बस वही है। दोनों दूसरे निष्पादन एक ही hash डायरेक्टरी का उपयोग करते हैं।

मैं इसे फिर से चलाने जा रहा हूँ, लेकिन अब dry run के लिए "-n" के बजाय, मैं force के लिए "-f" करने जा रहा हूँ और इसने उस hash डायरेक्टरी को हटा दिया है। अब अगर मैं "tree work" करता हूँ, तो हम देख सकते हैं, हमारे पास बस यह आउटपुट फ़ाइल बची है।

बढ़िया। तो हमने वहाँ बहुत सारी डिस्क स्पेस साफ़ की है।

work डायरेक्टरी हटाते समय ध्यान देने योग्य कुछ बातें, यदि आप अपनी results डायरेक्टरी में सामान को symlink करते हैं, तो उन symlink स्रोतों को अब हटा दिया जाएगा और आपके परिणाम हमेशा के लिए चले जाएंगे। इसलिए copy mode का उपयोग करना एक सुरक्षित काम है, और आम तौर पर हम जो अनुशंसा करते हैं।

दूसरे, Nextflow की resume कार्यक्षमता इन work डायरेक्टरी पर निर्भर करती है। इसलिए यदि आप उन्हें हटाते हैं और आप Nextflow को फिर से चलाते हैं, तो resume कार्यक्षमता अब काम नहीं करेगी। इसलिए यह आप पर निर्भर है कि आप ट्रैक करें कि आपको किन चीजों की आवश्यकता हो सकती है या नहीं, और केवल तभी चीजों को हटाएं जब आप सुनिश्चित हों कि ऐसा करना सुरक्षित है।

दूसरी चीज़ जो हम कर सकते हैं वह है कि हम पूरी work डायरेक्टरी को हटा सकते हैं यदि हमने अपना workflow रन समाप्त कर लिया है और हम सुनिश्चित हैं कि हमें इसकी अब आवश्यकता नहीं है।

तो मैं "rm -r work" कर सकता हूँ। मुझे पता है कि वहाँ कुछ भी महत्वपूर्ण नहीं था। मेरे पास मेरे परिणाम हैं जिनकी मुझे results डायरेक्टरी में परवाह है जहाँ हमने उन्हें कॉपी किया। और इसलिए work डायरेक्टरी को हटाना सुरक्षित था। यह आप पर निर्भर है कि आप इनमें से किस दृष्टिकोण का उपयोग करते हैं।

## 4. command line पर पास किए गए variable input का उपयोग करें

ठीक है, आगे क्या है? मैंने उल्लेख किया कि हमने अपने workflow स्क्रिप्ट में यहाँ कुछ मूल्यों को हार्डकोड किया था, output.txt फ़ाइल, और कि इसे करने का एक बेहतर तरीका हो सकता है।

चलिए इस पर शुरुआत करते हैं। हम जो करने जा रहे हैं वह तीन चीजें हैं। हम process में एक नया input जोड़ने जा रहे हैं। हम process script को बताने जा रहे हैं कि उस input का उपयोग कैसे करें, और फिर हम इसे workflow में वायर करने जा रहे हैं ताकि हम इसे Nextflow चलाते समय command line flag के साथ गतिशील रूप से उपयोग कर सकें।

तो सबसे पहले। चलिए यहाँ एक input ब्लॉक जोड़ते हैं। output की तरह ही। यह process के लिए एक नया सेक्शन है, और मैं कहने जा रहा हूँ, "val greeting"।

यहाँ ध्यान दें, मैं "val" कह रहा हूँ, जो कहता है कि यह एक variable है, न कि path।

फिर मैं script में नीचे जा सकता हूँ और फिर मैं इस हार्डकोड किए गए टेक्स्ट को यहाँ निकाल सकता हूँ और $greeting कर सकता हूँ। यह किसी भी अन्य प्रोग्रामिंग भाषा की तरह काम करता है। हम यहाँ एक variable को परिभाषित कर रहे हैं और हम इसे इस script ब्लॉक के भीतर संदर्भित कर रहे हैं। जब Nextflow इस process को चलाता है, तो variable को interpolate किया जाएगा। और जब हम उस .command.sh फ़ाइल को देखने जाते हैं, तो हम वहाँ वास्तविक हार्ड कोडेड स्ट्रिंग देखेंगे।

## 4.1.3. एक CLI पैरामीटर सेटअप करें और इसे process कॉल में input के रूप में प्रदान करें

ठीक है, लेकिन हम variable कहाँ प्रदान करते हैं? इसके बाद हम workflow सेक्शन में जाते हैं, और आप देख सकते हैं कि यहाँ एक्सटेंशन कह रहा है, हम अब एक input की उम्मीद करते हैं, और इसने मुझे एक चेतावनी दी है।

अब, सबसे सरल चीज़ जो हम कर सकते हैं वह है इसे हार्डकोड करना। मैं "Hello World" लिख सकता था और process को वह स्ट्रिंग input प्रदान कर सकता था। लेकिन फिर से, यह वास्तव में किसी भी समस्या का समाधान नहीं करेगा। हमें अभी भी हर बार कुछ बदलना चाहते हैं तो pipeline कोड को वापस जाना और संपादित करना होगा, जो अच्छा नहीं है।

अच्छी खबर यह है कि Nextflow में command line arguments को संभालने के लिए एक अंतर्निहित सिस्टम है जिसे parameters कहा जाता है। तो इसके बजाय, मैं इन विशेष variables में से एक का उपयोग कर सकता हूँ जिसे params कहा जाता है और मैं इसे जो चाहूं कह सकता हूँ, लेकिन मैं greeting कहने जा रहा हूँ ताकि यह workflow logic से मेल खाए।

सेव करें और चलिए देखते हैं कि हम इसके साथ क्या कर सकते हैं।

तो अगर मैं टर्मिनल पर वापस जाता हूँ। तो हम "nextflow run hello-world.nf" करते हैं। बिल्कुल पहले की तरह, लेकिन मुख्य अंतर यह है कि हम --greeting करते हैं

ध्यान दें, यहाँ दो dashes हैं क्योंकि यह एक पैरामीटर है। जब हमने पहले workflow को resume किया, तो वह एक single dash था। ऐसा इसलिए है क्योंकि resume एक कोर Nextflow विकल्प है, और यह एक पैरामीटर है जो हमारे pipeline के लिए विशिष्ट है।

दोनों को मिक्स न करें। ऐसा करना आसान है। यदि आपने --resume के बजाय सिर्फ एक dash किया, तो वह "params.resume" होगा, जो कुछ नहीं करेगा। इसी तरह, यदि आपने यहाँ एक single dash किया, तो Nextflow इसे एक key argument के रूप में नहीं पहचानेगा।

तो यह --greeting है, जो parameters greeting से मेल खाता है।

अब मैं जो चाहूं टेक्स्ट का अनुसरण कर सकता हूँ। तो मैं इस समय स्वीडन में हूँ, इसलिए मैं कहने जा रहा हूँ, "Hej världen"।

तो चलिए इसे चलाते हैं, देखते हैं कि क्या होता है, सच्चाई का क्षण।

ठीक है, तो आप देख सकते हैं कि process फिर से चला, बिल्कुल पहले की तरह, एक single निष्पादन के साथ sayHello।

यह publishDir "results" डायरेक्टरी में फ़ाइल को अधिलेखित कर देगा। और इसलिए फ़ाइलों को फिर से चलाते समय सावधान रहें क्योंकि published air में चीजें अधिलेखित हो जाएंगी।

अब मैं "code results/output.txt" कर सकता हूँ, और निश्चित रूप से, हमारा आउटपुट अपडेट हो गया है और अब "Hej världen" कहता है।

## 4.2. command line पैरामीटर के लिए डिफ़ॉल्ट मान का उपयोग करें

ठीक है, यह बढ़िया है। लेकिन अब समस्या यह है कि हमारा workflow हमेशा इस पैरामीटर को परिभाषित करने पर निर्भर करता है, और समझदार डिफ़ॉल्ट होना अच्छा है ताकि चीजें आपके workflow के लिए समझदार तरीके से चलें जब तक कि आप डिफ़ॉल्ट को ओवरराइड न करें।

तो हम ऐसा करने का तरीका यह है कि हम अपने workflow स्क्रिप्ट में पैरामीटर के लिए एक डिफ़ॉल्ट मान सेट करें।

तो अगर मैं अपनी hello-world.nf फ़ाइल पर वापस जाता हूँ, तो मैं workflow के ठीक ऊपर स्क्रिप्ट में जा सकता हूँ, "params.greeting" टाइप कर सकता हूँ और इसे किसी अन्य variable की तरह परिभाषित कर सकता हूँ। तो चलिए यहाँ एक स्ट्रिंग डालते हैं और चलिए कहते हैं "Holà mundo!"

अब इस पैरामीटर को एक डिफ़ॉल्ट परिभाषित किया गया है, जिसका उपयोग यहाँ किया जाएगा, या हम अभी भी इसे command line पर --greeting के साथ ओवरराइड कर सकते हैं, बिल्कुल पहले की तरह।

तो चलिए देखते हैं कि यह काम करता है। "nextflow run hello-world.nf"

इस बार कोई command-line arguments नहीं, और जाँचें कि क्या इसने सही काम किया।

"code results/output.txt"। और यह रहा। हमें अपना डिफ़ॉल्ट मिला।

ठीक है, चलिए फिर से कोशिश करते हैं, बस जाँचें कि मैं आपको कोई झूठ नहीं बता रहा हूँ। चलिए इसे फिर से चलाते हैं, लेकिन --greeting करते हैं, और प्रशिक्षण सामग्री से उदाहरण का उपयोग करते हैं, चलिए कहते हैं "Konnichiwa!"

workflow को फिर से चलाता है, और निश्चित रूप से, शीर्ष पर हमारी आउटपुट फ़ाइल बस नए मान के साथ अपडेट की गई है जो हमने command line पर प्रदान किया था।

बढ़िया। किसी भी Nextflow workflow को लिखने के लिए यह एक वास्तविक केंद्रीय पहलू है। अपने pipeline कोड में समझदार डिफ़ॉल्ट परिभाषित करना, लेकिन टर्मिनल पर command line arguments रखकर अंतिम उपयोगकर्ता के लिए कॉन्फ़िगर करना बहुत आसान बनाना।

ध्यान दें कि अंतिम उपयोगकर्ता कई अलग-अलग स्थानों पर config को अधिलेखित कर सकता है। आपके होम डायरेक्टरी में एक config फ़ाइल हो सकती है, जो आपके द्वारा किए गए हर एक Nextflow रन पर लागू होती है। आपके लॉन्च डायरेक्टरी में एक config फ़ाइल हो सकती है। आपके pipeline डायरेक्टरी में एक config फ़ाइल हो सकती है। ये सभी विभिन्न config स्थान एक विशिष्ट क्रम में लोड किए जाते हैं, जो Nextflow docs में वर्णित है।

ठीक है, यह सेक्शन एक का अंत है। हमारे पास एक process और एक workflow के साथ Nextflow में हमारी पहली workflow स्क्रिप्ट थी। हमने inputs, outputs, scripts और publishing को देखा है, और यह कि कैसे पैरामीटर और एक input channel को हमारे process में वायर करें।

बधाई हो, Nextflow कोड लिखने की ओर आपका पहला कदम पूरा हो गया है।

थोड़ा ब्रेक लें और मैं आपको कुछ मिनटों में अध्याय दो के लिए वापस मिलूंगा।

[अगला वीडियो ट्रांसक्रिप्ट :octicons-arrow-right-24:](02_hello_channels.md)
