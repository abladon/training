# भाग 1: Hello World - वीडियो ट्रांसक्रिप्ट

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI-सहायता प्राप्त अनुवाद - [अधिक जानें और सुधार सुझाएं](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/tOukLxWCHiA?si=F0t9LFYLjAWoyRXj&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "महत्वपूर्ण नोट"

    यह पेज केवल ट्रांसक्रिप्ट दिखाता है। पूर्ण चरण-दर-चरण निर्देशों के लिए, [कोर्स सामग्री](../01_hello_world.md) पर वापस जाओ।

    ट्रांसक्रिप्ट में दिखाए गए सेक्शन नंबर केवल संकेत के लिए हैं और सामग्री के सभी सेक्शन नंबर शामिल नहीं हो सकते।

## स्वागत

नमस्ते, और वापस स्वागत है।

तुम अब "Hello Nextflow" कोर्स के पार्ट वन में हो जिसका नाम "Hello World" है। इस चैप्टर में, हम Nextflow की बुनियादी बातों की समझ बनाने जा रहे हैं।

उम्मीद है कि अब तुम Codespaces में या किसी समान वातावरण में VS Code के साथ सेट अप हो, और तुम्हारे पास Explorer में workspace में Hello Nextflow फ़ोल्डर है, जिसमें ये सभी अलग-अलग फ़ाइलें हैं।

हम शुरू करेंगे टर्मिनल में Bash का उपयोग करके कुछ बहुत बुनियादी चीजें करके, और फिर देखेंगे कि क्या हम Nextflow में वही चीजें कर सकते हैं ताकि तुम्हें सिंटैक्स का अंदाज़ा मिले।

## 0. वार्मअप

तो आओ सच में सरल शुरू करें। बस "echo" से शुरू करते हैं, टर्मिनल में कुछ प्रिंट करने के लिए। "Hello World"। मैं enter दबाता हूं और वो टर्मिनल में जाता है। Hello World। उम्मीद है कि ये इस कोर्स को देख रहे किसी को भी आश्चर्यचकित नहीं करेगा।

ठीक है, चलो इसके साथ कुछ करते हैं। बस इसे टर्मिनल में प्रिंट करने के बजाय, चलो इसे एक फ़ाइल में लिखते हैं। मैं अपने कीबोर्ड के up कर्सर को दबाने वाला हूं, जो Bash हिस्ट्री में घूमता है, तो मुझे मेरा आखिरी कमांड मिलता है, और मैं इसके अंत में छोटा greater than सिंबल जोड़ूंगा, जो इस कमांड से आउटपुट को एक फ़ाइल में रीडायरेक्ट करता है, और मैं इसे output.txt कहूंगा।

फिर से enter, उस कमांड को चलाने के लिए, इस बार टर्मिनल में कुछ नहीं, लेकिन हम बाईं ओर देख सकते हैं, नई फ़ाइल यहां दिखाई दी है, जिसका नाम output.txt है।

हम इसे टर्मिनल में cat जैसी चीज़ से देख सकते हैं। तो cat output.txt और सच में ये "Hello World" कहता है। हम इसे डबल क्लिक भी कर सकते हैं और ये VS Code में code editor में खुल जाता है।

## 1.1. कोड की जांच करो

ठीक है। मैंने कहा था कि ये सरल था। आगे क्या है? चलो इस प्रोसेस को फिर से करने की कोशिश करते हैं, लेकिन इस बार, चलो इसे Nextflow के अंदर करते हैं।

जैसा कि मैंने कहा, इस कोर्स के सभी अलग-अलग चैप्टर एक स्क्रिप्ट से शुरू होते हैं और इसे Hello World कहा जाता है। तो मैं Hello World ढूंढने वाला हूं। जब मैं इसे single click करता हूं तो ये प्रीव्यू करता है, मैं इसे editor में खोलने के लिए double click करने वाला हूं। और मैं बस जल्दी से टर्मिनल से छुटकारा पा लूंगा।

अब ये बहुत सरल स्क्रिप्ट है, तो जितना सरल हो सकता है। ये केवल 22 लाइन लंबी है, और ये मूल रूप से वही चीज़ करती है। वास्तव में, इसमें से कुछ परिचित होना चाहिए। हम अपना bash कमांड देख सकते हैं जो एक फ़ाइल में रीडायरेक्ट हो रहा है।

ठीक है। और क्या? साथ ही, इस फ़ाइल में, हम Nextflow की कुछ मुख्य अवधारणाओं को देखना शुरू कर सकते हैं। यहां लाल रंग में एक प्रोसेस है और एक वर्कफ़्लो। ये Nextflow में विशेष कीवर्ड और विशेष शब्दावली हैं।

## 1.1.1. प्रोसेस परिभाषा

एक वर्कफ़्लो के भीतर अलग-अलग प्रोसेस तुम्हारे वर्कफ़्लो की विभिन्न तार्किक इकाइयों को wrap करते हैं। हर प्रोसेस एक चीज़ करता है।

जब हम इसे चलाते हैं, तो ये एक टास्क या कई टास्क बनाता है, जो पाइपलाइन के वास्तविक चरण हैं। सभी प्रोसेस फिर एक workflow ब्लॉक के भीतर orchestrate किए जाते हैं, जिसे हम नीचे देखते हैं, और इस मामले में, बस उस एक प्रोसेस को चलाता है।

प्रोसेस का नाम इस कीवर्ड के बाद आता है, और ये मूल रूप से कुछ भी हो सकता है। और फिर प्रोसेस की contents इन curly brackets के भीतर हैं।

प्रोसेस के लिए वास्तव में केवल एक आवश्यकता है, और वो ये है कि इसमें किसी प्रकार का script या exec ब्लॉक शामिल हो। ये यहां triple quotes में है, और ये bash स्क्रिप्ट है जो working directory में लिखी जाती है जब हम पाइपलाइन चलाते हैं और वास्तव में तुम्हारे कंप्यूटर या सर्वर पर चलता है।

ये आमतौर पर bash है, लेकिन तुम यहां शीर्ष पर एक अलग hash bang भी डाल सकते हो, और ये एक Python स्क्रिप्ट या R स्क्रिप्ट हो सकती है। कोई फर्क नहीं पड़ता। इस स्क्रिप्ट में जो कुछ भी है वो execute होगा।

एक और चीज़ है जो हमने इस प्रोसेस में जोड़ी है, वो है output declaration। ये Nextflow को बताता है कि ये प्रोसेस output.txt नाम की एक आउटपुट फ़ाइल की उम्मीद कर रहा है। ये कहता है कि ये एक path है, तो इसे एक फ़ाइल की तरह handle किया जाना चाहिए, न कि यदि ये val था, तो ये कहता कि ये एक वेरिएबल या value की तरह है।

ध्यान दो कि ये इस फ़ाइल को create नहीं कर रहा है। ये वास्तव में इसे generate नहीं कर रहा है। वो यहां स्क्रिप्ट द्वारा किया जाता है। ये बस Nextflow को बता रहा है कि इस filename के साथ एक आउटपुट फ़ाइल की उम्मीद करे।

## 1.1.2. वर्कफ़्लो परिभाषा

ठीक है। और फिर नीचे हमारे पास यहां एक workflow है, और फिर से, हमारे पास एक declaration है। इसे Main कहा जाता है। ये workflow का equivalent है script ब्लॉक का, अगर तुम चाहो तो। ये workflow का वो हिस्सा है जो कुछ करता है। और इस मामले में, हम कह रहे हैं, sayHello नाम के प्रोसेस को call करो।

सामान्य रूप से, निश्चित रूप से, तुम्हारी पाइपलाइन इससे बहुत अधिक जटिल दिखेगी। तुम्हारे पास शायद एक से अधिक प्रोसेस होंगे, और तुम उनके बीच डेटा फ़्लो को orchestrate करने के लिए चैनल का उपयोग करोगे। हम इस कोर्स के अगले भागों में उस पर आने वाले हैं, लेकिन अभी के लिए, ये काफी है। ये एक valid पाइपलाइन है, जो काम करनी चाहिए।

मैं VS Code में preview DAG पर भी क्लिक कर सकता हूं। DAG या DAG पाइपलाइन में डेटा फ़्लो structure का एक प्रतिनिधित्व है, और हम इसे side पर mermaid diagram के रूप में rendered देख सकते हैं। इस मामले में ये बहुत सरल है। एक box है, जो workflow है और एक प्रोसेस है, जिसे sayHello कहा जाता है, लेकिन वो जैसे-जैसे हम आगे बढ़ते हैं अधिक दिलचस्प दिख सकता है।

## 1.2. वर्कफ़्लो चलाओ

ठीक है, चलो इस workflow को चलाने की कोशिश करते हैं और देखते हैं कि क्या होता है।

मैं नीचे फिर से टर्मिनल लाने वाला हूं, आउटपुट clear करूंगा, और मैं Nextflow Run टाइप करने वाला हूं। और फिर मैं बस स्क्रिप्ट का नाम टाइप करूंगा, जो hello-world.nf है। और मैं enter दबाऊंगा।

ठीक है, शीर्ष पर कुछ standard चीजें हैं, जो हमें बताती हैं कि Nextflow चला और कौन सा version चल रहा था और स्क्रिप्ट का नाम और सब कुछ था।

और वास्तव में महत्वपूर्ण चीज़ जो हम यहां ढूंढ रहे हैं वो _यहां_ है, जो विभिन्न टास्क का एक सारांश है जो execute किए गए थे।

यदि तुम्हारा ऐसा दिखता है छोटे हरे टिक के साथ, तो बधाई। तुमने अभी-अभी अपनी पहली पाइपलाइन चलाई। शानदार।

ये हमें यहां उस प्रोसेस का नाम बताता है, जो चला, जिसे Say Hello कहा जाता था, और इसने हमें बताया कि ये एक बार चला और वो सफल रहा। ये जैसे-जैसे तुम आगे बढ़ते हो update होता है, तो जब तुम एक बड़ी पाइपलाइन चला रहे हो, तुम यहां प्रगति का प्रतिनिधित्व देखोगे। लेकिन क्योंकि ये इतना छोटा है, ये मूल रूप से तुरंत चलता है।

## 1.2.2. work directory में आउटपुट और logs खोजो

अब जब तुम एक Nextflow पाइपलाइन चलाते हो, इनमें से प्रत्येक प्रोसेस एक साथ जुड़ा होता है, और हर प्रोसेस, जैसा कि मैंने पहले कहा, टास्क generate कर सकता है एक या कई। तो इस मामले में, हमारे पास इस प्रोसेस से एक single टास्क था। ये बस एक बार चला और वो इस टास्क _hash_ के तहत किया गया था।

Nextflow सीधे तुम्हारी working directory में फ़ाइलों के साथ deal नहीं करता है, ये work नाम का एक विशेष फ़ोल्डर बनाता है। और यदि मैं "ls" करता हूं, तो हम देखेंगे कि ये यहां दिखाई दिया है: _work_, और इसके भीतर हर एक टास्क के लिए sub directories हैं जो चलते हैं। और वो इस hash से मेल खाता है। तो तुम देख सकते हो यदि मैं "ls work/c4" पर जाता हूं, और फिर ये truncate है, लेकिन ये 203 से शुरू होता है, और वो working directory है, जो इस प्रोसेस द्वारा बनाई गई थी जब हमने पाइपलाइन चलाई। और तुम इसे side पर भी देख सकते हो।

जब मैं उन फ़ाइलों को list करता हूं, तो तुम output.txt फ़ाइल देख सकते हो जो generate हुई थी। तुम इसे यहां भी देख सकते हो। और कुछ hidden फ़ाइलें हैं, जो मेरे regular "ls" के साथ नहीं दिख रही हैं।

यदि मैं output.txt पर क्लिक करता हूं, तो सच में, हमारे पास हमारा आउटपुट है। शानदार। तो पाइपलाइन काम कर गई।

ये एक लाइन की bash स्क्रिप्ट चलाने के लिए काफी boilerplate लग सकता है, लेकिन जैसे-जैसे हमारे प्रोसेस अधिक जटिल हो जाते हैं, ये अधिक समझ में आएगा। और Nextflow के साथ ये work directory और ये फ़ाइलें, जो बनाई गई हैं, वास्तव में Nextflow को इतना शक्तिशाली बनाने की रीढ़ हैं।

प्रत्येक टास्क, पाइपलाइन का प्रत्येक तत्व हर दूसरे टास्क से isolated है। ये reproducible है। वे एक दूसरे के साथ conflict नहीं करते हैं, और सब कुछ parallel में चल सकता है। वास्तव में ये एक बहुत अच्छा तरीका है जब तुम इसकी आदत डाल लेते हो क्योंकि इस isolation की वजह से तुम अंदर जा सकते हो और देख सकते हो कि एक single टास्क के लिए वास्तव में क्या हुआ और debug कर सकते हो।

चलो work directory में इन अन्य फ़ाइलों पर एक quick नज़र डालते हैं। ऊपर से नीचे तक, हमारे पास _.command.begin_ नाम की एक फ़ाइल है। ये खाली है। ये बस Nextflow द्वारा बनाई गई एक sentinel फ़ाइल है जो कहती है, ठीक है, मैं टास्क शुरू कर रहा हूं। वहां कुछ भी दिलचस्प नहीं है।

फिर _.command.error_, _.command.log_ और _.command.out_ हैं। ये सभी bash कमांड या इस स्क्रिप्ट से आउटपुट हैं जो चली। ये standard error है। ये standard out है, और ये वे दोनों combined हैं जैसे वे बाहर आए। तो तुम्हें तार्किक क्रम मिलता है।

ठीक है, वे सभी इसके लिए भी खाली थे, तो बहुत दिलचस्प नहीं, लेकिन चीजें अधिक दिलचस्प हो जाती हैं जब तुम _.command.run_ पर पहुंचते हो।

ये आमतौर पर एक बहुत लंबी स्क्रिप्ट होती है। और ये वो है जो Nextflow वास्तव में execute करता है। यदि तुम यहां अंदर जाते हो, तो तुम Nextflow के सभी आंतरिक logic को देखना शुरू करोगे और देखोगे कि ये क्या कर रहा है और कैसे ये तुम्हारे प्रोसेस को execute कर रहा है। ये इस बात पर निर्भर करेगा कि तुम कहां चला रहे हो, क्या हम locally चला रहे हैं या इसे SLURM में एक job के रूप में submit कर रहे हैं, जिस स्थिति में हमारे पास शीर्ष पर SLURM headers होंगे। ये सभी अलग-अलग setups।

आम तौर पर, तुम्हें वास्तव में कभी भी इस फ़ाइल को देखने की ज़रूरत नहीं है। ये Nextflow द्वारा autogenerate होती है और वास्तव में तुम्हारी पाइपलाइन के लिए विशिष्ट कुछ भी नहीं है, जो इसमें है। लेकिन वो वास्तव में जो चल रहा है उसका core है।

अगली वाली बहुत अधिक दिलचस्प है। _.command.sh_ वो generated स्क्रिप्ट है, जो तुम्हारे प्रोसेस से आई, और यहां तुम देख सकते हो कि Nextflow ने Bash header जोड़ा, और फिर इसने हमारे कमांड को execute किया, जो हमारे script ब्लॉक में था।

और वो सब _.command.run_ फ़ाइल करती है बस इस _.command.sh_ फ़ाइल को चलाना है।

ये वास्तव में एक useful है, जो आमतौर पर सबसे ज्यादा देखी जाती है जब तुम किसी चीज़ को debug करने की कोशिश कर रहे हो और check कर रहे हो कि तुम्हारी Nextflow पाइपलाइन का logic वो कर रहा है जो तुम इसे करने की उम्मीद करते हो।

अंत में, हमारे पास _.exitcode_ नाम की एक फ़ाइल है, और ये बस एक टास्क से exit code को capture करती है, जो इस मामले में successful था। तो exit code zero था।

यदि कुछ गलत हो जाता है, तुम memory खत्म हो जाती है या कुछ और और ये fail हो जाता है, तो ये समझने के लिए बहुत उपयोगी है कि क्या गलत हुआ।

## 1.3. वर्कफ़्लो फिर से चलाओ

work directories के बारे में समझने के लिए एक और चीज़ है कि यदि मैं इस पाइपलाइन को बार-बार चलाता रहता हूं, तो यदि मैं _"nextflow run hello-world.nf"_ करता हूं, तो ये बिल्कुल वही चीज़ करने वाली है, लेकिन इस बार इसके पास एक नया task id होगा। तुम देख सकते हो कि ये hash यहां अलग है, और अब यदि मैं work में देखता हूं, तो दो hash directories हैं। और ये फिर से, एक दूसरे से अलग हैं।

तो हर बार जब तुम एक Nextflow workflow चलाते हो, जब तक तुम resume का उपयोग नहीं करते जो cache का उपयोग करता है, हम बाद में touch करेंगे, ये उन प्रोसेस को नई work directories में फिर से चलाने वाला है, जो एक दूसरे से अलग हैं। तुम्हें कोई फ़ाइल नाम collision नहीं मिलेगा, तुम्हें उस तरह की कोई समस्या नहीं होगी। सब कुछ isolated और clean है।

और यदि हम इस directory में जाते हैं, तो तुम सभी same फ़ाइलें और same _output.txt_ देख सकते हो, जो scratch से recreate किया गया है।

## 2. आउटपुट publish करो

ठीक है, वो Nextflow के लिए अपने आप में बढ़िया है, जबकि ये तुम्हारी पाइपलाइन चला रहा है ताकि सभी चीजें एक दूसरे से अलग हों और clean हों और manage की जा सकें।

लेकिन यदि तुम एक व्यक्ति हो जो अपने results को explore करने की कोशिश कर रहा है तो ये बहुत उपयोगी नहीं है। तुम वास्तव में अपनी result फ़ाइलों को खोजने की कोशिश में हजारों और हजारों अलग-अलग work directories के माध्यम से खुदाई नहीं करना चाहते। और तुम्हें वास्तव में ऐसा करने के लिए नहीं कहा जाता है। work directories का उद्देश्य तुम्हारी फ़ाइलों के बनाए जाने की final state नहीं है।

हम ऐसा अपनी फ़ाइलों को publish करके करते हैं।

## 2.1.1. sayHello प्रोसेस का आउटपुट declare करो

तो यदि मैं अपनी स्क्रिप्ट पर वापस जाता हूं, तो हम अपने workflow ब्लॉक में यहां काम करने वाले हैं। हम इसे बताने जा रहे हैं कि किन फ़ाइलों की उम्मीद करनी है, कौन सी फ़ाइलें हमें परवाह है, और फिर हम नीचे output ब्लॉक नाम का एक नया ब्लॉक बनाने जा रहे हैं।

ये नया syntax है, जो syntax parser के साथ आया और Nextflow के version 26.04 में default है। तो यदि तुमने पहले Nextflow का थोड़ा उपयोग किया है, तो ये उन चीजों में से एक है जो नई है।

तो हमारे पास main ब्लॉक है, और अगला मैं _publish_ कहने वाला हूं और मैं Nextflow को बताऊंगा कि publishing से क्या expect करना है। हम इसे _first_output_ कहने वाले हैं, और हम इसे _sayHello.out_ कहने वाले हैं।

मैंने गलती से वहां एक typo बना दिया, लेकिन ये Nextflow VS Code extension की कुछ features को भी इंगित करने का एक अच्छा अवसर है। तुम देख सकते हो कि तुरंत इसने मुझे इसके नीचे एक छोटी लहरदार लाल रेखा दी जो कहती है कि कुछ गलत है। और यदि मैं इस पर hover करता हूं, तो ये मुझे बताएगा कि ये variable defined नहीं है। मुझे नहीं पता ये क्या है।

इस मामले में ये बहुत स्पष्ट है, मैंने एक typo बनाया। मैं sayHello टाइप करना चाहता था, और फिर लहरदार रेखा चली जाती है।

अब ये purple है। Nextflow syntax parser जानता है कि ये एक प्रोसेस है और जब मैं इस पर hover करता हूं, तो ये मुझे एक reduced representation देता है कि ये प्रोसेस कैसा दिखता है। तो मैं बहुत जल्दी एक नज़र में देख सकता हूं कि ये कोई input नहीं लेता है और ये हमें ये आउटपुट देता है। तो VS Code में इस extension के साथ काम करना तुम्हें code लिखते समय बहुत contextual जानकारी देता है।

ध्यान दो कि हम इस प्रोसेस से आउटपुट को _.out_ syntax के साथ refer कर सकते हैं। और इस समय हम इसे जो चाहें कह सकते हैं, ये बस एक arbitrary variable name है।

## 2.1.2. स्क्रिप्ट में एक output: ब्लॉक जोड़ो

जहां ये महत्वपूर्ण हो जाता है वो तब है जब हम यहां अपना नया ब्लॉक करते हैं, और ये अब workflow ब्लॉक के नीचे है, हम अब workflow के अंदर नहीं हैं। फिर से curly brackets। और यहीं हम बस Nextflow को बताते हैं कि सभी फ़ाइलें कहां रखनी हैं, जो workflow द्वारा बनाई गई हैं।

अब मैं इस variable name को लेने वाला हूं, जो मैंने यहां बनाया, और मैं इसे वहां रखने वाला हूं और इसके लिए कुछ curly brackets डालूंगा। और मैं Nextflow को एक path use करने के लिए कहूंगा। Oops. Path, quote marks में। और मैं dot use करूंगा। वो बस Nextflow को बताता है कि फ़ाइल को results directory के root में रखें। तो कोई sub directories या कुछ भी नहीं।

चलो अपनी workflow फिर से चलाते हैं। यदि मैं _"nextflow run hello-world.nf"_ करता हूं, तो उम्मीद है कि ये मूल रूप से बिल्कुल वैसा ही दिखना चाहिए। यहां Nextflow के साथ वास्तव में कुछ भी नहीं बदला है। ये वही चीजें चला रहा है। ये बस उन्हें फिर से work directories में कर रहा है।

लेकिन अब यदि मैं _"ls results/"_ करता हूं, तो तुम देखोगे कि यहां results नाम की एक नई directory बनाई गई है जो workflow publishing के लिए default base directory है। और वहां _output.txt_ नाम की एक फ़ाइल है।

यदि मैं _"ls -l results"_ करता हूं, तो तुम देखोगे कि ये वास्तव में work directory से soft linked है। तो ये एक real फ़ाइल नहीं है, ये work directory से linked है और इसने हमारे लिए वहां सभी फ़ाइलें collect की हैं।

## 2.2. एक custom location सेट करो

"Results" इस path के लिए default name है। यदि मैं workflow फिर से चलाता हूं, और इस बार मैं _dash_ single hyphen करता हूं, ये है, क्योंकि ये एक core Nextflow option है। _"-output-dir **my** results"_। short के लिए _"-o"_ भी कर सकते हो। तो ये फ़ाइलों के store होने के लिए एक अलग base directory सेट करने वाला है और एक बार फिर, यहां _myresults/_ में, अब हमारे पास एक _output.txt_ है।

वो बढ़िया है, लेकिन हम शायद सभी फ़ाइलें बस root में नहीं चाहते। हम कुछ organization चाहते हैं, तो हम यहां एक subdirectory भी बना सकते हैं जिसे हम जो चाहें कह सकते हैं। चलो _"path 'hello_world'"_ कहते हैं, और मैं इसे फिर से चलाता हूं। _"nextflow run hello-world.nf"_। ये results directory में एक subdirectory में जाना चाहिए और सच में, अब results के तहत यहां शीर्ष पर हमारे पास _hello_world/_ है और हमारे पास _output.txt_ है।

ध्यान देने योग्य महत्वपूर्ण बात, पुरानी _output.txt_ फ़ाइल अभी भी वहां है। results directory को तब साफ नहीं किया जाता जब तुम ऐसा करते हो। बस नई फ़ाइलें वहां copy की जाती हैं। वे फ़ाइलों को overwrite करेंगी जो पहले से वहां हैं यदि उनके पास same फ़ाइल name है, लेकिन वे पुरानी को clear नहीं करेंगी। तो तुम्हें थोड़ा सावधान रहना होगा जब तुम pipelines को फिर से चलाते हो। यदि तुम नहीं चाहते कि वे पहले से वहां मौजूद फ़ाइलों के ऊपर हों। सुनिश्चित करो कि तुम एक blank empty directory का उपयोग करते हो।

## 2.3. publish mode को copy पर सेट करो

ठीक है, मैंने उल्लेख किया कि ये फ़ाइलें soft links हैं, तो यदि मैं _"ls -l results/hello_world/"_ करता हूं, तो तुम देख सकते हो कि ये work directory से soft linking कर रहा है। ये आम तौर पर एक अच्छी बात है यदि तुम HPC जैसी किसी चीज़ पर काम कर रहे हो, और ये वास्तव में बहुत बड़ी फ़ाइलें हैं और तुम उन्हें duplicate नहीं करना चाहते, क्योंकि इसका मतलब है कि फ़ाइल केवल एक बार file system पर store होती है।

हालांकि, इसका मतलब है कि यदि तुम work directory को delete करते हो: यदि मैं _"rm -r work"_ करता हूं और उन सभी intermediate फ़ाइलों को clear करता हूं जो बनाई गई थीं। अब, यदि मैं इस फ़ाइल _"results/hello_world/"_ को read करने की कोशिश करता हूं। ये एक soft link के रूप में एक फ़ाइल की ओर इशारा कर रहा होगा जो अब मौजूद नहीं है और data हमेशा के लिए चला गया है और irretrievable है, जो शायद बहुत अच्छा नहीं है।

तो आम तौर पर हम, मैं कहता हूं कि यदि तुम कर सकते हो तो फ़ाइलों को soft linking के बजाय copy करना अच्छा अभ्यास है, क्योंकि ये safer है। बस aware रहो कि ये दोगुनी disk space का उपयोग करेगा जब तक तुम उन work directories को delete नहीं करते।

output ब्लॉक के साथ ऐसा करने के लिए, मैं यहां first output पर जाने वाला हूं। मैंने पहले path सेट किया और अब मैं mode सेट करने वाला हूं और तुम देख सकते हो जैसे मैं टाइप करता हूं, VS code extension, चीजें suggest कर रहा है जो ये जानता है कि ये यहां एक output directive है। और मैं copy कहने वाला हूं। मैं save दबाता हूं।

चलो workflow को फिर से चलाते हैं। ये फिर से फ़ाइलें बनाने वाला है, नई work directory।

अब, यदि मैं _"ls -l results/hello_world/"_ पर जाता हूं तो तुम देख सकते हो कि ये एक real फ़ाइल है और ये अब soft link नहीं है, और Nextflow ने उसे copy किया। जानना अच्छा है। तो path और mode ऐसी चीजें हैं जो तुम खुद को काफी बार लिखते हुए पाओगे।

अब, निश्चित रूप से, ये बहुत सरल है। हम इसे अधिक जटिल और शक्तिशाली बनाएंगे जैसे-जैसे हम आगे बढ़ते हैं, और तुम देखोगे कि इन चीजों को dynamic कैसे बनाया जाए और बहुत verbose न बनाया जाए।

## 2.4. प्रोसेस-लेवल publishDir directives पर नोट

अब, मैंने कहा जैसा कि हमने इस पर शुरू किया, कि ये syntax का एक काफी नया रूप है। ये केवल Nextflow के latest versions में उपलब्ध है जैसा कि मैं इसे record करता हूं, और इसे Workflow Outputs कहा जाता है।

यदि तुम इसका उपयोग करते हो, तो ये बढ़िया है। ये Nextflow के भीतर बहुत सारी अन्य cool features को unlock करता है, जैसे, Nextflow Lineage जो इन फ़ाइलों की heritage को track करने में मदद करता है जैसे वे बनाई जाती हैं, और जल्द ही 26.04 में default होंगी। और भविष्य में बाद की तारीख में, ये तुम्हारे workflows लिखने का एकमात्र तरीका होगा।

हालांकि, जैसा कि हम अभी इस transition phase में हैं, तुम अच्छी तरह से wild में pipelines देख सकते हो, जो तुम publishDir नाम की किसी चीज़ का उपयोग करते हो, जो इसे करने का पुराना तरीका है, और ये workflow और output level पर नहीं बल्कि process level पर defined है।

और ये declaration मूल रूप से वही चीज़ कहता है। ये कहता है, results फ़ाइलों को results नाम की एक directory में publish करो, और copy mode का उपयोग करो। तो तुम देख सकते हो syntax बहुत similar है। लेकिन जब तुम अब नई pipelines लिख रहे हो, तो इस publishDir directive का उपयोग न करने की कोशिश करो, भले ही तुम इसे AI results में या documentation में या अन्य pipelines में देखते हो, क्योंकि वो इसे करने का पुराना तरीका है।

2026 में हम सभी को workflow outputs का उपयोग करना चाहिए।

ये सब documented है, यदि तुम ऐसा कर रहे हो और तुमने पहले Nextflow का उपयोग किया है, तो तुम यहां Nextflow docs पर जा सकते हो, nextflow.io/docs/। और यदि मैं tutorials तक scroll करता हूं, तो एक tutorial है जिसे _Migrating to Workflow Outputs_ कहा जाता है।

ये वास्तव में अच्छा है। ये सभी syntax से गुजरता है, ये पुराने syntax के equivalent कैसे है, हमने इसे क्यों बदला, और एक timeline और सब कुछ है। और ये सभी विभिन्न scenarios से गुजरता है जिसमें loads और lots of examples हैं। तो तुम आसानी से मौजूदा Nextflow code को नए syntax में convert कर सकते हो।

## 3.1. sayHello प्रोसेस को एक variable input की उम्मीद करने के लिए बदलो

ठीक है, तो हमारी simple स्क्रिप्ट है, जो एक प्रोसेस चला रही है, एक फ़ाइल बना रही है, Nextflow को बता रही है कि ये एक आउटपुट है, और फिर हम Nextflow को बता रहे हैं कि उस फ़ाइल को कहां save करना है। वो एक अच्छी शुरुआत है।

लेकिन ये अधिक दिलचस्प होगा यदि ये सब hardcoded नहीं था। तो अगला, चलो सोचते हैं कि Nextflow को कैसे बताया जाए कि ये प्रोसेस एक variable input ले सकता है, जो कुछ ऐसा है जिसे हम runtime पर control कर सकते हैं जब हम एक workflow launch करते हैं।

हमें ऐसा करने के लिए कुछ अलग-अलग चीजें करनी होंगी।

सबसे पहले, हमें इस प्रोसेस को बताना होगा कि ये एक input variable accept कर सकता है और हम यहां एक नए declaration ब्लॉक के रूप में _input_ type करते हैं। और हम इसे _"val greeting"_ कहने वाले हैं।

val bit यहां नीचे path के equivalent है। ये Nextflow को बताता है कि ये एक variable है, इस मामले में एक string की तरह। और यदि तुम फिर से इस पर hover करते हो, तो ये तुम्हें extension से बताता है कि इसका क्या अर्थ है।

अगला हम Nextflow को बताने वाले हैं कि इसके साथ क्या करना है। बस यह कहना काफी नहीं है कि एक variable है। तुम्हें स्क्रिप्ट में कहना होगा कि उस variable का उपयोग कैसे करें। और इसलिए मैं यहां इस hardcoded string से छुटकारा पाने वाला हूं, और मैं एक variable डालने वाला हूं।

मैं जल्दी से curly brackets के बिना ऐसा करने वाला हूं बस तुम्हें दिखाने के लिए कि ये allowed है, और ये पुराना तरीका है। लेकिन अब नए syntax के साथ, हम वास्तव में इसे curly brackets के अंदर रखने की सिफारिश करते हैं जैसे, और ये वास्तव में clear करता है कि ये यहां Nextflow द्वारा interpolate किया जा रहा है।

बढ़िया। तो _"input greeting"_ _$\{greeting\}_ में जाता है। आखिरी चीज़ ये है कि हमें workflow level पर Nextflow को बताने की ज़रूरत है कि ये प्रोसेस अब एक input लेता है। और ऐसा करने के लिए, हम मूल रूप से इसे एक variable देने वाले हैं।

## 3.2. user input को capture करने के लिए एक command-line parameter सेट अप करो

हम इसे फिर से hard code कर सकते थे, जैसे Hello World, और वो ठीक काम करेगा, लेकिन स्पष्ट रूप से ये वास्तव में हमें कोई advantage नहीं देता। हम चाहते थे कि हम इसे run time पर configure कर सकें, तो हम चाहते हैं कि हम इसे CLI पर कर सकें, जब तुम Nextflow launch करते हो।

और जिस तरीके से हम ऐसा करते हैं वो एक विशेष Nextflow अवधारणा है जिसे _params_ कहा जाता है। हम इसे _params.input_ कहने वाले हैं।

ये क्या करता है ये CLI पर इस input variable को expose करता है और वहीं हम double dash का उपयोग करते हैं जब हम Nextflow launch करते हैं।

मैं इसे जो चाहूं कह सकता हूं, मैं इसे _hello, greeting_ कह सकता हूं। कोई फर्क नहीं पड़ता। जो कुछ भी मैं वहां करूंगा वो CLI option के रूप में exposed होगा जब हम एक पाइपलाइन launch करते हैं। और ये Nextflow द्वारा एक real magic trick है क्योंकि इसका मतलब है कि तुम इन parameters के साथ अपनी workflow स्क्रिप्ट बहुत जल्दी build कर सकते हो, और तुम अपनी पाइपलाइन के लिए एक custom CLI बना रहे हो, इसे launch करते समय विभिन्न options को customize करना वास्तव में आसान बनाते हुए।

तो। चलो इसे try करते हैं। अपने टर्मिनल पर वापस जाओ। हमारे पास यहां हमारा _"nextflow run"_ कमांड है। और अब मैं _"--input"_ करने वाला हूं, जो _"params.input"_ से मेल खाता है जो हमने पहले देखा था। मुझे लगता है कि docs में ये French में है। Geraldine को French बोलना पसंद है। मैं इसे Swedish में करने वाला हूं क्योंकि मैं Sweden में रहता हूं। तो मैं कहने वाला हूं, "_Hej Världen_" और enter दबाऊंगा।

Single quotes या double quotes का उपयोग कर सकते हो, ये बस प्रभावित करता है कि Bash इसे कैसे interpret करता है।

ये Nextflow पाइपलाइन को बिल्कुल उसी तरह चलाता है। तुम देख सकते हो working directory और सब कुछ same है। लेकिन अब यदि मैं _"results/hello_world/output"_ पर जाता हूं। हम यहां अपनी अच्छी Swedish देख सकते हैं।

तो हमने dynamically एक CLI से एक पैरामीटर के लिए एक input pass किया है। हमने उसे प्रोसेस में एक input के रूप में pass किया है और प्रोसेस ने उसे interpret किया है और इसे एक script ब्लॉक में डाला है, जिसने फिर उस स्क्रिप्ट result के आउटपुट को dynamically बदल दिया है। बहुत cool।

यहां बहुत कम syntax के साथ काफी जटिल logic। और तुम उम्मीद कर सकते हो कि ये अब कैसे scale होना शुरू होता है। और ये वास्तव में वो तरीका है जिससे हम अपनी pipelines के logic और customizability को Nextflow स्क्रिप्ट में build करते हैं।

## 3.4. command line parameters के लिए default values का उपयोग करो

ठीक है, वो बढ़िया है। लेकिन अब समस्या ये है कि, हर बार जब मैं इस पाइपलाइन को चलाता हूं, मुझे इसे चलाने के लिए dash, input करने की ज़रूरत होती है।

यदि मैं इस पैरामीटर के बिना चलाने की कोशिश करता हूं, तो अब Nextflow एक error throw करने वाला है जो कहता है कि इसे इस पैरामीटर की ज़रूरत थी और ये सेट नहीं था। और इसलिए ये नहीं जानता था कि क्या करना है।

वैसे ये एक cool नई चीज़ है। अतीत में, Nextflow बस एक empty string के साथ चला होता, और तुम्हें सभी प्रकार की अजीब errors हुई होतीं, जिन्हें समझना मुश्किल होता। लेकिन नए Nextflow syntax parser में, ये थोड़ा अधिक सावधान है और ये तुम्हें तुरंत बताता है।

तो हम हमेशा हर एक option specify नहीं करना चाहते। sensible defaults specify करना अच्छा अभ्यास है। तो हम अपनी स्क्रिप्ट में ऐसा कैसे करते हैं?

तुम ध्यान दोगे कि जब हमने ये लिखा, तो हमने _params.input_ को सीधे वहां डाला जहां हम इसका उपयोग कर रहे हैं। तो स्पष्ट समाधान ये है कि हम एक default define करते हैं, और हम ऐसा यहां स्क्रिप्ट के शीर्ष पर workflow में एक विशेष params ब्लॉक में करते हैं। ये यहां workflow स्क्रिप्ट में है।

फिर से, यहां कुछ नया syntax है, तो ध्यान दो। ये वास्तव में cool stuff है। हमारे पास पैरामीटर का नाम है, जो यहां expected होगा।

और फिर इस colon character के बाद, हम variable के type को define कर रहे हैं। तुम्हें ऐसा करने की ज़रूरत नहीं है, तुम इसे बस blank छोड़ सकते हो, लेकिन ये वास्तव में अच्छा है। ये Nextflow को बताता है कि हम एक string की उम्मीद कर रहे हैं और इसे वैसा ही treat करो।

यदि हम इसके बजाय एक number चाहते हैं, उदाहरण के लिए, हम float लिख सकते हैं, और वो कहेगा कि हम एक floating point number चाहते हैं। और यदि हम उसके साथ चलाने की कोशिश करते हैं, तो ये एक error throw करेगा। यदि हम इसे एक string देते हैं, जो float नहीं है। और ये इसे वैसे ही pass भी करेगा। जैसे यदि हम string करते हैं, तो ये जानता है कि ये एक string है। और भले ही इसमें leading zeros हों और सभी numeric हों, फिर भी ये इसे एक actual string के रूप में pass करेगा।

तो वो type safety Nextflow की एक बहुत नई feature है, लेकिन तुम्हारे code को लिखने और चलाने के लिए safer बनाने के लिए वास्तव में शक्तिशाली है।

फिर उसके बाद हमारे पास एक equal symbol है और फिर यहां default value। Nextflow originally Barcelona में लिखा गया था, तो ये उपयुक्त लगता है कि हमारे पास यहां कुछ Spanish है, _"Holà mundo!"_ default के रूप में।

ठीक है मैं उस स्क्रिप्ट को save करने वाला हूं, वापस जाता हूं, स्क्रिप्ट को फिर से _--input_ के बिना चलाता हूं। और इस बार ये चलना चाहिए और ये _results_ में हमारी नई फ़ाइल बनाएगा। और अब इस फ़ाइल में ये _"Holà mundo!"_ कहता है।

हालांकि ये बस एक default है, तो इसका मतलब ये नहीं है कि हम अभी भी पहले जैसा नहीं कर सकते। यदि मैं वापस जाता हूं और यहां अपनी पुरानी स्क्रिप्ट ढूंढता हूं, _"Hej Världen"_, क्योंकि मैं command line पर _--input_ करता हूं, वो उस default को overwrite करेगा और output.txt फ़ाइल में फिर से उसका उपयोग करेगा।

तो स्क्रिप्ट में ये केवल default value है जो मैं सेट कर रहा हूं।

जैसे-जैसे हम अपने workflow को अधिक जटिल बनाते हैं और अधिक parameters शामिल करते हैं, स्क्रिप्ट के शीर्ष पर ये params ब्लॉक उन सभी को एक जगह collect करना शुरू कर देगा।

और तुम अपनी स्क्रिप्ट में इस काफी अच्छी symmetry के साथ समाप्त होते हो, जहां तुम्हारे पास effectively यहां तुम्हारे सभी workflow inputs हैं और तुम्हारे workflow outputs नीचे हैं। और ये बहुत स्पष्ट है कि बाहरी दुनिया के लिए तुम्हारे workflow का interface क्या है। तो तुम एक नई पाइपलाइन को नए syntax के साथ बहुत जल्दी pick कर सकते हो और समझ सकते हो कि इसका उपयोग कैसे करना है।

एक आखिरी cool चीज़। हमें इसके साथ एक default value सेट करने की ज़रूरत नहीं है। यदि हम params input करते हैं लेकिन default value सेट नहीं करते हैं, तो ये Nextflow को बताता है कि ये पैरामीटर required है, और फिर से, पाइपलाइन इसके बिना चलने में fail हो जाएगी, लेकिन ये तुम्हें इसके null होने के बारे में कुछ के बजाय एक अधिक उपयोगी error message देगा।

तो ये कहता है कि हम इसकी उम्मीद कर रहे हैं इसका input required है, लेकिन command line पर specified नहीं था। बहुत अच्छा।

ठीक है, तो उम्मीद है कि अब ये स्पष्ट है कि अपनी Nextflow पाइपलाइन को variable inputs और parameters के साथ कैसे सेट अप करें, default कैसे सेट करें, types कैसे सेट करें, ये एक Boolean true false flag या एक integer या यहां अलग-अलग types हो सकती हैं। उन्हें अपने workflow में कैसे pass करें, जहां ये जाता है, और फिर अपने प्रोसेस में interpolate होता है। और फिर तुम यह भी जानते हो कि जब तुम Nextflow launch करते हो तो command line पर उन्हें कैसे customize करें। ये हमारे simple bash कमांड की तुलना में अधिक दिलचस्प दिखना शुरू हो रहा है।

## 4. वर्कफ़्लो executions को manage करो

ठीक है। आगे क्या है? इस चैप्टर के अंतिम भाग के लिए, हम सभी अलग-अलग workflow executions को कैसे manage करें, इस बारे में थोड़ी बात करने वाले हैं। यदि तुम मेरे sidebar में देखते हो और work के नीचे Explorer में, तो तुम देखोगे कि मैंने कई अलग-अलग pipelines चलाई हैं और ये work directories काफी लंबी हो रही हैं, इनमें से बहुत सारी हैं।

और दूसरी बात ये है कि, जैसा कि मैंने पहले कहा, हर बार जब मैं इस पाइपलाइन को फिर से चलाता हूं, तो ये work directories का एक नया सेट बना रहा है, और ये scratch से सभी प्रोसेस को फिर से चला रहा है, जो एक अच्छी बात है। वो intended behavior है। ये reproducible है और ये सब कुछ fresh regenerate कर रहा है। लेकिन स्पष्ट रूप से, यदि तुम बहुत लंबे समय तक चलने वाले प्रोसेस चला रहे हो, तो हमेशा अपनी पाइपलाइन को शुरुआत से शुरू करना annoying है यदि ये आधे रास्ते में crash हो गई, या यदि तुम पाइपलाइन के अंत में कुछ बदलते हो।

## 4.1. -resume के साथ एक वर्कफ़्लो को फिर से launch करो

सौभाग्य से, Nextflow वास्तव में अच्छा है यह जानने में कि पहले क्या चलाया गया है और क्या उपलब्ध है, और उन पुराने results को फिर से उपयोग करना बहुत सरल है। हम बस कमांड के अंत में एक नया flag जोड़ते हैं _"-resume"_।

अब, ध्यान दो कि input पर दो hyphens हैं क्योंकि वो पैरामीटर है। resume पर केवल एक hyphen है क्योंकि वो एक core Nextflow option है।

ये लोगों को हर समय trip करता है, भले ही तुमने लंबे समय तक Nextflow का उपयोग किया हो। तो हमेशा याद रखो एक या दो hyphens। निर्भर करता है यदि ये एक core Nextflow option है।

ठीक है, तो अब मैं _-resume_ करता हूं और मैं बिल्कुल वही workflow फिर से चलाता हूं। और इस बार ये एक key difference के साथ बिल्कुल वैसा ही दिखना चाहिए।

यहां आउटपुट में, तुम देख सकते हो कि results cached थे। और वास्तव में, यहां ये task hash बिल्कुल previous run के समान है, और इसने बस उस work directory को अपनी संपूर्णता में reuse किया। inputs और outputs और स्क्रिप्ट सभी unmodified थीं। और इसलिए ये बस उससे उस फ़ाइल को लेता है और यदि प्रोसेस में downstream steps हैं, तो ये उन्हें पाइपलाइन में अगले step पर pass कर देगा।

तो ये अभी भी पूरी पाइपलाइन को शुरू से अंत तक चला रहा है, लेकिन ये उन टास्क में से प्रत्येक के लिए cached results का उपयोग कर रहा है, जहां ये कर सकता है।

अब, जब तुम _-resume_ करते हो, तो ये बस तुम्हारी working directory में last पाइपलाइन run को resume करता है, जो भी वो था। लेकिन तुम वास्तव में किसी भी previous run से resume कर सकते हो जो तुमने वहां किया है। और हमने अब काफी किया है।

## 4.2. पिछले executions के log की जांच करो

उन सभी को देखने के लिए, हम _"nextflow run"_ के बजाय _"nextflow log"_ कर सकते हैं, और वो हमें एक अच्छा आउटपुट देगा जो इन सभी अलग-अलग.. मुझे अपनी स्क्रीन को थोड़ा छोटा करने की ज़रूरत है ताकि हम इसे देख सकें, इन सभी अलग-अलग runs को दिखाता है जब हमने उन्हें किया, session id, कमांड और सब कुछ।

और हम यहां देख सकते हैं और हम इनमें से किसी का भी run name ले सकते हैं और फिर उन विशिष्ट में से एक को resume कर सकते हैं। तो मैं वापस जा सकता हूं और मैं _hungry_ekeblad_ नाम वाले को resume कर सकता हूं। और मैं बस इसे _resume_ के बाद डालता हूं।

यदि तुम curious हो, वैसे, ये सभी विशेषण और वैज्ञानिकों के नाम Nextflow source code में हैं। Nextflow में अपना पहला pull request पाने का ये वास्तव में एक अच्छा तरीका है इसे जाकर और ढूंढकर और अपने पसंदीदा वैज्ञानिक को जोड़कर।

और वैसे भी, तो मैंने ऐसा किया और ये वापस गया और इसने इस workflow run से cached results को देखा, realize किया कि ये अभी भी उन्हें reuse कर सकता है, और इसने किया। तो मुझे फिर से cached results मिले।

## 4.3. पुरानी work directories को delete करो

वो बढ़िया है। क्या होगा यदि मैं इन work directories को clean up करना चाहता हूं? यहां इनमें से loads हैं। loads of फ़ाइलें हैं। शायद मैं निश्चित रूप से जानता हूं कि मैं आखिरी कुछ पाइपलाइन runs से resume करना चाहता हूं, लेकिन मुझे उससे पहले के सभी की परवाह नहीं है।

तो मैं यहां एक pick कर सकता हूं और मैं एक और Nextflow कमांड का उपयोग कर सकता हूं, जो _"nextflow clean"_ है, और मैं _"nextflow clean"_ कर सकता हूं, मैं _"-before"_ करने वाला हूं, और particular run name, जो इस मामले में _reverent_pike_ था और मैं _"-n"_ करने वाला हूं, जो Nextflow को बस एक dry run करने के लिए कहता है। तो ये बस मुझे बताता है कि ये क्या delete करेगा। वास्तव में कुछ भी किए बिना, तो ये इन work directories को remove करेगा।

वो sensible लग रहा है। तो मैं फिर से वही कमांड करने वाला हूं, लेकिन _"-n"_ के बजाय मैं वास्तव में cleanup करने के लिए _"-f"_ करूंगा। और इस बार इसने वास्तव में इन सभी directories को remove किया है। और यदि मैं अंदर जाता हूं और work directories को देखता हूं, तो अब ये बहुत lighter दिख रहा है। शानदार।

तो वो तुम्हारी सभी local work directories को एक काफी safe तरीके से clean up करने का तरीका है बिना cache को पूरी तरह से destroy किए। तो तुम अभी भी resume कर सकते हो यदि तुम चाहो तो।

यदि कभी तुम भूल जाते हो कि हर Nextflow कमांड के लिए ये flags क्या हैं तो तुम _"nextflow help"_ कर सकते हो, और फिर कमांड का नाम। तो यदि मैं _"nextflow help clean"_ करता हूं, तो तुम सभी अलग-अलग options देख सकते हो: _-after, -before, -but_, इस cleanup behavior को configure करने के सभी अलग-अलग तरीके। बहुत cool।

## सारांश

ठीक है, वो Hello Nextflow के part one का अंत है। कोर्स की शुरुआत के लिए ये काफी intense है, लेकिन उम्मीद है कि अब तुम्हें एक Nextflow स्क्रिप्ट कैसी दिखती है, इसकी बहुत अच्छी समझ है; अलग-अलग key parts के साथ, प्रोसेस, workflows, outputs, और parameters। तुम जानते हो कि command line से basic overrides के साथ उन्हें कैसे configure करना है, dynamic script के साथ dynamic input ब्लॉक कैसे बनाना है और तुम जानते हो कि अपने सभी workload executions को कैसे manage करना है: देखना कि तुमने पहले क्या चलाया है, resuming, cleaning up। बहुत सारी चीजें हैं। तुम एक लंबा रास्ता तय कर चुके हो। तो यदि तुम break लेना चाहते हो और एक त्वरित walk और चाय का कप लेना चाहते हो, तो अब शायद एक अच्छा समय है। तुमने इसे earned किया है।

यहां से, हम मूल रूप से इस foundation पर निर्माण कर रहे हैं। हम इसे अधिक जटिल, अधिक शक्तिशाली कैसे बना सकते हैं? हम इसे अधिक flexible कैसे बना सकते हैं? वे चीजें करो जो हम अपने analysis को scale पर करना चाहते हैं।

## Quiz

अब यदि तुम webpage पर part one, hello world तक scroll करते हो तो तुम एक छोटा quiz देखोगे और ये कुछ नया है जो हमने Nextflow training के इस version के लिए किया है। और तुम जा सकते हो और खुद को quiz कर सकते हो यह check करने के लिए कि तुमने इस चैप्टर में जो सामग्री की है उसे समझ लिया है।

ये हमें या कुछ भी नहीं भेजा जाता है, ये बस तुम्हारे browser में stored है। तो हम नहीं जानते कि तुम्हारे जवाब क्या हैं, लेकिन ये बस एक छोटा self check है यह सुनिश्चित करने के लिए कि तुमने कुछ भी miss नहीं किया है या कुछ भी गलत नहीं समझा है। और तुम इसे जितनी बार चाहो उतनी बार try कर सकते हो।

यदि तुम मेरे जैसे हो, शायद तुम अपने VS Code instance में टर्मिनल में रहना चाहते हो, जिस स्थिति में तुम _quiz_ कमांड टाइप कर सकते हो और फिर बस इसे बता सकते हो कि तुम किस चैप्टर पर हो। तो हम _"Hello World"_ करते हैं, और फिर तुम बिल्कुल same कर सकते हो, quiz questions, जो web browser में हैं, लेकिन बस अपने टर्मिनल में।

Cool. ठीक है। उम्मीद है कि तुम्हें मज़ा आया। थोड़ा मज़ा करो और, हम तुम्हें अगले चैप्टर में बस एक मिनट में Nextflow चैनल के बारे में बात करने के लिए देखेंगे।
