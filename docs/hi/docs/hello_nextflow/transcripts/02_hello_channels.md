# भाग 2: Hello Channels - वीडियो ट्रांसक्रिप्ट

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI-सहायता प्राप्त अनुवाद - [अधिक जानें और सुधार सुझाएं](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/yDR66fzAMOg?si=xCItHLiOQWqoqBB9&amp;list=PLPZ8WHdZGxmWKozQuzr27jyMGqp9kElVK&amp;cc_load_policy=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "महत्वपूर्ण नोट"

    यह पेज केवल ट्रांसक्रिप्ट दिखाता है। पूर्ण चरण-दर-चरण निर्देशों के लिए, [कोर्स सामग्री](../02_hello_channels.md) पर वापस जाओ।

    ट्रांसक्रिप्ट में दिखाए गए सेक्शन नंबर केवल संकेत के उद्देश्य से दिए गए हैं और हो सकता है कि सामग्री में सभी सेक्शन नंबर शामिल न हों।

## स्वागत

नमस्ते और Hello Nextflow के भाग 2 में वापस स्वागत है। इस अध्याय को Hello Channels कहा जाता है।

चैनल तुम्हारी Nextflow पाइपलाइन में गोंद की तरह हैं। ये वो हिस्से हैं जो सभी अलग-अलग प्रोसेस को एक साथ जोड़ते हैं, जिनका उपयोग Nextflow सभी जानकारी को पास करने और तुम्हारे वर्कफ़्लो को ऑर्केस्ट्रेट करने के लिए करता है।

चैनल का एक और हिस्सा है जो ऑपरेटर हैं। ये मूल रूप से फ़ंक्शन हैं जिनका उपयोग हम चैनल पर उनकी सामग्री को संशोधित करने के लिए कर सकते हैं। चलो VS code में जाते हैं और देखते हैं कि हम कहाँ हैं।

मैं इस VS code पर बहुत ज़ूम इन हूँ, इसलिए चीज़ों को साफ़ और व्यवस्थित रखने के लिए, मैंने सभी _.nextflow\*_ फ़ाइलें और _work/_ डायरेक्टरी और results/ और अध्याय एक से सब कुछ हटा दिया है। और मैं यहाँ बस नए सिरे से शुरू कर रहा हूँ। लेकिन इसके बारे में ज़्यादा चिंता मत करो। अगर तुम नहीं चाहते, तो तुम उन फ़ाइलों को वहीं छोड़ सकते हो। वे कोई समस्या नहीं पैदा करेंगी।

हम इस अध्याय के लिए _hello-channels.nf_ पर काम करना शुरू करने वाले हैं, और अगर मैं इसे खोलता हूँ, तो यह उस फ़ाइल के समान दिखनी चाहिए जिस पर हम पहले काम कर रहे थे। हो सकता है कि अलग-अलग हिस्से स्क्रिप्ट के अलग-अलग हिस्सों में हों, लेकिन सब कुछ मूल रूप से समान होना चाहिए।

एक चीज़ जो अलग है वह यह है कि यहाँ output ब्लॉक में path अब इस भाग के लिए _hello_channels_ है, जिसका मतलब है कि रिज़ल्ट फ़ाइलें तुम्हारे results में एक अलग सबडायरेक्टरी में स्टोर की जाएंगी अगर तुम्हारे पास अभी भी वह है। तो आउटपुट के बारे में भ्रमित हुए बिना शुरू करने के लिए यह एक अच्छी और साफ़ जगह होनी चाहिए।

ठीक है, तो चलो जल्दी से याद करते हैं कि जब हम इस वर्कफ़्लो को चलाते हैं तो यह स्क्रिप्ट क्या करती है। हम _"nextflow run hello-channels.nf"_ करते हैं। हम _"--input myinput"_ कर सकते हैं, और जब हम इसे चलाते हैं, तो यह इस पैरामीटर, params.input का उपयोग करने वाला है, जिसे यहाँ ऊपर sayHello प्रोसेस के लिए वेरिएबल के रूप में पास किया गया था, जो greeting में जाता है और output.txt में सेव हो जाता है। और हम इसे results फ़ाइल में देख सकते हैं। बढ़िया।

## 1. चैनल के माध्यम से स्पष्ट रूप से वेरिएबल इनपुट प्रदान करना

यह अच्छा है। लेकिन यह काफी सरल है। हमारे पास इस पैरामीटर में एक वेरिएबल है, जो एक प्रोसेस में जाता है जो एक बार चलता है, और वास्तव में स्केल नहीं करता है। और हम इसे यहाँ बनाने के लिए बहुत सारी अलग-अलग फ़ाइलें नहीं दे सकते। हम इसे बहुत सारे अलग-अलग अभिवादन नहीं दे सकते। हमारे पास बस एक है।

वास्तव में, Nextflow तुम्हारे विश्लेषण को स्केल करने के बारे में है। तो तुम शायद चाहोगे कि यह एक से अधिक चीज़ें करे। और हम इसे _चैनल_ के साथ करते हैं।

चैनल Nextflow को सीखने वाले कई लोगों के लिए एक अनोखी अवधारणा है। यह फ़ंक्शनल प्रोग्रामिंग की अवधारणाओं से आता है, और इसे समझने में थोड़ा समय लग सकता है, लेकिन एक बार जब तुम समझ जाते हो, तो वे वास्तव में Nextflow की शक्ति को अनलॉक करते हैं और यह तुम्हारे वर्कफ़्लो लिखने के तरीके की कुंजी है।

## 1.1. एक इनपुट चैनल बनाना

चलो इस स्क्रिप्ट को लेकर शुरू करते हैं और इसे सिर्फ़ एक _param_ के बजाय एक _चैनल_ का उपयोग करने के लिए बनाते हैं।

हम वर्कफ़्लो में जाते हैं, जो हमारे सभी वर्कफ़्लो लॉजिक के बारे में है जो चीज़ों को एक साथ जोड़ता है। और मैं यहाँ जाने वाला हूँ और मैं एक नया चैनल बनाने वाला हूँ।

एक नया चैनल बनाओ।

और मैं इसे "_greeting_ch_" कहने वाला हूँ। यह "_\_ch_" करने का कन्वेंशन है, बस इसलिए कि तुम याद रख सको कि यह वेरिएबल एक चैनल है। लेकिन तुम इसे जो चाहो कह सकते हो।

और फिर मैं equals कहने वाला हूँ, और मैं _"channel.of"_ करने वाला हूँ।

Channel चैनल से संबंधित हर चीज़ के लिए नेम स्पेस की तरह है। लोअर केस "c" अगर तुम पहले Nextflow का उपयोग कर रहे हो। और _".of"_ को Channel factory कहा जाता है, जो मूल रूप से एक चैनल बनाने का एक तरीका है।

बहुत सारे अलग-अलग channel factory हैं। अगर मैं यहाँ सिर्फ़ "." करता हूँ, तो तुम देख सकते हो कि VS Code उनमें से बहुत सारे सुझा रहा है, लेकिन _".of"_ सबसे सरल है और बस यहाँ एक इनपुट लेता है।

तो मैं कुछ ब्रैकेट कर सकता हूँ और मैं _"Hello Channels!"_ कहने वाला हूँ।

बढ़िया। मेरे पास एक चैनल है। शानदार। मैं save दबा सकता हूँ, मैं इसे फिर से चला सकता हूँ, लेकिन कुछ भी दिलचस्प नहीं होने वाला है। VS Code ने मुझे यहाँ एक नारंगी चेतावनी लाइन दी है और मुझे बताया है कि यह सेट अप है: तुमने इसे बनाया है, लेकिन तुमने वास्तव में इसे किसी भी चीज़ के लिए उपयोग नहीं किया है। यह चैनल consume नहीं हो रहा है।

ठीक है, तो हम इसका उपयोग कैसे करते हैं? बहुत सरल। मैं इसे लेने वाला हूँ, इसे कॉपी करने वाला हूँ, और मैं _params.input_ को डिलीट करने वाला हूँ और मैं इसके बजाय यहाँ _"greeting_ch"_ डालने वाला हूँ। तो हम इस चैनल को sayHello के इनपुट के रूप में पास करने वाले हैं।

ध्यान दो कि मैंने अभी के लिए इस स्ट्रिंग को हार्ड कोड किया है। यह हमारे अच्छे param के बाद थोड़ा पीछे की ओर कदम है जिसका हमने पिछले अध्याय के अंत में उपयोग किया था, लेकिन यह चीज़ों को शुरू करने के लिए सरल रखता है ताकि तुम लॉजिक देख सको।

ठीक है, मैं अपने टर्मिनल में जाने वाला हूँ और मैं वर्कफ़्लो को फिर से चलाने वाला हूँ। इस बार बिना किसी _"--input"_ के, और यह चलने वाला है और यह उस चैनल का उपयोग करने वाला है जिसे हमने बनाया है और उम्मीद है कि हमारे पास यहाँ _results/hello_channels/_ में एक फ़ाइल होनी चाहिए और अब यह कहती है "Hello Channels!"। शानदार। तो यह वही है जो हम अपने चैनल से उम्मीद कर रहे हैं। बढ़िया।

## 1.4. चैनल सामग्री का निरीक्षण करने के लिए view() का उपयोग करना

यहाँ जोड़ने के लिए एक और चीज़, चैनल पर उपयोग किए जा सकने वाले एक और फ़ंक्शन का त्वरित परिचय जिसे "_.view_" कहा जाता है।

यह Python या अन्य भाषाओं में _print_ कमांड के समान है जिनका तुम उपयोग कर सकते हो, और यह जब हम इसे चलाते हैं तो इस चैनल की सामग्री को टर्मिनल में डंप कर देता है।

तो "_.view_" करो, और फिर अगर मैं वर्कफ़्लो को फिर से चलाता हूँ, तो यह टर्मिनल पर प्रिंट करना चाहिए कि उस चैनल की सामग्री क्या है, उस समय जब हमने इसे बनाया था।

निश्चित रूप से, तुम देख सकते हो कि यह यहाँ टर्मिनल पर प्रिंट हुआ है। _"Hello Channels!"_।

ध्यान दो कि तुम चाहो तो इन चीज़ों को लाइनों में तोड़ सकते हो, और वास्तव में, Nextflow, ऑटोमैटिक फ़ॉर्मेटर तुम्हारे लिए ऐसा करने की कोशिश करेगा। व्हाइट स्पेस यहाँ वास्तव में महत्वपूर्ण नहीं है, इसलिए तुम इन चीज़ों को एक के बाद एक चेन कर सकते हो।

## 2. कई इनपुट मानों पर चलाने के लिए वर्कफ़्लो को संशोधित करना

ठीक है, तो हमारे चैनल में एक चीज़ है जो अच्छी है, लेकिन यह मूल रूप से पहले जैसी ही है। तो चलो इसे थोड़ा और जटिल बनाते हैं। चलो अपने चैनल में कुछ और चीज़ें जोड़ते हैं।

"_.of()_" channel factory कई आइटम ले सकता है, तो चलो कुछ और लिखते हैं। हम _Hello, Bonjour, Hej_ करेंगे। और फिर हम इस वर्कफ़्लो को फिर से चला सकते हैं और देखेंगे कि क्या होता है।

फिर से चलना चाहिए। और हमने अब प्रिंट किया है। _"Hello", "Bonjour"_ और _"Hej"_ अपने view स्टेटमेंट के साथ टर्मिनल पर। शानदार।

## 2.1.2. कमांड चलाना और लॉग आउटपुट देखना

तुम सोच सकते हो कि हम इस बिंदु पर पूरा कर चुके हैं। लेकिन वास्तव में यहाँ थोड़ी सी समस्या है, जो हमें परेशान करने वाली है। अगर हम यहाँ अपनी आउटपुट फ़ाइल को देखें। तुम देख सकते हो कि इसमें _"Hello"_ है, लेकिन इसमें कोई अन्य आउटपुट नहीं है। वास्तव में, यह बस यही एक है।

अगर हम इस वर्कफ़्लो को कई बार चलाते हैं, तो हम देख सकते हैं कि कभी-कभी इसमें _"Bonjour"_ होता है, कभी-कभी इसमें _"Hej"_ होता है। यह थोड़ा रैंडम है।

अगर हम टर्मिनल को देखें, तो हम देख सकते हैं कि यह तीन बार चला और हम अलग-अलग view आउटपुट देख सकते हैं। लेकिन अगर मैं work डायरेक्टरी में जाता हूँ, तो मैं _"cat work"_ कर सकता हूँ। इस हैश को डालो और उसे expand करो और _output.txt_। तुम देख सकते हो कि work डायरेक्टरी में यह फ़ाइल results डायरेक्टरी से अलग है, और यह _"Hej"_ है। तो यहाँ कुछ ठीक से काम नहीं कर रहा है।

और मुख्य बात यह है कि, हमारे पास तीन कार्य थे जो चले। Nextflow आउटपुट इसे संक्षेप में प्रस्तुत करने की कोशिश करता है जैसे-जैसे प्रोसेसिंग चलती है, ताकि यह तुम्हारे पूरे टर्मिनल को पूरी तरह से न ले ले, और वह ANSI Logging ANSI escape codes का उपयोग करता है, मूल रूप से अन्य कार्यों को ओवरराइट कर दिया है। तो यह तुम्हें बस आखिरी वाला दिखाता है जो अपडेट हुआ था।

## 2.1.3. -ansi-log false विकल्प के साथ कमांड फिर से चलाना

कुछ चीज़ें हैं जो हम वास्तव में इसे थोड़ा बेहतर समझने के लिए कर सकते हैं। हम work डायरेक्टरी में ही देख सकते हैं और तुम वहाँ सभी अलग-अलग work dirs देख सकते हो, लेकिन यह थोड़ा भ्रमित करने वाला है क्योंकि यह अलग-अलग Nextflow execution runs के साथ मिश्रित होगा।

या हम Nextflow को ANSI escape codes का उपयोग न करने के लिए कह सकते हैं।

तो अगर मैं कमांड को फिर से चलाता हूँ, लेकिन इस बार मैं _"-ansi-log false"_ कहता हूँ इसे बंद करने के लिए, मैं environment variables _$NO_COLOR_ या _"$NXF_ANSI_LOG=false"_ का भी उपयोग कर सकता था। फिर यह बिना किसी चालाक अपडेट के सीधे टर्मिनल पर प्रिंट करते हुए, इन escape codes के बिना Nextflow logging की पुरानी शैली का उपयोग करता है।

और अब हम इन सभी तीन प्रोसेस को देख सकते हैं जो चले। और उनमें से प्रत्येक का अपना task hash है। और अगर हम इन work डायरेक्टरी में जाते हैं, तो हम तीन अलग-अलग अभिवादन देखेंगे जो हमने निर्दिष्ट किए थे।

तो अब यह थोड़ा अधिक समझ में आता है। उम्मीद है कि तुम समझ गए हो कि Nextflow यह कर रहा था, यह बस उन work डायरेक्टरी के साथ टर्मिनल में तुम्हें जो दिखाया गया था उसके साथ थोड़ा चालाक हो रहा था।

हालाँकि, इसने work डायरेक्टरी के साथ एक समस्या को ठीक किया है, लेकिन इसने आउटपुट फ़ाइल के साथ समस्या को ठीक नहीं किया है। हमारे पास अभी भी सिर्फ़ एक आउटपुट फ़ाइल है जो _"Hello"_ कहती है।

## 2.2. सुनिश्चित करना कि आउटपुट फ़ाइल के नाम अद्वितीय होंगे

अब इसे समझने के लिए, हमें अपनी वर्कफ़्लो स्क्रिप्ट पर वापस जाना होगा। हम यहाँ अपना चैनल जनरेट कर रहे हैं, हम इसे अपने प्रोसेस में पास कर रहे हैं, और अगर हम प्रोसेस को देखें, तो हम greeting को _"output.txt"_ नामक फ़ाइल में लिख रहे हैं और उस आउटपुट फ़ाइल को यहाँ नीचे आउटपुट ब्लॉक में वापस पास कर रहे हैं, इसे publish कर रहे हैं।

हालाँकि, हर तीन बार यह प्रोसेस इन तीन अलग-अलग कार्यों को चलाता है। वे सभी _"output.txt"_ नामक एक फ़ाइल जनरेट करते हैं, उन सभी आउटपुट फ़ाइलों को results डायरेक्टरी में publish किया जाता है, और वे सभी एक दूसरे को overwrite कर देते हैं। तो जो भी रिज़ल्ट फ़ाइल तुम्हें वहाँ मिलती है वह बस आखिरी वाली है जो जनरेट की गई थी, लेकिन बाकी सभी को clobber कर दिया। यह वास्तव में वह नहीं है जो हम चाहते हैं।

## 2.2.1. एक डायनामिक आउटपुट फ़ाइल नाम बनाना

इसे संभालने के अलग-अलग तरीके हैं, लेकिन अभी के लिए सबसे सरल है बस अलग-अलग अद्वितीय फ़ाइल नाम बनाना। तो हर बार जब कार्य एक अलग greeting के साथ चलता है, तो यह एक अलग आउटपुट फ़ाइल जनरेट करेगा, जो publish होने पर अब clash नहीं करेगी। और फिर हमें तीन अद्वितीय आउटपुट फ़ाइलें मिलेंगी।

हम इसे बिल्कुल उसी तरह करते हैं। हम इस वेरिएबल का उपयोग script ब्लॉक के भीतर कहीं भी कर सकते हैं और हम इसे कई बार उपयोग कर सकते हैं।

तो मैं इसे यहाँ पेस्ट कर सकता हूँ, _"$\{greeting\}\_output.txt"_, और फिर मुझे इसे यहाँ ऊपर भी पेस्ट करना होगा क्योंकि हम अब _output.txt_ नामक फ़ाइल नहीं बना रहे हैं। तो अगर मैं इसे अपडेट नहीं करता, तो Nextflow एक error के साथ crash हो जाएगा जो कहेगा कि उसे एक फ़ाइल की उम्मीद थी, जो कभी जनरेट नहीं हुई।

तो मुझे वहाँ भी वही करना होगा और मुझे double quotes का उपयोग करना होगा, single quotes नहीं, ताकि यह वेरिएबल समझा जाए।

ठीक है, चलो इसे आज़माते हैं और देखते हैं कि यह काम किया या नहीं। हम वर्कफ़्लो को फिर से चलाने वाले हैं। उम्मीद है कि यह हमें तीन अलग-अलग work डायरेक्टरी के भीतर तीन अलग-अलग कार्य दिखाएगा। और निश्चित रूप से, तुम यहाँ बाईं ओर results फ़ोल्डर में देख सकते हो। अब हमारे पास तीन अलग-अलग फ़ाइल नाम के साथ तीन अलग-अलग फ़ाइलें हैं और प्रत्येक में अलग-अलग सामग्री है जिसकी हम उम्मीद करते हैं। तो फ़ाइलें अब एक दूसरे को clobber नहीं कर रही हैं, और सब कुछ वहाँ है जैसा हम उम्मीद करते हैं।

यह एक तरह का तुच्छ सेटअप है जिससे हम यहाँ गुज़रे हैं, लेकिन यह कुछ मुख्य अवधारणाओं को रेखांकित करता है जिन्हें तुम्हें यह समझने की ज़रूरत है कि फ़ाइल publishing कैसे काम करती है, और कुछ चीज़ें जिनमें तुम traps के रूप में गिर सकते हो। तो उम्मीद है कि तुम अपने स्वयं के वर्कफ़्लो में इससे बच सकते हो।

यह भी ध्यान देने योग्य है कि हमने यहाँ जो किया है वह वास्तविक जीवन की स्थितियों में थोड़ा अव्यावहारिक है। हमने कुछ इनपुट डेटा लिया है और हम उस डेटा का उपयोग कर रहे हैं, लेकिन हम उस डेटा के बाद फ़ाइल का नामकरण भी कर रहे हैं, जो तुम आमतौर पर नहीं कर सकते।

तो वास्तविक अधिक परिपक्व Nextflow पाइपलाइन में, तुम अक्सर एक दिए गए नमूने से जुड़े सभी मेटाडेटा के साथ एक meta ऑब्जेक्ट को पास करोगे। फिर तुम उसके आधार पर डायनामिक फ़ाइल नाम बना सकते हो, जो बहुत अधिक व्यावहारिक है।

अगर तुम इसे best practices के साथ कैसे करना है इसमें रुचि रखते हो, तो _training.nextflow.io_ पर एक side quest है, जो विशेष रूप से metadata और meta maps के बारे में है, तो तुम अधिक विस्तार के लिए वहाँ खोद सकते हो।

## 3. एक array के माध्यम से कई इनपुट प्रदान करना

ठीक है। अगला हम थोड़ा explore करने वाले हैं कि चैनल कैसे संरचित हैं और वे कोडिंग भाषा में अन्य प्रकार के डेटा स्ट्रक्चर से कैसे भिन्न हैं। और मैं थोड़ा सोचने वाला हूँ कि मैं संभावित रूप से एक array का उपयोग कैसे कर सकता हूँ, जो एक परिचित अवधारणा हो सकती है अगर तुम अन्य भाषाओं से आए हो।

क्या मैं एक चैनल में एक array का उपयोग कर सकता हूँ? चलो कोशिश करते हैं। मैं एक array बनाने वाला हूँ, और मैंने इसे docs से कॉपी किया है, _"greetings_array"_ और _"Hello", "Bonjour"_ और _"Holà"_। और फिर मैं इसे यहाँ अपनी हार्डकोडेड स्ट्रिंग के बजाय डालने वाला हूँ। तो मैं "channel.of" _"greetings_array"_ कहने वाला हूँ, इस array को एक चैनल में पास कर रहा हूँ। चलो कोशिश करते हैं।

टर्मिनल लाओ, और पाइपलाइन चलाओ।

ठीक है। तुम देख सकते हो कि view स्टेटमेंट ने यहाँ हमारे array को उम्मीद के अनुसार प्रिंट किया, लेकिन फिर यह सारा लाल टेक्स्ट, या यह लाल नहीं होगा अगर तुम्हारे पास अभी भी _"-ansi-log"_ off है, लेकिन यह सारा लाल टेक्स्ट हमें बता रहा है कि कुछ गलत हुआ।

हमारे पास यहाँ अब एक अच्छा हरा टिक नहीं है। हमारे पास एक लाल क्रॉस है, और अगर मैं इसे थोड़ा चौड़ा करता हूँ ताकि यह पढ़ना आसान हो, तो Nextflow हमें बता रहा है कि क्या गलत हुआ।

तो चलो इसे सेक्शन दर सेक्शन तोड़ते हैं। यह कहता है कि error इसके कारण हुई, और फिर error का कारण, जो missing output files है। तो मूल रूप से उस output ब्लॉक ने कहा कि यह फ़ाइल बनाई जानी चाहिए और यह नहीं थी। अगला यह कहता है कि यह वह कमांड है जो execute की गई थी। तो यह मूल रूप से उस _.command.sh_ फ़ाइल की सामग्री है। यह इस तरह दिखती थी जब उन सभी वेरिएबल को डाला गया था।

और तुम यहाँ देख सकते हो कि हमारी echo कमांड वास्तव में केवल एक बार चलाई गई है और इसने पूरे array का उपयोग किया है, लेकिन एक स्ट्रिंग प्रतिनिधित्व में, जो वास्तव में वह नहीं है जो हम चाहते थे।

और फिर कमांड उस तरह से exit हुई, और वह work डायरेक्टरी थी जहाँ हम जा सकते हैं और थोड़ा और समझने के लिए फ़ाइलें देख सकते हैं।

ठीक है। तो फिर क्या हुआ था। Nextflow ने बस इस पूरे array को एक single channel element के रूप में प्रोसेस में पास कर दिया, जिसका मतलब था कि प्रोसेस केवल एक बार चला। इसका एक कार्य था और इसने डेटा का उपयोग उस संरचना में नहीं किया जिसकी हमें उम्मीद थी।

## 3.2. चैनल सामग्री को बदलने के लिए एक ऑपरेटर का उपयोग करना

तो हमें इस चैनल के साथ पहले कुछ करने की ज़रूरत है, इससे पहले कि इसका उपयोग किया जा सके। और यह ऑपरेटर का उपयोग करने के लिए एक मंच स्थापित कर रहा है, जो विशेष फ़ंक्शन हैं जिनका उपयोग हम चैनल सामग्री को manipulate करने के लिए चैनल पर कर सकते हैं।

इस मामले में, हम _flatten_ नामक कुछ का उपयोग करने जा रहे हैं। जिसे हम यहाँ चैनल के अंत में पास करते हैं। तो हम चैनल बनाते हैं और फिर हम _flatten_ चलाते हैं। और फिर से, अगर हम इस पर hover करते हैं, तो यह हमें VS Code में सीधे इस कमांड के लिए documentation दिखाता है, जो बहुत मददगार है। तुम Nextflow वेबसाइट, documentation पर भी ये सभी docs पा सकते हो।

मैं अभी इस कोड को चला सकता था और देख सकता था कि यह काम करता है या नहीं, लेकिन यह ऑपरेटर के भीतर और Nextflow कोड के भीतर डायनामिक कोड कैसे करना है यह पेश करने का एक अच्छा अवसर भी है, जिन्हें closures कहा जाता है।

तो मैं यहाँ एक view कमांड वापस जोड़ने वाला हूँ इससे पहले कि हम _flatten_ चलाएँ। और यहाँ इसमें ये घुमावदार ब्रैकेट हैं, जो डायनामिक closure है। और इसके भीतर बस कुछ arbitrary code है जो execute किया जाएगा, एक view ऑपरेटर के संदर्भ में।

यहाँ, यह कह रहा है कि greeting लो, जो view ऑपरेटर का इनपुट है, और वह यहाँ है। मैं इसे जो चाहूँ कह सकता था, मैं इसे _"foo"_ कह सकता था और मुझे बस इसे बाद में _"foo"_ के रूप में refer करने की ज़रूरत है। और फिर मैं इसके साथ कहता हूँ, यह return करो।

और फिर एक स्ट्रिंग return कर रहा हूँ जो कहती है before the flatten for a variable। बहुत सरल।

मैं अब इनमें से एक और बिल्कुल वैसा ही जोड़ने वाला हूँ, लेकिन मैं after _flatten_ कहने वाला हूँ।

तो यह क्या करता है, क्योंकि यह sequence में चलता है, तुम देखने वाले हो कि चैनल _flatten_ चलाने से पहले कैसा दिखता है, और फिर _flatten_ चलाने के बाद फिर से।

और फिर यह greeting चैनल अभी भी बनाया गया है, तो यह अभी भी प्रोसेस में पास होने वाला है। और उम्मीद है कि अब वर्कफ़्लो चलेगा। चलो इसे आज़माते हैं।

बढ़िया। तो सबसे पहली बात यह है कि पाइपलाइन इस बार crash नहीं हुई। हमारे पास तीन प्रोसेस थे जो ठीक से चले और हमें एक छोटा टिक मार्क मिला। और फिर हम देख सकते हैं कि हमारे view स्टेटमेंट ने काम किया।

हमारे पास before _flatten_ है, जो वह array है जो हमने पहले failure से देखा था, और फिर हमारे पास तीन बार after _flatten_ कहा गया था जहाँ हमारे पास _"Hello", "Bonjour"_, और वे अन्य तीन अलग-अलग elements array में हैं, जो अब जैसा हमने उम्मीद की थी, चैनल में तीन अलग-अलग elements हैं।

और तुम देख सकते हो कि _view_ ऑपरेटर तीन बार चलाया गया था। और ऐसा इसलिए है क्योंकि _flatten_ के बाद इस चैनल में अब तीन elements हैं। और इसलिए ऑपरेटर तीन बार कॉल किया जाता है।

बहुत जल्दी, मैं बस उल्लेख करूँगा कि जब मैं पहले channel factories बना रहा था, तो मैंने _"."_ किया, और फिर हमने देखा कि चैनल बनाने के बहुत सारे अलग-अलग तरीके थे, और उनमें से एक को "_fromList_" कहा जाता है। और वह वास्तव में विशेष रूप से इसी ऑपरेशन को करने के लिए डिज़ाइन किया गया है। तो हम बस from list greetings away कर सकते थे, और वह काम करेगा। यह थोड़ा साफ़ और अच्छा syntax है। लेकिन इस demonstration के उद्देश्यों के लिए, हम इसे थोड़ा अधिक step-by-step बनाना चाहते थे ताकि तुम देख सको कि चैनल को कैसे manipulate किया जा रहा है और अलग-अलग ऑपरेटर चैनल की सामग्री में क्या बदल सकते हैं।

## 4. CSV फ़ाइल से इनपुट मान पढ़ना

ठीक है, हम इसे थोड़ा और realistic कैसे बना सकते हैं? तुम शायद अपनी Nextflow पाइपलाइन में हार्ड कोडेड arrays के साथ बहुत सारा कोड बनाना नहीं चाहोगे। तुम शायद जब तुम launch करते हो तो बाहर से डेटा लेना चाहोगे, और वह डेटा लगभग निश्चित रूप से फ़ाइलों में होने वाला है।

तो अगली चीज़ जो हम करने वाले हैं वह यह है कि हम इसे replicate करने वाले हैं, लेकिन एक single CLI पैरामीटर से या एक हार्डकोडेड स्ट्रिंग या array से डेटा लेने के बजाय, हम इसे एक फ़ाइल से लेने वाले हैं।

तो चलो अपने greetings away से छुटकारा पाते हैं। और अब हम इस channel factory को फिर से बदलने वाले हैं। मैंने अभी कहा कि चुनने के लिए एक समूह था और एक है जिसे _".fromPath"_ कहा जाता है। और मैं इसे बताने वाला हूँ, इस मामले में, _params.input_ लो, जो हमारे इनपुट पर वापस जा रहा है जिसका हम पहले उपयोग कर रहे थे।

अब वह पैरामीटर वास्तव में उपयोग किए जाने के लिए तैयार नहीं है। हम अभी भी कह रहे हैं कि यह एक स्ट्रिंग है और यह यहाँ एक default के साथ हार्ड कोड किया गया है, लेकिन हम उस स्ट्रिंग को overwrite कर सकते थे। अब हम चाहते हैं कि यह इसके बजाय एक फ़ाइल हो। तो type अलग है। यह अब एक _String_ नहीं है। यह एक _Path_ है।

और फिर हम default सेट कर सकते हैं अगर हम चाहें, फिर से, एक Path पर। और अगर मैं बाईं ओर explore में देखता हूँ, तो तुम इस repository में, इस working डायरेक्टरी में देख सकते हो, मेरे पास data नामक एक डायरेक्टरी है। मेरे पास वहाँ _"greetings.csv"_ नामक एक फ़ाइल है।

तो मैं यहाँ बस default को _"data/greetings.csv"_ पर सेट कर सकता हूँ। अब, जब मैं इस पाइपलाइन को फिर से बिना किसी command line options के चलाता हूँ, तो यह इस default value का उपयोग करेगा। यह जानता है कि यह एक path है, इसलिए यह जानता है कि इसे एक path के रूप में handle करना चाहिए न कि एक स्ट्रिंग के रूप में।

और फिर यह इस _params.input_ से एक channel factory में पास होने वाला है और हमारा चैनल बनाने वाला है, जो फिर इस प्रोसेस में उपयोग होने वाला है जिसे _sayHello_ कहा जाता है। चलो इसे आज़माते हैं।

ठीक है। Failed। चिंता मत करो। यह उम्मीद थी। और अगर तुम training material का पालन कर रहे हो, तो तुम देखोगे कि यह वहाँ भी उम्मीद थी। चलो देखते हैं कि यहाँ क्या हो रहा है।

इसने पाइपलाइन चलाने की कोशिश की है। इसने प्रोसेस को execute करने की कोशिश की है, और इसे पहले जैसी ही error मिली है।

यहाँ यह कहता है: हमने _echo_ चलाने की कोशिश की, लेकिन इस CSV फ़ाइल की सामग्री को echo करने के बजाय, इसने बस path को echo किया। और तुम देख सकते हो कि यह यहाँ इस CSV फ़ाइल का पूरा absolute path है।

और फिर निश्चित रूप से, क्योंकि इसने उस वास्तव में जटिल path में लिखने की कोशिश की, यह वास्तव में नहीं जानता था कि क्या करना है। और यह प्रोसेस work डायरेक्टरी के दायरे से बाहर था।

मैंने शुरुआत में उल्लेख किया था कि Nextflow प्रत्येक executed कार्य को एक विशेष work डायरेक्टरी के भीतर encapsulate करता है। और अगर तुम डेटा लिखने की कोशिश करते हो, जो उस work डायरेक्टरी के बाहर है, तो Nextflow तुम्हें एक सुरक्षा सावधानी के रूप में रोक देगा। और यही यहाँ हुआ है। हमने एक absolute path पर लिखने की कोशिश की और Nextflow failed हो गया और हमें रोक दिया।

## 4.2. फ़ाइल को parse करने के लिए splitCsv() ऑपरेटर का उपयोग करना

ठीक है, चलो इस चैनल पर एक नज़र डालते हैं और देखते हैं कि यह कैसा दिखता है। हम _".view"_ कर सकते हैं, और मैंने इसे वेबसाइट से कॉपी किया है। तो _.view_, और हमारे पास यहाँ एक डायनामिक closure है और हम एक वेरिएबल नाम "_csv_" कहते हैं इनपुट के रूप में। तो वह चैनल सामग्री है, और हम कहते हैं before splitCsv, और यह इस तरह दिखता है।

अगर मैं इसे फिर से चलाता हूँ, तो यह अभी भी fail होगा, लेकिन यह हमें दिखाएगा कि इस चैनल के अंदर क्या है। यह विशेष रूप से रोमांचक नहीं है। यह वह _path_ वेरिएबल है। तो तुम देख सकते हो कि यह यहाँ बस एक स्ट्रिंग है क्योंकि इसे टर्मिनल पर प्रिंट किया जा रहा है, लेकिन यह एक _path_ ऑब्जेक्ट है, जिसमें इस फ़ाइल के बारे में जानकारी और मेटाडेटा है।

हम फ़ाइल के मेटाडेटा को इनपुट में पास नहीं करना चाहते। हम उस फ़ाइल की सामग्री को पास करना चाहते हैं। अगर हम _greetings.csv_ फ़ाइल को देखें, तो तुम यहाँ देख सकते हो कि इसमें ये अलग-अलग वेरिएबल हैं। _Hello, Bonjour, Holà_ फिर से। और ये वास्तव में वे चीज़ें हैं जिन्हें हम अपने प्रोसेस में पास करना चाहते हैं, न कि सिर्फ़ फ़ाइल को एक single ऑब्जेक्ट के रूप में।

तो हमें इस CSV फ़ाइल को parse करने की ज़रूरत है। हमें इसे unpack करने की ज़रूरत है, CSV फ़ाइल की सामग्री पर पहुँचने की ज़रूरत है, और फिर चैनल के भीतर सामग्री को प्रोसेस में पास करने की ज़रूरत है।

जैसा कि तुम शायद log message से बता सकते हो, हम _splitCsv_ का उपयोग करना चाहते हैं, जो एक और ऑपरेटर है, एक और channel ऑपरेटर। तो अगर मैं "_dot" "s"_ करता हूँ, और फिर तुम देख सकते हो कि यह auto suggested है। Oops, _splitCsv_ और कुछ ब्रैकेट।

और फिर _splitCsv_ के बाद, मैं एक और _view_ स्टेटमेंट डालने वाला हूँ बस ताकि हम देख सकें कि यह बाद में कैसा दिखता है। चलो पाइपलाइन चलाते हैं और देखते हैं कि हमें क्या मिला।

ठीक है। यह अभी भी failed हुआ, लेकिन एक नए और रोमांचक तरीके से, जो प्रगति है।

इस बार फिर से, हमारे पास अपनी स्क्रिप्ट के साथ कुछ समस्या है, जो render की गई है। अब। हमें अब final path नहीं मिला है, लेकिन हमें वेरिएबल की एक array मिली है, जो बहुत हद तक उस error जैसी दिखती है जो हमें पहले मिली थी जब हम एक array को एक fixed इनपुट के रूप में पास कर रहे थे।

view ऑपरेटर से हमारी logging के साथ, हम देख सकते हैं कि before _splitCsv_ path था। और निश्चित रूप से, after _splitCsv_, हमारे पास तीन अलग-अलग आउटपुट हैं और उनमें से प्रत्येक आउटपुट _greetings.csv_ फ़ाइल की प्रत्येक पंक्ति की तरह बहुत दिखता है, जो समझ में आता है।

तो यहाँ क्या हुआ है कि Nextflow ने इस CSV फ़ाइल को parse किया है, हमें तीन ऑब्जेक्ट दिए हैं, CSV फ़ाइल की प्रत्येक पंक्ति के लिए एक array। तो फिर तीन बार हमने एक single स्ट्रिंग value के बजाय वेरिएबल की एक array को चैनल में पास किया है।

ठीक है, तो पिछली बार जब हमें यह समस्या थी, तो हमने _flatten_ का उपयोग किया था। चलो बस बहुत जल्दी। flatten को try करते हैं और देखते हैं कि क्या होता है।

मैं इन वेरिएबल को जो चाहूँ कह सकता हूँ। तो मैं इसे _myarray_ कहने वाला हूँ क्योंकि यह अब वास्तव में एक CSV नहीं है। चलो इसे फिर से चलाने की कोशिश करते हैं और देखते हैं कि _flatten_ के साथ क्या होता है।

तो इस बार हम चलने वाले हैं, हमने CSV को तीन array ऑब्जेक्ट में parse किया, और फिर हमने इसे flatten किया। और इस बार यह pass हुआ। और Nextflow पाइपलाइन चली। हालाँकि तुम देख सकते हो कि _flatten_ वास्तव में शहर में जाता है और सब कुछ flatten कर देता है। और इसलिए हमें प्रत्येक पंक्ति के लिए तीन स्वतंत्र array entries मिलती हैं। और इसलिए इसने प्रोसेस को CSV की हर पंक्ति में तीन बार चलाया। और अब हमारे पास बहुत सारी results फ़ाइलें हैं, और 123, 456, और सभी प्रकार की चीज़ें, न कि सिर्फ़ CSV के पहले कॉलम, जो वास्तव में हम चाहते थे।

## 4.3. अभिवादन निकालने के लिए map() ऑपरेटर का उपयोग करना

तो हम सिर्फ़ पहले कॉलम पर कैसे पहुँचें? अगर flatten यहाँ बहुत सरल है, तो हमें एक अधिक जटिल ऑपरेटर की ज़रूरत है जहाँ हम वास्तव में customize कर सकते हैं और इसे बता सकते हैं कि हम CSV से क्या चाहते हैं।

ऐसा करने के लिए, हम _map_ का उपयोग करने जा रहे हैं। मूल रूप से _map_ बस कहता है, कुछ कोड चलाओ, हर element पर कुछ फ़ंक्शन जो मुझे दिया गया है और उस पर किसी प्रकार का transformation करो। और क्योंकि यह इतना लचीला है, तुम इसे Nextflow कोड में हर समय आते हुए देखोगे।

अपने आप में, यह कुछ नहीं करता। तो हम regular ब्रैकेट नहीं चाहते, हम यहाँ एक closure चाहते हैं और हमें इसे बताने की ज़रूरत है कि क्या करना है। तो मैं _"row"_ कहने वाला हूँ, क्योंकि इसे CSV से पंक्तियाँ दी जा रही हैं, तो यह एक logical वेरिएबल नाम है। इनपुट है। और मैं उस array के सिर्फ़ पहले element को return करना चाहता हूँ।

Nextflow में arrays zero based हैं, तो हम सिर्फ़ पहला element कहने वाले हैं, जो row zero है। अगर हम दूसरे कॉलम को चाहते, तो मैं one हो सकता था या तीसरा कॉलम two हो सकता था, और इसी तरह। हम यहाँ जो चाहें return कर सकते हैं, लेकिन मैं सिर्फ़ पहली value return करने वाला हूँ।

और अब, हम पाइपलाइन को फिर से चला सकते हैं और देख सकते हैं कि यह वही करती है जो हम उम्मीद करते हैं।

निश्चित रूप से, after _splitCsv_ हमारे पास हमारे arrays हैं, और फिर _map_ के बाद, हमारे पास हमारी अच्छी साफ़ स्ट्रिंग हैं, बस _"Hello", "Bonjour"_ और _"Holà"_। और पाइपलाइन अब वही कर रही है जो हम चाहते हैं। शानदार।

तो हम अब इन सभी view कमांड से छुटकारा पा सकते हैं। हमें अब उनकी ज़रूरत नहीं है।

## सारांश

हमने अपनी तरह की debugging समाप्त की और यह वह कोड है जिसके साथ हम समाप्त होते हैं। अपने CLI पैरामीटर को _input_ कहा जाता है, जिसे _Path_ के रूप में वर्गीकृत किया गया है। Nextflow path ढूँढता है, इसे लोड करता है, और CSV फ़ाइल को समझता है। सभी अलग-अलग पंक्तियों को return करता है। और फिर हम उस पंक्ति के सिर्फ़ पहले element को चैनल में map करते हैं जो हमें चैनल सामग्री देता है, जो प्रोसेस में पास की जाती है।

और प्रोसेस चैनल में प्रत्येक element पर चलता है, जो तीन है। और यह प्रोसेस को तीन बार चलाता है, इसे तीन कार्य देता है। और फिर उन results को वर्कफ़्लो से publish किया जाता है, प्रोसेस आउटपुट द्वारा उठाया जाता है। वर्कफ़्लो से publish किया जाता है और output ब्लॉक में _"hello_channels"_ नामक एक सबडायरेक्टरी में सेव किया जाता है।

बहुत बढ़िया। हम अब कुछ ऐसी चीज़ पर पहुँच रहे हैं जो एक वास्तविक जीवन की Nextflow पाइपलाइन से अधिक निकटता से मिलती-जुलती है जिसे तुम कुछ वास्तविक विश्लेषण के लिए चला सकते हो।

## सारांश

ठीक है। उम्मीद है कि अब तुम्हें यह महसूस हो रहा है कि Nextflow चैनल और ऑपरेटर क्या हैं और ऑपरेटर चैनल पर कैसे काम करते हैं और तुम उन्हें कैसे बना सकते हो।

चैनल, जैसा कि मैंने इस वीडियो की शुरुआत में कहा था, Nextflow का गोंद हैं। और तुम यहाँ देख सकते हो कि हम अलग-अलग इनपुट ले सकते हैं और उन्हें manipulate कर सकते हैं और उस डेटा को ले सकते हैं और फिर उन्हें downstream वर्कफ़्लो लॉजिक में पास कर सकते हैं।

और यह वर्कफ़्लो ब्लॉक यहाँ वास्तव में वह जगह है जहाँ तुम उस सभी parallelization और सभी चालाक लॉजिक को build करते हो, और Nextflow को समझाते हो कि अपने वर्कफ़्लो DAG को कैसे बनाना है, और अपनी पाइपलाइन को कैसे orchestrate करना है।

चैनल समझने के लिए सबसे आसान अवधारणा नहीं हैं। तो एक ब्रेक लो, इसके बारे में थोड़ा सोचो, शायद सामग्री को फिर से पढ़ो, और वास्तव में सुनिश्चित करो कि तुमने इन अवधारणाओं को समझ लिया है क्योंकि यह Nextflow की तुम्हारी समझ की कुंजी है और जितना बेहतर तुम चैनल और अलग-अलग channel ऑपरेटर और अलग-अलग channel factories को समझते हो। उतना ही अधिक मज़ा तुम्हें Nextflow लिखने में आएगा और तुम्हारी पाइपलाइन उतनी ही अधिक शक्तिशाली होगी।

यह Python या अन्य भाषाओं में regular programming के समान नहीं है। हम यहाँ _if_ स्टेटमेंट का उपयोग नहीं कर रहे हैं, यह चैनल और ऑपरेटर का उपयोग करके functional flow programming है। तो यह थोड़ा अलग है, लेकिन यह बेहद शक्तिशाली भी है।

यह इस अध्याय का अंत है। जाओ और एक त्वरित ब्रेक लो और मैं तुम्हें अगले वीडियो में भाग तीन के लिए देखूँगा जहाँ हम Hello Workflow से गुज़रने वाले हैं, और वर्कफ़्लो के बारे में थोड़ा और बात करने वाले हैं।

बिल्कुल पिछले अध्याय की तरह, यहाँ वेबपेज के नीचे कुछ quiz प्रश्न हैं, तो तुम इनके माध्यम से एक त्वरित रन कर सकते हो और सुनिश्चित कर सकते हो कि तुम सामग्री के सभी अलग-अलग हिस्सों को समझते हो जो हमने अभी किया है। और इसके अलावा, मैं तुम्हें अगले वीडियो में देखूँगा। बहुत-बहुत धन्यवाद।

ठीक है।
