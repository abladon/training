# भाग 2: Hello Channels - ट्रांसक्रिप्ट

<span class="ai-translation-notice">:material-information-outline:{ .ai-translation-notice-icon } AI-सहायता प्राप्त अनुवाद - [अधिक जानें और सुधार सुझाएं](https://github.com/nextflow-io/training/blob/master/TRANSLATING.md)</span>

<div class="video-wrapper">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/lJ41WMMm44M?si=xCItHLiOQWqoqBB9&amp;list=PLPZ8WHdZGxmXiHf8B26oB_fTfoKQdhlik" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

!!!note "महत्वपूर्ण नोट"

    यह पृष्ठ केवल ट्रांसक्रिप्ट दिखाता है। पूर्ण चरण-दर-चरण निर्देशों के लिए, [कोर्स सामग्री](../02_hello_channels.md) पर वापस जाएं।

    ट्रांसक्रिप्ट में दिखाए गए सेक्शन नंबर केवल संकेत के लिए प्रदान किए गए हैं और सामग्री में सभी सेक्शन नंबर शामिल नहीं हो सकते हैं।

## स्वागत

नमस्ते, Hello Nextflow के भाग दो में आपका स्वागत है।

इस अध्याय को Hello Channels कहा जाता है। हम Nextflow के इस मौलिक हिस्से के बारे में बात करने वाले हैं।

Channels वे चीजें हैं जो आपकी pipeline में विभिन्न चरणों को जोड़ती हैं, जिस तरह से आपका डेटा और लॉजिक आपके workflow के माध्यम से प्रवाहित होता है।

ठीक है, चलिए शुरू करते हैं।

चलिए training.nextflow.io पर जाकर शुरू करते हैं

साइडबार में Hello Nextflow और भाग दो पर क्लिक करें। Hello Channels.

सभी सामग्री यहां लिखी हुई है ताकि आप अपनी गति से अनुसरण कर सकें और जो कुछ भी आपसे छूट गया हो उसे पकड़ सकें।

एक बार जब आप वेबसाइट खोल लें, तो आप Codespaces लोड कर सकते हैं और हम पिछले अध्याय के अंत से जारी रखेंगे।

## 0. वार्म-अप: hello-channels.nf चलाएं

इस अध्याय के लिए, हम एक अलग फ़ाइल को संपादित करने जा रहे हैं। इसे Hello Channels कहा जाता है, तो आप इसे साइडबार में पा सकते हैं, इसे खोलने के लिए डबल क्लिक करें।

अब यदि आप अभी-अभी अध्याय एक से आए हैं, तो यह फ़ाइल आपको बहुत परिचित लगेगी। यहां शुरुआती बिंदु मूल रूप से वह है जहां हम अध्याय एक समाप्त करते हैं, हमारे process sayHello के साथ, हमारे input, output, हमारे publishDir और हमारे params.greeting, और हमारे सरल workflow के साथ।

हम एक नई फ़ाइल से शुरू कर रहे हैं, इसलिए यह सभी के लिए समान स्तर है, लेकिन यदि आप चाहें तो अपनी पिछली फ़ाइल के साथ जारी रख सकते हैं।

ध्यान दें, मैंने यहां सभी .nextflow\* फ़ाइलें और work डायरेक्टरी भी हटा दी हैं, बस ताकि यह एक स्वच्छ शुरुआती बिंदु हो। यह महत्वपूर्ण नहीं है कि आप ऐसा करें या नहीं, यह आप पर निर्भर है।

ठीक है। चलिए यह जांच कर शुरू करते हैं कि यह pipeline अभी भी उम्मीद के अनुसार काम करती है। मैं यहां terminal लाने जा रहा हूं।

"nextflow run hello-channels.nf" करें और enter दबाएं।

यह उस छोटे workflow को चलाने वाला है, हमारे sayHello चरण को चलाता है, उस hash के साथ एक work डायरेक्टरी उत्पन्न करता है, और यहां हमारा results फ़ोल्डर है और हमारी आउटपुट फ़ाइल है, बिल्कुल जैसा कि हमने अपने डिफ़ॉल्ट params.greeting से उम्मीद की थी।

तो यह बढ़िया है। अध्याय एक के बिल्कुल समान, जैसी उम्मीद थी वैसे काम कर रहा है।

## 1. channel के माध्यम से स्पष्ट रूप से variable inputs प्रदान करें

अध्याय एक में, आप वास्तव में पहले से ही channels का उपयोग कर रहे थे, आपको बस यह एहसास नहीं था। जब हमने यहां एक string निर्दिष्ट की, तो Nextflow ने स्वचालित रूप से हमारे लिए उस string के चारों ओर एक channel बना दिया, सिर्फ इसलिए क्योंकि यह जानता था कि हम एक process कॉल कर रहे थे, इसलिए हमें एक input channel की आवश्यकता थी।

सबसे पहले हम जो करने जा रहे हैं वह यह है कि वास्तव में channel को स्वयं टाइप करके इसे स्पष्ट बनाएं।

## 1.1. एक input channel बनाएं

तो मैं स्क्रिप्ट के नीचे workflow में जाने वाला हूं, और मैं कहने वाला हूं greeting_ch। यह एक परंपरा है जिसका हम अक्सर Nextflow कोड में उपयोग करते हैं, जब यह एक channel हो तो variable नाम के अंत में अंडरस्कोर ch रखने की, बस ताकि यह पहचानना आसान हो कि यह एक channel है, लेकिन आपको ऐसा करने की आवश्यकता नहीं है। Channel.of Hello Channels के बराबर।

हमने अभी जो उपयोग किया है उसे Nextflow भाषा में "Channel Factory" कहा जाता है। यह यहां यह चीज है, हम इस variable को एक नए channel पर सेट कर रहे हैं, और यहां यह channel factory हमारे लिए एक विशेष तरीके से एक channel बना रही है।

Nextflow में कुछ अलग-अलग channel factories हैं, विभिन्न प्रकार के inputs से channels बनाने के लिए। Dot of सबसे सरल है, और बस हम जो भी strings देते हैं उसे लेता है।

ध्यान दें कि जब मैं VS Code में इन शब्दों पर होवर करता हूं, तो Nextflow extension मुझे एक पॉपअप दे रहा है जो समझाता है कि यह syntax क्या करता है, और उस पॉपअप विंडो के नीचे एक और पढ़ें टेक्स्ट भी है।

यदि मैं उस पर क्लिक करता हूं, तो यह Nextflow docs खोल देगा। एक नए टैब में और मुझे सीधे इस विशिष्ट चीज़ के लिए documentation पर ले जाएगा। इस मामले में channel.of के लिए।

## 1.2. process कॉल में input के रूप में channel जोड़ें

ध्यान दें कि extension हमें एक चेतावनी भी दे रहा है, कह रहा है कि हमने यहां एक नया channel बनाया है, लेकिन इसे किसी भी चीज़ द्वारा उपयोग नहीं किया जा रहा है।

तो, चलिए इसे ठीक करते हैं। मैं नए channel का नाम लेने जा रहा हूं और मैं इस params.greeting को हमारे नए channel से बदलने जा रहा हूं।

ध्यान दें कि हम अब command line flag --greeting का उपयोग नहीं कर रहे हैं, params.greeting का उपयोग नहीं किया जा रहा है, हम इस string को hard code करने के लिए वापस जा रहे हैं। कोई बात नहीं। मैं बस चीजों को सरल रखने की कोशिश कर रहा हूं। हम बाद में वापस आएंगे और फिर से params का उपयोग करेंगे।

## 1.3. workflow कमांड फिर से चलाएं

ठीक है, चलिए बस दोबारा जांच करते हैं कि यह काम करता है। terminal लाएं और फिर से ध्यान दें। Nextflow run hello channels. output.txt की जांच करें, और वहां यह है।

बढ़िया थोड़ा उबाऊ उदाहरण, बिल्कुल वही करना जो हमने पहले किया था, लेकिन अब कम से कम तर्क थोड़ा स्पष्ट है। हम एक नए channel को लिखने के बारे में स्पष्ट हो रहे हैं।

हमने वही काम करने के लिए प्रभावी रूप से अधिक कोड लिखा है। लेकिन यह तब समझ में आने लगेगा जब हम अपने channels को बनाने के तरीके में थोड़ा अधिक जटिल हो जाएंगे।

## 2. कई input values पर चलाने के लिए workflow को संशोधित करें

ठीक है, चलिए इसे थोड़ा और दिलचस्प बनाते हैं। यह बहुत दुर्लभ है कि आप एक ही input पर Nextflow pipeline चलाना चाहें, तो चलिए इसे कई inputs देते हैं।

## 2.1. input channel में कई greetings लोड करें

यहां docs से। मैं इन विभिन्न strings को कॉपी करने जा रहा हूं, उनमें से तीन। Hello, Bonjour, Olà. ओह, Hope प्राप्त करें। Copilot कुछ अन्य सुझाव दे रहा है। तो चलिए उन्हें tab enter करते हैं।

यहां Nextflow docs हमें बताता है कि हम इस operator को कई values दे सकते हैं, इसलिए इसे काम करना चाहिए, लेकिन चलिए इसे आजमाते हैं और देखते हैं कि क्या होता है।

## 2.1.2. कमांड चलाएं और log output देखें

खैर। हां और नहीं। चलिए देखते हैं। यह कहता है कि पांच में से पांच कार्य यहां चल चुके हैं, लेकिन यह हमें केवल एक hash दिखाता है, जो थोड़ा अजीब है। कोई बात नहीं। सब कुछ उम्मीद के मुताबिक है। डिफ़ॉल्ट रूप से। Nextflow terminal पर आउटपुट के एक विशेष प्रकार का उपयोग करता है जिसे ANSI control codes कहा जाता है, जिसका मतलब है कि यह उन सभी विभिन्न processes का एक अच्छा संकुचित दृश्य देने के लिए कुछ पंक्तियों को अधिलेखित करता है जो चल रही हैं।

यह तब बहुत अधिक समझ में आता है जब आपके पास बड़े workflows हैं और सैकड़ों या हजारों विभिन्न नमूने चला रहे हैं। आप terminal पर इतना आउटपुट उत्पन्न कर सकते हैं, इसे देखना असंभव है, जबकि यह अपडेट होने वाला दृश्य आपको वास्तविक समय की प्रगति देता है।

## 2.1.3. -ansi-log false विकल्प के साथ कमांड फिर से चलाएं

यदि आप चाहें, तो आप इसे फिर से चला सकते हैं, और इस बार मैं एक अतिरिक्त Nextflow core तर्क का उपयोग करने जा रहा हूं जिसमें एक hyphen है, "-ansi-log false"। यह Nextflow log आउटपुट के पिछले संस्करण का उपयोग करता है। और यहां आप सभी व्यक्तिगत processes देख सकते हैं जो लॉन्च की गई हैं।

यह आप पर निर्भर है कि आप ऐसा करते हैं या नहीं। Nextflow से आउटपुट दोनों मामलों में बिल्कुल समान है।

## 2.2. सुनिश्चित करें कि आउटपुट फ़ाइल के नाम अद्वितीय होंगे

ठीक है, चलिए आउटपुट फ़ाइलों पर एक नज़र डालते हैं, फिर हम results पर जाएंगे। लेकिन केवल एक ही आउटपुट फ़ाइल है। क्या हुआ? हमने देखा कि process कई बार चली थी। हम work डायरेक्टरी में जा सकते हैं और सभी अलग-अलग hashes देख सकते हैं, सभी कार्य ठीक से निष्पादित किए गए थे। लेकिन यदि आपको याद है कि हमारे process में, हम सब कुछ एक output.txt फ़ाइल में सहेज रहे हैं और फिर उसे इस डायरेक्टरी में publish कर रहे हैं।

तो एक ही फ़ाइल पांच बार बनाई गई, और फिर इसे पांच बार अधिलेखित किया गया। और हमारे पास वह है जो कोई भी कार्य अंतिम रूप से निष्पादित हुआ।

## 2.2.1. एक dynamic आउटपुट फ़ाइल नाम बनाएं

जिस तरह से हम इसे ठीक करते हैं वह एक dynamic आउटपुट फ़ाइल नाम का उपयोग करके है। यहां हमारे पास पहले से ही process के भीतर greeting नामक एक variable है, इसलिए हम उसे आउटपुट फ़ाइल नाम में उपयोग कर सकते हैं। मैं उसे कॉपी करता हूं और मैं $greeting-output.txt करता हूं।

मैं इसे quotes में घेरने जा रहा हूं, बस ताकि bash किसी भी spaces से भ्रमित न हो जो यहां आ सकती हैं। और फिर मैं वही फ़ाइल नाम लेने जा रहा हूं और यहां आउटपुट को अपडेट करूंगा।

यह वास्तव में महत्वपूर्ण है कि आउटपुट इससे मेल खाए, क्योंकि अन्यथा, यह फ़ाइल नहीं मिलेगी और Nextflow क्रैश हो जाएगा।

मैं एक और वास्तव में महत्वपूर्ण संपादन करने जा रहा हूं, जो है कि मैं इन single quotes को double quotes में बदलने जा रहा हूं। ध्यान दें कि जब मैंने ऐसा किया तो कोड का रंग बदल गया। यह variable केवल तभी विस्तारित होता है जब हम double quotes का उपयोग करते हैं। यदि मैं यहां single quotes का उपयोग करता हूं, तो इसे एक literal value के रूप में उपयोग किया जाता है, और मुझे $greeting-output नामक एक ही फ़ाइल मिलेगी, जो मैं नहीं चाहता।

## 2.2.2. workflow चलाएं

तो चलिए double quotes वापस रखते हैं और इसे आजमाते हैं।

मैं शुरू करने से पहले अपनी डायरेक्टरी को साफ करने जा रहा हूं, ताकि नई फ़ाइलों को देखना आसान हो। मैं .nextflow, work, और results नामक किसी भी चीज़ को हटाने जा रहा हूं।

और मैं उस Nextflow कमांड को फिर से चलाने जा रहा हूं और देखते हैं कि कौन सी फ़ाइलें बनाई जाती हैं। तो यह वहां पांच processes चलाता है। यदि आप बहुत करीब से देख रहे थे, तो आपने देखा होगा कि वह line चलते समय अपडेट हो रही थी।

और अब हम results डायरेक्टरी में जा सकते हैं, और निश्चित रूप से, हमारे पास पांच अलग-अलग आउटपुट हैं, और वे सभी विभिन्न greeting के साथ prefixed हैं।

यदि मैं इनमें से प्रत्येक को खोलूं, तो हम देखेंगे कि उनमें से प्रत्येक में संबंधित greeting है। शानदार। यही हम चाहते हैं।

## 3. channel की सामग्री को transform करने के लिए एक operator का उपयोग करें

ठीक है, तो अब हम जानते हैं कि channels क्या हैं और हम जानते हैं कि channel factories क्या हैं। operators के बारे में क्या? यह Nextflow भाषा के एक हिस्से के लिए एक और शब्द है, जो functions की एक श्रृंखला है जो हमें channels पर संचालन करने की अनुमति देता है, उन पर कुछ चीजें करने के लिए। Nextflow, operators के एक suite के साथ आता है, जो हमें विभिन्न तरीकों से channels में हेरफेर करने की अनुमति देता है।

## 3.1. channel में input के रूप में values का एक array प्रदान करें

चलिए एक उदाहरण के साथ इसके माध्यम से काम करते हैं। मान लीजिए कि हम इन input strings को लेना चाहते हैं, लेकिन उन्हें सीधे channel factory में डालने के बजाय, हम उन्हें एक array के रूप में परिभाषित करना चाहते हैं।

## 3.1.1. input variable सेट करें

तो मैं इन्हें लेने जा रहा हूं और इसे ऊपर एक नई line के रूप में करूंगा और कहूंगा, greetings, array।

वहां हम जाते हैं। मैं उस array variable को लेने जा रहा हूं और इसे channel.of में डालूंगा, और save करूंगा।

## 3.1.3. workflow चलाएं

अब, देखते हैं क्या होता है। मेरे terminal पर वापस जाएं। मैं बस उन सभी अस्थायी फ़ाइलों को फिर से साफ करने जा रहा हूं। और चलिए workflow चलाते हैं।

अच्छा नहीं है। ठीक है। यह टूट गया। कोई बात नहीं। मुझे इस बार इसके टूटने की उम्मीद थी। जब कोई Nextflow workflow विफल हो जाता है तो क्या गलत होता है, इसे debug करना Nextflow developer होने का एक प्रमुख हिस्सा है। यह बहुत होगा और यह समझना महत्वपूर्ण है कि error message क्या कहता है और इससे कैसे निपटना है।

Nextflow, error messages वास्तव में काफी संरचित हैं। यह हमें बताता है कि कौन सी process गलत हुई। यह हमें एक कारण के लिए एक error message देता है। यह कहता है कि उस विशेष कार्य के भीतर चलाने की कोशिश की गई कमांड क्या थी, exit status क्या थी, आउटपुट क्या था जहां वह कार्य work डायरेक्टरी थी।

ध्यान दें कि मैं VS Code में इसे option, click कर सकता हूं और यह इसे एक साइडबार में खोलता है ताकि मैं सीधे वहां जा सकूं और इन सभी छिपी हुई फ़ाइलों को देख सकूं, जिनके बारे में हमने पिछले अध्याय में बात की थी, जिसमें .command.sh फ़ाइल भी शामिल है। यह आप देख सकते हैं कि वही है जो यहां निष्पादित की गई commands के समान है।

इस फ़ाइल को देखकर, हम यह समझ सकते हैं कि यहां क्या गलत हुआ होगा, array में प्रत्येक तत्व के लिए एक ही कार्य चलाने के बजाय, पिछली बार जैसा किया था, इसने बस पूरे array को एक बार में string के रूप में प्रदान किया। इसलिए हमें channel में पास करने से पहले उस array को अलग-अलग values में unpack करने की आवश्यकता है। चलिए वापस जाते हैं और देखते हैं कि क्या हम एक operator का उपयोग करके ऐसा कर सकते हैं।

## 3.2. channel की सामग्री को transform करने के लिए एक operator का उपयोग करें

इस मामले में, हम array को channel में पास करने से पहले बदलने नहीं जा रहे हैं। हम channel को समायोजित करने जा रहे हैं ताकि यह उस तरह से व्यवहार करे जिसकी हम उम्मीद करते हैं। हम ऐसा flatten operator का उपयोग करके करने जा रहे हैं, dot टाइप करना शुरू कर सकते हैं और हम देख सकते हैं कि VS Code extension उन सभी विभिन्न operators का सुझाव देना शुरू कर देता है जो हमारे पास उपलब्ध हैं।

## 3.2.1. flatten() operator जोड़ें

और मैं flatten का चयन करने जा रहा हूं। ध्यान दें कि white space इस संदर्भ में Nextflow के लिए मायने नहीं रखता है। इसलिए यदि आप चाहें तो आप इन operators को एक नई line पर रख सकते हैं। इसलिए मैं इसे यहां नीचे छोड़ सकता हूं और इसे indent कर सकता हूं ताकि यह ".of" के नीचे बैठे और आप देखेंगे कि लोग अक्सर इस तरह के बहुत सारे operators को एक channel पर chain करते हैं और इसे इस तरह indent करते हैं ताकि यह पढ़ने में आसान हो।

आप यह भी देख सकते हैं, पहले की तरह मैं इस पर hover कर सकता हूं और पढ़ सकता हूं कि flatten operator क्या कर रहा है, और यदि मैं चाहूं तो documentation के लिए एक link का पालन भी कर सकता हूं।

तो यह operator इस channel को ले रहा है, जिसके भीतर एक एकल array है, और array values को अलग कर रहा है।

## 3.2.2. channel की सामग्री का निरीक्षण करने के लिए view() जोड़ें

हम विशेष view operator का उपयोग करके channels के अंदर झांक सकते हैं, और मैं उनमें से कुछ को यहां जोड़ने जा रहा हूं। यह अन्य भाषाओं में print statements का उपयोग करने जैसा है। इसलिए मैं dot view करने जा रहा हूं और फिर मैं इन squiggly brackets का उपयोग करूंगा।

इसे closure कहा जाता है। यह मूल रूप से view operator को अतिरिक्त कोड देता है, जिसे यह channel के भीतर प्रत्येक item पर निष्पादित करेगा। इस मामले में, मैं कहने जा रहा हूं greeting before flatten। Greeting.

मैं यहां एक variable परिभाषित कर रहा हूं, जो केवल इस closure के दायरे में है। तो यह variable केवल यहां उपयोग किया जाता है और मैं इसे जो भी चाहता था कह सकता था। यह वास्तव में मायने नहीं रखता। मैं बस इसे पढ़ने में आसान बनाने के लिए greeting का उपयोग कर रहा हूं।

कुछ Nextflow pipelines में, आप लोगों को "$it" नामक एक विशेष implicit variable का उपयोग करते हुए देख सकते हैं। ऐसा। यह Nextflow कोड के भीतर एक विशेष variable है, जो एक shorthand है ताकि आपको variable की थोड़ी परिभाषा नहीं करनी पड़े। हालांकि, समय के साथ हम सोच रहे हैं, यह उन लोगों के लिए बहुत स्पष्ट नहीं है जो Nextflow में नए हैं, और हम अब "$it" के उपयोग को हतोत्साहित करते हैं।

इसलिए मैं greeting के पिछले व्यवहार के साथ बने रहने जा रहा हूं और इसे इस तरह उपयोग करने जा रहा हूं क्योंकि यह अधिक स्पष्ट है और यह स्पष्ट है कि क्या हो रहा है।

फिर मैं इस line को कॉपी करूंगा और flatten तर्कों के बाद बिल्कुल वही फिर से करूंगा। view operator थोड़ा विशेष है क्योंकि यह elements पर कुछ करता है, लेकिन यह उन्हें अगले operator को पास करना जारी रखता है ताकि हम इसे इस तरह के operations की chain के बीच में chain कर सकें, और यह वहां status प्रिंट करेगा और आगे बढ़ता रहेगा। तो उम्मीद है कि यह हमें दिखाएगा कि flatten operator से पहले और बाद में channel कैसा दिखता है।

## 3.2.3. workflow चलाएं

चलिए इसे आजमाते हैं। साफ़ करें। workspace में सब कुछ साफ़ करें। pipeline फिर से चलाएं।

ठीक है, तो हम देख सकते हैं कि इसने हमारी पांच processes फिर से चलाई। फिर, यह एक error के साथ क्रैश नहीं हुआ, इसलिए यह निश्चित रूप से अच्छा है। और अब हमारे पास before flatten है और यह निश्चित है कि हमारे पास हमारा array है और हमारे पास after flatten है, पांच बार प्रिंट किया गया array के प्रत्येक तत्व के लिए एक बार। यही हम आशा कर रहे थे। तो यह वास्तव में अच्छी खबर है। और यह कोड से हम जो उम्मीद करते हैं उसके अनुरूप है।

हमें अब इन debug statements की आवश्यकता नहीं है, इसलिए मैं या तो उन्हें comment कर सकता हूं या हटा सकता हूं। मैं अपने कोड को अच्छा और साफ रखने के लिए उन्हें हटाने जा रहा हूं। ठीक है, बढ़िया। यह उदाहरण अब अच्छी तरह से काम कर रहा है और हम देखना शुरू कर सकते हैं कि channels थोड़ी अधिक जटिल logic कैसे कर सकते हैं।

## 4. CSV फ़ाइल से input values को parse करने के लिए एक operator का उपयोग करें

अब हम इसके बजाय inputs की एक श्रृंखला के साथ एक फ़ाइल का उपयोग करके ऐसा करने की कोशिश करने जा रहे हैं। यह metadata के sample sheet या CSV का उपयोग करके Nextflow pipelines लिखने का एक बहुत ही सामान्य तरीका है।

## 4.1. greetings के स्रोत के रूप में एक CSV फ़ाइल की अपेक्षा करने के लिए स्क्रिप्ट को संशोधित करें

यदि मैं साइडबार पर जाता हूं, तो आप उदाहरण repository में greetings.csv देख सकते हैं, और यह एक बहुत ही, बहुत ही सरल CSV फ़ाइल है जिसमें तीन अलग-अलग greetings के साथ केवल तीन lines हैं। देखते हैं कि क्या हम इस CSV फ़ाइल का उपयोग अपने workflow के भीतर कर सकते हैं।

अब मैं params का उपयोग करने के लिए वापस जा रहा हूं जैसा कि हमने अध्याय एक में किया था, ताकि हम एक command line input प्राप्त कर सकें।

मैं इस greetings array को हटाने जा रहा हूं।

## 4.1.1. CSV फ़ाइल को इंगित करने के लिए input पैरामीटर को स्विच करें

मैं params greeting को फ़ाइल नाम पर सेट करने जा रहा हूं, जो greetings.csv है, और मैं channel उत्पन्न करने के लिए इस विशेष variable का उपयोग करने जा रहा हूं। मैं उसे वहां डालने जा रहा हूं, और errors चली जाती हैं। याद रखें कि यह अब इस variable को डिफ़ॉल्ट रूप से सेट कर रहा है। इसलिए यदि मैं किसी तर्क के बिना pipeline चलाता हूं, तो यह greetings.csv का उपयोग करेगा, लेकिन यदि मैं चाहूं तो इस variable को अधिलेखित करने के लिए मैं --greeting कर सकता था।

## 4.1.2. एक फ़ाइल को संभालने के लिए डिज़ाइन किए गए channel factory पर स्विच करें

ठीक है, हम अब एक string या strings के एक array के बजाय एक फ़ाइल पास कर रहे हैं, इसलिए हमें शायद एक अलग channel factory की आवश्यकता है।

हम "of" से छुटकारा पाने जा रहे हैं जिसे हम अब तक उपयोग कर रहे हैं, और इसके बजाय .fromPath का उपयोग करें। यह बिल्कुल वही करता है जो यह लगता है। यह एक string फ़ाइल नाम या glob का उपयोग करके values के बजाय paths के साथ एक channel बनाता है। मैं flatten operator को भी हटाने जा रहा हूं क्योंकि अब हमें इसकी आवश्यकता नहीं है, अब जब हम एक फ़ाइल पास कर रहे हैं।

## 4.1.3. workflow चलाएं

मैं save करने जा रहा हूं, terminal खोलूंगा, workflow चलाऊंगा, और फिर देखूंगा कि क्या होता है।

ठीक है। यह फिर से क्रैश हो गया। चिंता मत करो। मुझे इसकी भी उम्मीद थी। आइए error message पर एक नज़र डालें और देखें कि क्या हम यह पता लगा सकते हैं कि क्या गलत हो रहा है। यहां हम निष्पादित कमांड देख सकते हैं, और पहले की तरह थोड़ा जहां हमारे पास पूरा array प्रिंट था। अब हमारे पास फ़ाइल path है जिसे कमांड में echoed किया जा रहा है, फ़ाइल की सामग्री के माध्यम से जाने के बजाय।

## 4.2. फ़ाइल को parse करने के लिए splitCsv() operator का उपयोग करें

तो फ़ाइल की सामग्री का उपयोग करने के लिए, हमें एक और operator की आवश्यकता है। इसके लिए जो operator हम उपयोग करने जा रहे हैं उसे splitCsv कहा जाता है। समझ में आता है, क्योंकि यह एक CSV फ़ाइल है जिसे हम लोड कर रहे हैं।

## 4.2.1. channel पर splitCsv() लागू करें

ठीक है, तो splitCsv। Close bracket। हमें यहां किसी तर्क की आवश्यकता नहीं है। और फिर, मैं यह समझने के लिए कुछ view operators का उपयोग करने जा रहा हूं कि यहां क्या हो रहा है।

.view csv after splitCsv। Before split Csv.s

## 4.2.2. workflow फिर से चलाएं

ठीक है, चलिए इसे चलाने और देखने की कोशिश करते हैं कि क्या होता है।

ठीक है, इस बार हमें थोड़ा अधिक आउटपुट मिला है, लेकिन यह अभी भी विफल रहा। हम view statements को देख सकते हैं, और यहां आप before split CSV देख सकते हैं, और हमारे पास एक फ़ाइल path है जैसा कि हमने पिछले error message में देखा था। After split CSV, अब हमारे पास तीन values हैं जो CSV फ़ाइल में तीन lines के अनुरूप हैं।

हालांकि, आप देख सकते हैं कि इनमें से प्रत्येक value square brackets से घिरी हुई है। तो उनमें से प्रत्येक अपने आप में एक array था, और इसने हमें वही area दिया है जो हमारे पास पहले था जहां यह एक ही string के बजाय एक array को echo करने की कोशिश कर रहा है।

यदि हम एक CSV फ़ाइल के बारे में सोचते हैं, तो यह एक प्रकार से समझ में आता है। आमतौर पर, एक CSV फ़ाइल में rows और columns होंगे, इसलिए split CSV दो आयामी array करता है। array का पहला आयाम प्रत्येक row है, और फिर एक दूसरा आयाम है, जो प्रत्येक row के लिए प्रत्येक column है।

तो यहां हमारे पास प्रत्येक line पर केवल एक ही value है, इसलिए हमारे पास एक ही column है, इसलिए हमारे पास फ़ाइल की प्रत्येक line के लिए एक one element array है।

कोई बात नहीं। हमें बस parsed CSV फ़ाइल की प्रत्येक line के लिए उस array को collapse करने के लिए एक और operator की आवश्यकता है। चलिए इसे साफ करते हैं। terminal से छुटकारा पाएं और देखें कि हम क्या कर सकते हैं।

## 4.3. greetings निकालने के लिए map() operator का उपयोग करें

अब हम flatten operator का फिर से उपयोग कर सकते हैं, जिसे हमने पहले उपयोग किया था। हमने देखा है कि यह कैसे एक array को values की एक श्रृंखला में collapse कर सकता है, जो यहां बहुत अच्छी तरह से काम करेगा। लेकिन मैं map operator नामक एक और operator को प्रदर्शित करने के अवसर का उपयोग करने जा रहा हूं, जो workflows के भीतर बहुत आम है।

## 4.3.1. channel पर map() लागू करें

मैं dot map करने जा रहा हूं और मैं item item[0] करने जा रहा हूं।

यदि आप अन्य कोड भाषाओं का बहुत सारा कोड लिखते हैं, तो आप map operator से पहले से ही परिचित हो सकते हैं। यह एक iterable, जैसे कि एक array या एक channel लेता है, और यह उसके प्रत्येक value पर कुछ operation करता है।

यहां हम कह रहे हैं कि हमें इस closure के दायरे में item नामक एक variable को परिभाषित करना चाहिए, और फिर हम चाहते हैं कि बस, उस array में पहला value return करें। तो item index zero।

यह प्रभावी रूप से array को flatten कर रहा है। आप देख सकते हैं कि हम इसे कैसे और अधिक जटिल होने के लिए बढ़ा सकते हैं, हालांकि: यदि हमारी CSV फ़ाइल में छह columns थे, लेकिन हम केवल चौथे column में रुचि रखते हैं, तो हम यहां एक विशिष्ट index तक पहुंच सकते हैं। या downstream processing को पास करने से पहले value पर किसी भी अन्य प्रकार का operation कर सकते हैं।

तो map operator बेहद लचीला है और flight में channels को संशोधित करने के लिए बहुत शक्तिशाली है। आइए एक और view statement डालें बस ताकि हम देख सकें कि यह हमारे execution में क्या कर रहा है। उस line को adjudicate कर सकते हैं और इसे नीचे ले जा सकते हैं। और after map।

## 4.3.2. workflow एक बार फिर चलाएं

आइए terminal लाएं और workflow चलाने की कोशिश करें।

ठीक है, इस बार कोई errors नहीं। यह एक अच्छा संकेत है। अब हम view statements से इन सभी विभिन्न आउटपुट के माध्यम से जा सकते हैं। Before split CSV, हमारे पास एक एकल path था। After split CSV, हमारे पास single value arrays थे, और फिर after map, हमारे पास बिना किसी array syntax के बस values हैं। चलिए results डायरेक्टरी में जाते हैं, और यहां हमारी आउटपुट फ़ाइलें बिल्कुल वैसे ही व्यवहार कर रही हैं जैसे हम चाहते थे।

यहां थोड़ा बोनस है। आप वास्तव में देख सकते हैं कि view operators उस क्रम में थोड़े मिश्रित हैं जिसमें उन्होंने आउटपुट किया है। ऐसा इसलिए है क्योंकि Nextflow इन विभिन्न कार्यों के parallelization कर रहा है। तो इसने CSV को विभाजित करने के बाद, इस channel में तीन elements हैं, और यह उन तीन elements के processing को स्वचालित रूप से parallel में संभाल रहा है। इसका मतलब है कि आउटपुट का क्रम stochastic है और भिन्न हो सकता है। इस मामले में, ऐसा हुआ कि कुछ view operators बाद के चरण के पूरा होने के बाद return हुए, और इसलिए यह इस क्रम में आया।

यदि मैं फिर से वही workflow चलाता हूं। तब निश्चित रूप से, यह एक अलग क्रम में आया है और इस बार हमें split CSVs और maps उस क्रम में मिले हैं जिसकी हम उम्मीद करते हैं।

तो बस ध्यान रखें, आप एक process कार्य से आउटपुट के क्रम पर भरोसा नहीं कर सकते क्योंकि Nextflow आपके लिए स्वचालित रूप से इस parallelization को संभाल रहा है। Nextflow अपने data flow logic के साथ आपके लिए ऐसा करता है, और यही Nextflow की वास्तविक शक्ति है।

ठीक है, यह शायद पूरे प्रशिक्षण के सबसे महत्वपूर्ण अध्यायों में से एक है। एक बार जब आप channels, channel factories और operators को समझ जाते हैं, तो आप Nextflow की ताकत और इसे एक प्रोग्रामिंग भाषा के रूप में अद्वितीय बनाने वाली चीज़ में प्रवेश करना शुरू कर देते हैं। यह functionality Nextflow को आपके लिए आपके सभी workflows को parallelize करने और एक बहुत ही स्वच्छ syntax और एक push data flow model के साथ अत्यंत जटिल workflow logic उत्पन्न करने की अनुमति देती है। यह पहली बार में थोड़ा अजीब concept हो सकता है, लेकिन एक बार जब आप इस तरह कोड लिखने के आदी हो जाते हैं, तो यह जल्दी से स्वाभाविक महसूस होगा और इससे पहले कि आप इसे जानें, आप शानदार workflows लिख रहे होंगे।

ब्रेक लें, चाय का एक कप, घूमें और चलिए अध्याय तीन की ओर बढ़ते हैं, जहां हम इन अवधारणाओं को अधिक जटिल workflows में विस्तारित करना शुरू करते हैं। अगले वीडियो में मिलते हैं।

[अगला वीडियो ट्रांसक्रिप्ट :octicons-arrow-right-24:](03_hello_workflow.md)
